In Scala, Lists are SEQUENCES, which means data is stored
in elements that can be accessed via a sequential Integer
index.  The following line of code creates a List of 3
integers that's initialized to the values of 1, 2 and 3.

val myList:List[Int] = List[Int](1, 2, 3)

The square brackets '[]' in the above code indicates that the
List is a paramaterized type.  In the above example, this
paramaterized type is declared to be of type Int.  Like the
above line of code, the following line of code also creates
a List of 3 integers that's initialized to the values of
1, 2 and 3.

var myList = List(1, 2, 3)

Even though the above myList is declared as a var, we can't change the
values contained in each List element.  A List in Scala is IMMUTABLE,
which means a List's element values can never be altered, even if
its a var.  The var indicates that myList can be used to point
to a different List.  For example, you can do the following:

var myList = List(1, 2, 3);
myList = List(9, 8, 7);  // Allowed because myArray is a var.

Unlike Arrays, Lists cannot be multi-dimensional.  You can PREPEND
values to an existing var List by using the cons operator (::).
Note that this can be done only with a var List, not a val List.
Here's an example.

var myList = List(1, 2, 3);
myList = 0::myList
myList.foreach(println)

Prepending a value to a List, as shown above, literally creates a new List.

Since all Lists (including empty lists) end with a Nil value, you
cannot append values to an existing List, even if it's a var List.
The following example shows us that an empty List contains a single
Nil value.  We can detect that a List is empty by checking to see
if the List == null, or by calling the isEmpty method, which is preferable.

val myList = List()
if (myList == Nil)
{
  println("myList == Nil")
}
if (myList.isEmpty)
{
  println("myList is empty.")
}

Below is Scala code that performs a mathematical operation
on all elements in a List, using a recursive function.
========================================================================
========================================================================
object Demo
{
  def main(args: Array[String])
  {
    val myList:List[Int] = List[Int](1, 2, 3, 4, 5, 6, 7);

    println("operateOnList() result = "  + operateOnList(myList, _+_))
    println("operateOnList2() result = " + operateOnList2(myList, _+_))
  }

  /**
    * This operateOnList() function is identical in behavior to the
    * below operateOnList2() function.
    */
  def operateOnList(list:List[Int], func:(Int, Int) => Int):Int =
  {
    if (list.tail.isEmpty)
    {
      list.head
    }
    else
    {
      func(list.head, operateOnList(list.tail, func))
    }
  }

  /**
    * This operateOnList2() function is identical in behavior to the
    * above operateOnList() function.
    */
  def operateOnList2(list:List[Int], func:(Int, Int) => Int):Int =
  {
    list match
    {
      case a::Nil => a
      case a::t => func(a, operateOnList2(t, func))
      case _ => 0
    }
  }
}
===================================================================
The following is a list of methods that can be called on BOTH
Arrays and Lists.  See pages 143-148 in the Scala book for details.

BASIC METHODS:
___ drop - EXAMPLE:
           val myList:List[String] = List("abc", "def", "ghi", "jkl", "mno", "pqr")
           val newList = myList.drop(1)
           println("newList = " + newList) // Prints:  newList = List(def, ghi, jkl, mno, pqr)
___ init - EXAMPLE:
           val myList:List[String]  = List("abc", "def", "ghi", "jkl", "mno", "pqr")
           val newList:List[String] = myList.init
           println("newList = " + newList) // Prints:  newList = List(abc, def, ghi, jkl, mno)
___ last - EXAMPLE:
           val myList:List[String]  = List("abc", "def", "ghi", "jkl", "mno", "pqr")
           val newList:String = myList.last
           println("newList = " + newList) // Prints:  newList = List(pqr)
___ slice - EXAMPLE:
            val myList:List[String]  = List("abc", "def", "ghi", "jkl", "mno", "pqr")
            val newList:List[String] = myList.slice(2,5)
            println("newList = " + newList) // Prints: newList = List(ghi, jkl, mno)
___ splitAt - EXAMPLE:
              val myList:List[String]  = List("abc", "def", "ghi", "jkl", "mno", "pqr")
              val newList:(List[String], List[String]) = myList.splitAt(3) // newList is a tuple type.
              println("newList = " + newList) // Prints: newList = (List(abc, def, ghi),List(jkl, mno, pqr))
___ take - EXAMPLE:
           val myList:List[String]  = List("abc", "def", "ghi", "jkl", "mno", "pqr")
           val newList:List[String] = myList.take(3)
           println("newList = " + newList) // Prints: newList = List(abc, def, ghi)
___ takeRight - EXAMPLE:
                val myList:List[String]  = List("abc", "def", "ghi", "jkl", "mno", "pqr")
                val newList:List[String] = myList.takeRight(2)
                println("newList = " + newList) // Prints: newList = List(mno, pqr)

BOOLEAN TESTS:
___ contains - EXAMPLE:
               val myList:List[String]  = List("abc", "def", "ghi", "jkl", "mno", "pqr")
               val result:Boolean = myList.contains("pqr")
               println("result = " + result) // Prints: result = true
___ endsWith - EXAMPLE:
               val myList:List[String]  = List("abc", "def", "ghi", "jkl", "mno", "pqr")
               val result:Boolean = myList.endsWith(List("pqr"))
               println("result = " + result) // Prints: result = true
___ isEmpty - EXAMPLE:
              val myList1:List[String] = List()
              val myList2:List[String] = List("abc", "def", "ghi", "jkl", "mno", "pqr")
              val result1:Boolean = myList1.isEmpty
              val result2:Boolean = myList2.isEmpty
              println("result1 = " + result1 + ",  result2 = " + result2) // Prints: result1 = true,  result2 = false
___ nonEmpty - The opposite of the isEmpty method.
___ startsWith - EXAMPLE:
                 val myList1:List[String] = List("abc", "def", "ghi", "jkl", "mno", "pqr")
                 val myList2:List[String] = List("abc", "def")
                 val result:Boolean = myList1.startsWith(myList2)
                 println("result = " + result) // Prints: result = true


SEARCHING:
___ indexOf - EXAMPLE:
              val myList:List[String] = List("abc", "def", "ghi", "jkl", "mno", "mno")
              val result:Int = myList.indexOf("mno")
              println("result = " + result) // Prints: result = 4
___ lastIndexOf - EXAMPLE:
                  val myList:List[String] = List("abc", "def", "ghi", "jkl", "mno", "mno")
                  val result:Int = myList.lastIndexOf("mno")
                  println("result = " + result) // Prints: result = 5
___ diff - EXAMPLE:
           val myList1:List[String] = List("abc", "def", "ghi", "jkl", "mno", "pqr")
           val myList2:List[String] = List("pqr", "mno", "jkl", "ghi", "def", "abc")
           val myList3:List[String] = List("mno", "abc")
           val result1:List[String] = myList1.diff(myList2)
           val result2:List[String] = myList1.diff(myList3)
           println("result1 = " + result1 + ", result2 = " + result2) // Prints: result1 = List(), result2 = List(def, ghi, jkl, pqr)
___ mkString EXAMPLE:
             val myList:List[String] = List("abc", "def", "ghi", "jkl", "mno", "pqr")
             println("myList                               = " + myList)
             println("myList.mkString                      = " + myList.mkString)
             println("myList.mkString(\" + \")               = " + myList.mkString(" + "))
             println("myList.mkString(\"BEGIN\", \"_\", \"END\") = " + myList.mkString("BEGIN", "_", "END"))
             // PRINTS THE FOLLOWING 4 LINES:
             myList                               = List(abc, def, ghi, jkl, mno, pqr)
             myList.mkString                      = abcdefghijklmnopqr
             myList.mkString(" + ")               = abc + def + ghi + jkl + mno + pqr
             myList.mkString("BEGIN", "_", "END") = BEGINabc_def_ghi_jkl_mno_pqrEND
___ reverse - EXAMPLE:
              val myList:List[String] = List("abc", "def", "ghi", "jkl", "mno", "pqr")
              println("myList.reverse = " + myList.reverse) // Prints:  myList.reverse = List(pqr, mno, jkl, ghi, def, abc)
___ toList  - EXAMPLE:
              val myArray:Array[String] = Array("abc", "def", "ghi", "jkl", "mno", "pqr")
              val myList:List[String]   = myArray.toList
              println(myList) // Prints: List(abc, def, ghi, jkl, mno, pqr)
___ toArray - EXAMPLE:
              val myList:List[String]   = List("abc", "def", "ghi", "jkl", "mno", "pqr")
              val myArray:Array[String] = myList.toArray
              myArray.foreach(println)
              // PRINTS THE FOLLOWING 6 LINES:
              abc
              def
              ghi
              jkl
              mno
              pqr
___ zip
___ zipWithIndex
___ product (Multiplies all memebers)
___ sum (Adds all members)

HIGHER-ORDER METHODS:
___ count
___ dropWhile - EXAMPLE:
                val strList:List[String] = List[String]("str1_abc_junk", "str2_abc_stuff", "str3_qrs_things", "str4_xyz_trash")
                val result:List[String] = strList.dropWhile(_.contains("abc"))
                result.foreach(println) // prints: str3_qrs_things  str4_xyz_trash

___ exists - EXAMPLE 1:
             val strList:List[String] = List[String]("str1_abc_junk", "str2_jkl_stuff", "str3_qrs_things", "str4_xyz_trash");
             val result:Boolean = strList.exists(_.compareTo("str3_qrs_things") == 0)
             println(result) // result = true
             EXAMPLE 2:
             val intList:List[Int] = List[Int](1, 2, 3, 4, 5, 6, 7);
             val result:Boolean = intList.exists(x => x==7)
             println(result) // result = true
___ filter - EXAMPLE:
             val intList:List[Int] = List[Int](1, 2, 3, 4, 5, 6, 7)
             val result:List[Int] = intList.filter(_ > 6)
             println(result) // result = List(7)
___ filterNot - The opposite of the filter method.
___ flatMap - EXAMPLE:
              The flatMap method is essentially a combination of the map
              method being run first, followed by the flatten method.
              val fish:List[String]               = List[String]("alewife", "bass", "perch", "northern", "walleye")
              val waterBirds:List[String]         = List[String]("eagle", "duck", "goose")
              val waterAnimals:List[List[String]] = List[List[String]](fish, waterBirds)
              val flatMap:List[String]            = waterAnimals.flatMap(x => x)
              println("fish                 = " + fish)
              println("waterBirds           = " + waterBirds)
              println("waterAnimals         = " + waterAnimals)
              println("flatMap waterAnimals = " + flatMap)
              PRINTS THE FOLLOWING 4 LINES:
              fish                 = List(alewife, bass, perch, northern, walleye)
              waterBirds           = List(eagle, duck, goose)
              waterAnimals         = List(List(alewife, bass, perch, northern, walleye), List(eagle, duck, goose))
              flatMap waterAnimals = List(alewife, bass, perch, northern, walleye, eagle, duck, goose)
___ forall
___ foreach
___ indexWhere
___ lastIndexWhere
___ map - EXAMPLE:
          val intList:List[Int] = List[Int](1, 2, 3, 4, 5, 6, 7);
          val result:List[Int] = intList.map(_*2)
          println(result) //  prints: List(2, 4, 6, 8, 10, 12, 14)

___ partition
___ takeWhile
