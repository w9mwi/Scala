In Scala, Lists are SEQUENCES, which means data is stored
in elements that can be accessed via a sequential Integer
index.  The following line of code creates a List of 3
integers that's initialized to the values of 1, 2 and 3.

val myList:List[Int] = List[Int](1, 2, 3)

The square brackets '[]' in the above code indicates that the
List is a paramaterized type.  In the above example, this
paramaterized type is declared to be of type Int.  Like the
above line of code, the following line of code also creates
a List of 3 integers that's initialized to the values of
1, 2 and 3.

var myList = List(1, 2, 3)

Even though the above myList is declared as a var, we can't change the
values contained in each List element.  A List in Scala is IMMUTABLE
by default, which means a List's element values can never be altered,
even if it's a var.  (It is possible to declare a List as mutable
instead of immutable via an import statement.)  The var indicates
that myList can be used to point to a different List.  For example,
you can do the following:

var myList = List(1, 2, 3);
myList = List(9, 8, 7);  // Allowed because myList is a var.

Unlike Arrays, Lists cannot be multi-dimensional.  You can PREPEND
values to an existing var List by using the cons operator (::).
Note that this can be done only with a var List, not a val List.
Prepending a value to a List literally creates a new List as
shown in the example immediately below.

var myList = List(1, 2, 3);
myList = 0::myList
myList.foreach(println)

You can combine two Lists into one List by using the List
append operator, which consists of 3 colon characters (:::),
as shown in the example immediately below.

val list_1:List[Int] = List(1, 22, 333)
val list_2:List[Int] = List(7, 88, 999)
val list_result:List[Int] = list_1 ::: list_2
println(list_result)  // PRINTS: List(1, 22, 333, 7, 88, 999)

Since all Lists (including empty lists) end with a Nil value, you
cannot append values to an existing List, even if it's a var List.
The following example shows us that an empty List contains a single
Nil value.  We can detect that a List is empty by checking to see
if the List == null, or by calling the isEmpty method, which is preferable.

val myList = List()
if (myList == Nil)
{
  println("myList == Nil")
}
if (myList.isEmpty)
{
  println("myList is empty.")
}
========================================================================
When using Scala Lists, you will very frequently call the List head()
and tail() methods, as demonstrated by the following code.  The List.head()
method always returns the data type contained in the List's first element.
The List.tail() method always returns the entire List except for the first
element.  It's possible for a single List to contain different data types
(i.e., Int, Float, String, etc.) in each of its elements by declaring
a List with the "Any" parameter type as shown below.

object Demo
{
  def main(args: Array[String])
  {
    val array:Array[Char] = Array('1', '2', '3', '4')
    val list_1:List[Int] = List(12, 34, 56, 78)
    val list_2:List[Any] = List("one two three four", 12, 12.34F, 12.34D, array)

    val listHead_1:Int       = list_1.head
    val listTail_1:List[Int] = list_1.tail
    println("listHead_1 = " + listHead_1) // PRINTS: listHead_1 = 12
    println("listTail_1 = " + listTail_1) // PRINTS: listTail_1 = listTail_1 = List(34, 56, 78)

    val listHead_2:Any       = list_2.head
    val listTail_2:List[Any] = list_2.tail
    println("listHead_2 = " + listHead_2) // PRINTS: listHead_2 = one two three four
    println("listTail_2 = " + listTail_2) // PRINTS: listTail_2 = List(12, 12.34, 12.34, [C@48140564)
  }
}
========================================================================
Below is Scala code that performs a mathematical operation
on all elements in a List, using a recursive function.

object Demo
{
  def main(args: Array[String])
  {
    val myList:List[Int] = List[Int](1, 2, 3, 4, 5, 6, 7);

    println("operateOnList() result = "  + operateOnList(myList, _+_))
    println("operateOnList2() result = " + operateOnList2(myList, _+_))
  }

  /**
    * This operateOnList() function is identical in behavior to the
    * below operateOnList2() function.
    */
  def operateOnList(list:List[Int], func:(Int, Int) => Int):Int =
  {
    if (list.tail.isEmpty)
    {
      list.head
    }
    else
    {
      func(list.head, operateOnList(list.tail, func))
    }
  }

  /**
    * This operateOnList2() function is identical in behavior to the
    * above operateOnList() function.
    */
  def operateOnList2(list:List[Int], func:(Int, Int) => Int):Int =
  {
    list match
    {
      case a::Nil => a
      case a::t => func(a, operateOnList2(t, func))
      // NOTE: In this code example, the following line never executes
      //       because the first two lines of this match statement
      //       match all possible scenarios.
      case _ => 0
    }
  }
}
===================================================================
===================================================================
import scala.io.Source

object Demo
{
  type NameData = (String, Int, String, Int)

  def main(args: Array[String]) =
  {
    // Each line of the WI.TXT file contains comma-delimted String
    // data in this format:  stateAbbreviation, sex, year, name, numberBorn
    // EXAMPLE:  WI,M,1958,Thomas,1445
    val fileName:String = "/home/tbouril/ScalaData/WI.TXT"

    // Initialize an Array[String], where each element of the Array
    // contains a single line of text obtained from the WI.TXT file.
    val nameArray:Array[String]  = Source.fromFile(fileName).getLines().toArray
    val nameData:Array[NameData] = nameArray.map(parseLine)

    // Print the NameData tuple obtained from every element of the nameData Array.
    // nameData.foreach(println)

    println("nameArray contains " + nameArray.length + " lines of text.")

    val sex:String  = "M"
    val year:Int    = 1958
    val name:String = "Thomas"
    val data:Array[NameData] = nameData.filter(nd => nd._1.equalsIgnoreCase(sex)  &&
                                               nd._2 == year  &&
                                               nd._3.equalsIgnoreCase(name))

    // NOTE: Because of the way the WI.TXT file's data is defined, the data
    //       Array should always contain either zero elements, or one element.
    println("data contains " + data.length + " element(s).")
    if (data.length == 1)
    {
      println("Year = " + year + ", Sex = " + sex + ", Name = " + name + ", Number Born = " + data(0)._4)
    }
    else
    {
      println("No data found for Year = " + year + ", Sex = " + sex + ", Name = " + name)
    }

    val female1959:Array[NameData] = nameData.filter(x => x._1 == "F"  &&  x._2 == 1959)
    var maxNames:Int   = female1959.map(_._4).max

    // Print the NameData for the most common female name(s) born in 1959.
    female1959.filter(_._4 == maxNames).foreach(println)

    // Print the NameData for all female names occurring 100 times and born in 1959.
    val rose:Array[NameData] = nameData.filter(x => x._1 == "F"  &&  x._2 == 1959  &&  x._4 == 100)
    rose.foreach(println)
  }

  /**
    * Pass this function a line of text delimited by commas where the line
    * of text has this format: (String, String, Int, String, Int).  Then,
    * return the final 4 values of that String as the type NameData.
    * @param line
    * @return
    */
  def parseLine(line:String): NameData =
  {
    val parts:Array[String] = line.split(",")
    (parts(1), parts(2).toInt, parts(3), parts(4).toInt)
  }
}
===================================================================
===================================================================
The following is a list of methods that can be called on BOTH
Arrays and Lists.  See pages 143-148 in the Scala book for details.

BASIC METHODS:
=============
___ drop - EXAMPLE:
           val myList:List[String] = List("abc", "def", "ghi", "jkl", "mno", "pqr")
           val newList = myList.drop(1)
           println("newList = " + newList) // Prints:  newList = List(def, ghi, jkl, mno, pqr)
___ init - EXAMPLE:
           val myList:List[String]  = List("abc", "def", "ghi", "jkl", "mno", "pqr")
           val newList:List[String] = myList.init
           println("newList = " + newList) // Prints:  newList = List(abc, def, ghi, jkl, mno)
___ last - EXAMPLE:
           val myList:List[String]  = List("abc", "def", "ghi", "jkl", "mno", "pqr")
           val newList:String = myList.last
           println("newList = " + newList) // Prints:  newList = List(pqr)
___ patch - Calling the patch() method on a List returns a List where 1 or more elements of the List
            is removed from the List, and replaced by a GenSeq.  For example, in the following sample
            code, assume accounts is a List.  1 element beginning at index will be replaced with Nil.
            accounts = accounts.patch(index, Nil, 1)
___ slice - EXAMPLE:
            val myList:List[String]  = List("abc", "def", "ghi", "jkl", "mno", "pqr")
            val newList:List[String] = myList.slice(2,5)
            println("newList = " + newList) // Prints: newList = List(ghi, jkl, mno)
___ splitAt - EXAMPLE:
              val myList:List[String]  = List("abc", "def", "ghi", "jkl", "mno", "pqr")
              val newList:(List[String], List[String]) = myList.splitAt(3) // newList is a tuple type.
              println("newList = " + newList) // Prints: newList = (List(abc, def, ghi),List(jkl, mno, pqr))
___ take - EXAMPLE:
           val myList:List[String]  = List("abc", "def", "ghi", "jkl", "mno", "pqr")
           val newList:List[String] = myList.take(3)
           println("newList = " + newList) // Prints: newList = List(abc, def, ghi)
___ takeRight - EXAMPLE:
                val myList:List[String]  = List("abc", "def", "ghi", "jkl", "mno", "pqr")
                val newList:List[String] = myList.takeRight(2)
                println("newList = " + newList) // Prints: newList = List(mno, pqr)


BOOLEAN TESTS:
==============
___ contains - EXAMPLE:
               val myList:List[String]  = List("abc", "def", "ghi", "jkl", "mno", "pqr")
               val result:Boolean = myList.contains("pqr")
               println("result = " + result) // Prints: result = true
___ endsWith - EXAMPLE:
               val myList:List[String]  = List("abc", "def", "ghi", "jkl", "mno", "pqr")
               val result:Boolean = myList.endsWith(List("pqr"))
               println("result = " + result) // Prints: result = true
___ isEmpty - EXAMPLE:
              val myList1:List[String] = List()
              val myList2:List[String] = List("abc", "def", "ghi", "jkl", "mno", "pqr")
              val result1:Boolean = myList1.isEmpty
              val result2:Boolean = myList2.isEmpty
              println("result1 = " + result1 + ",  result2 = " + result2) // Prints: result1 = true,  result2 = false
___ nonEmpty - The opposite of the isEmpty method.
___ startsWith - EXAMPLE:
                 val myList1:List[String] = List("abc", "def", "ghi", "jkl", "mno", "pqr")
                 val myList2:List[String] = List("abc", "def")
                 val result:Boolean = myList1.startsWith(myList2)
                 println("result = " + result) // Prints: result = true


SEARCHING:
==========
___ find - EXAMPLE:
           Finds the FIRST ELEMENT of the sequence satisfying a predicate, if one exists.
           val intList:List[Int] = List[Int](7, 4, 6, 3, 9, 1)
           var result:Option[Int] = intList.find(_<4)
           println(result) // Prints: Some(3)
           result = intList.find(_>10)
           println(result) // Prints: None
___ indexOf - EXAMPLE:
              val myList:List[String] = List("abc", "def", "ghi", "jkl", "mno", "mno")
              val result:Int = myList.indexOf("mno")
              println("result = " + result) // Prints: result = 4
___ lastIndexOf - EXAMPLE:
                  val myList:List[String] = List("abc", "def", "ghi", "jkl", "mno", "mno")
                  val result:Int = myList.lastIndexOf("mno")
                  println("result = " + result) // Prints: result = 5
___ diff - EXAMPLE:
           val myList1:List[String] = List("abc", "def", "ghi", "jkl", "mno", "pqr")
           val myList2:List[String] = List("pqr", "mno", "jkl", "ghi", "def", "abc")
           val myList3:List[String] = List("mno", "abc")
           val result1:List[String] = myList1.diff(myList2)
           val result2:List[String] = myList1.diff(myList3)
           println("result1 = " + result1 + ", result2 = " + result2) // Prints: result1 = List(), result2 = List(def, ghi, jkl, pqr)
___ mkString EXAMPLE:
             val myList:List[String] = List("abc", "def", "ghi", "jkl", "mno", "pqr")
             println("myList                               = " + myList)
             println("myList.mkString                      = " + myList.mkString)
             println("myList.mkString(\" + \")               = " + myList.mkString(" + "))
             println("myList.mkString(\"BEGIN\", \"_\", \"END\") = " + myList.mkString("BEGIN", "_", "END"))
             // PRINTS THE FOLLOWING 4 LINES:
             myList                               = List(abc, def, ghi, jkl, mno, pqr)
             myList.mkString                      = abcdefghijklmnopqr
             myList.mkString(" + ")               = abc + def + ghi + jkl + mno + pqr
             myList.mkString("BEGIN", "_", "END") = BEGINabc_def_ghi_jkl_mno_pqrEND
___ reverse - EXAMPLE:
              val myList:List[String] = List("abc", "def", "ghi", "jkl", "mno", "pqr")
              println("myList.reverse = " + myList.reverse) // Prints:  myList.reverse = List(pqr, mno, jkl, ghi, def, abc)
___ toList  - EXAMPLE:
              val myArray:Array[String] = Array("abc", "def", "ghi", "jkl", "mno", "pqr")
              val myList:List[String]   = myArray.toList
              println(myList) // Prints: List(abc, def, ghi, jkl, mno, pqr)
___ toArray - EXAMPLE:
              val myList:List[String]   = List("abc", "def", "ghi", "jkl", "mno", "pqr")
              val myArray:Array[String] = myList.toArray
              myArray.foreach(println)
              // PRINTS THE FOLLOWING 6 LINES:
              abc
              def
              ghi
              jkl
              mno
              pqr
___ zip - EXAMPLE:
          val myList1:List[String] = List("abc", "def", "ghi", "jkl", "mno", "pqr")
          val myList2:List[String] = List("stu", "vwx", "yz")
          println(myList1.zip(myList2)) // Prints:  List((abc,stu), (def,vwx), (ghi,yz))
___ zipWithIndex - EXAMPLE:
                   val myList:List[String]                = List("abc", "def", "ghi", "jkl", "mno", "pqr")
                   val myListWithIndex:List[(String,Int)] = myList.zipWithIndex
                   println("myListWithIndex = " + myListWithIndex)
                   println("myListWithIndex(2)._1 = " + myListWithIndex(2)._1 + ",  myListWithIndex(2)._2 = " + myListWithIndex(2)._2)
                   PRINTS THE FOLLOWING 2 LINES:
                   myListWithIndex = List((abc,0), (def,1), (ghi,2), (jkl,3), (mno,4), (pqr,5))
                   myListWithIndex(2)._1 = ghi,  myListWithIndex(2)._2 = 2
___ product - EXAMPLE:
              val myList:List[Float] = List(123.4F, 456.7F, 78.9F)
              println("myList.product = " + myList.product) // Prints: myList.product = 4446550.0
___ sum - EXAMPLE:
          val myList:List[Float] = List(123.4F, 456.7F, 789.1F)
          println("myList.sum = " + myList.sum) // Prints: myList.sum = 1369.2


HIGHER-ORDER METHODS, ETC.
==========================
Among this group of higher-order functions, there are specifically
TWO (2) of these functions that are widely used and very popular.
They are the filter() function and the map() function.  You should
make it a point to understand those two functions very well.

___ count - EXAMPLE:
            val myList:List[Float] = List(123.4F, 456.7F, 78.9F)
            println("myList.count = " + myList.count(_ > 100.0F)) // Prints: myList.count = 2
___ dropWhile - Also see the takeWhile method, which is the inverse of this dropWhile method.
                EXAMPLE:
                val strList:List[String] = List[String]("str1_abc_junk", "str2_abc_stuff", "str3_qrs_things", "str4_xyz_trash")
                val result:List[String] = strList.dropWhile(_.contains("abc"))
                result.foreach(println) // prints: str3_qrs_things  str4_xyz_trash
___ combinations - Also see the permutations function.
                   EXAMPLE:
                   val intList:List[Int] = List[Int](7, 4, 6, 3, 9, 1)
                   intList.combinations(3).foreach(println)
                   var count = 0
                   for (x <- intList.combinations(3))
                   {
                     count += 1
                     // Print the same intList.combinations(3) as the above call to foreach.
                     println("count = " + count + ", " + x)
                   }
___ exists - The exists method returns true if at least one element in the collection meets the condition.
             The forall method returns true if ALL elements in the collection meet the condition.
             EXAMPLE 1:
             val strList:List[String] = List[String]("str1_abc_junk", "str2_jkl_stuff", "str3_qrs_things", "str4_xyz_trash");
             val result:Boolean = strList.exists(_.compareTo("str3_qrs_things") == 0)
             println(result) // result = true
             EXAMPLE 2:
             val intList:List[Int] = List[Int](1, 2, 3, 4, 5, 6, 7);
             val result:Boolean = intList.exists(x => x==7)
             println(result) // result = true
___ filter - EXAMPLE:
             val intList:List[Int] = List[Int](1, 2, 3, 4, 5, 6, 7)
             val result:List[Int] = intList.filter(_ > 6)
             println(result) // result = List(7)
___ filterNot - The opposite of the filter method.
___ flatMap - EXAMPLE:
              The flatMap() method called below is essentially a combination of the
              map() method run first, followed by the flatten() method run second.

              val fish:List[String]               = List[String]("alewife", "bass", "perch", "northern", "walleye")
              val waterBirds:List[String]         = List[String]("eagle", "duck", "goose")
              val waterAnimals:List[List[String]] = List[List[String]](fish, waterBirds)
              println("A) fish                             = " + fish)
              println("B) waterBirds                       = " + waterBirds)
              println("C) waterAnimals                     = " + waterAnimals)
              println("D) waterAnimals.map(x => x)         = " + waterAnimals.map(x => x)) // NOTE: map(x => x) changes nothing.
              println("E) waterAnimals.flatten             = " + waterAnimals.flatten)
              println("F) waterAnimals.map(x => x).flatten = " + waterAnimals.map(x => x).flatten)
              println("G) waterAnimals.flatMap(x => x)     = " + waterAnimals.flatMap(x => x))
          //  PRINTS THE FOLLOWING 7 LINES...
          //  A) fish                             = List(alewife, bass, perch, northern, walleye)
          //  B) waterBirds                       = List(eagle, duck, goose)
          //  C) waterAnimals                     = List(List(alewife, bass, perch, northern, walleye), List(eagle, duck, goose))
          //  D) waterAnimals.map(x => x)         = List(List(alewife, bass, perch, northern, walleye), List(eagle, duck, goose))
          //  E) waterAnimals.flatten             = List(alewife, bass, perch, northern, walleye, eagle, duck, goose)
          //  F) waterAnimals.map(x => x).flatten = List(alewife, bass, perch, northern, walleye, eagle, duck, goose)
          //  G) waterAnimals.flatMap(x => x)     = List(alewife, bass, perch, northern, walleye, eagle, duck, goose)

___ flatten - Read the following web page for explanations and examples of how to use the flatten method:
              https://alvinalexander.com/scala/how-to-flatten-list-lists-in-scala-with-flatten-method
___ foldLeft - See the foldRight example below.
___ foldRight - For more info. regarding foldLeft and foldRight, see "CURRYING EXAMPLE 3" and "CURRYING EXAMPLE 4"
                at the bottom of this URL:  https://github.com/w9mwi/Scala/blob/master/Currying
                EXAMPLE:
                val intList:List[Int] = List[Int](7, 4, 6, 3, 9, 1)

                // NOTE: foldLeft and foldRight are both CURRIED FUNCTIONS,
                //       as they get passed a value, and they return a function
                //       that gets passed a value and returns a value.  When
                //       foldLeft and foldRight are called below, they get
                //       called with TWO PARAMETER LISTS.

                // The following foldLeft function works on intList as follows:
                // The first argument list (0) takes the base value that's used
                // as the first operand.  The second argument list (_ - _) is the
                // function to apply.
                // 0−7−4−6−3−9−1 = ((((((0−7)−4)−6)−3)−9)−1) = -30
                println("intList.foldLeft(0)(_ - _) = " + intList.foldLeft(0)(_ - _))

                // The following foldRight function works on intList as follows:
                // The first argument list (0) takes the base value that's used
                // as the first operand.  The second argument list (_ - _) is the
                // function to apply.
                // 0−(1−(9−(3−(6−(4−7))))) = 14
                println("intList.foldRight(0)(_ - _) = " + intList.foldRight(0)(_ - _))
                // ********************************************************************
                val wordList:List[String] = List[String]("How", "many", "characters", "do", "we", "have?")

                // NOTE: The second parameter list for foldRight has its tuple order as (word, count),
                //       which is the reverse order used by the foldLeft function below.
                var wordCount:Int = wordList.foldRight(0)((word:String, count:Int) => count + word.length)
                println("wordCount.foldRight = " + wordCount)

                // NOTE: The second parameter list for foldLeft has its tuple order as (count, word),
                //       which is the reverse order used by the foldRight function above.
                wordCount = wordList.foldLeft(0)((count:Int, word:String) => count + word.length)
                println("wordCount.foldLeft = " + wordCount)

                // The following calls to foldRight and foldLeft perform identically
                // to the foldRight and foldLeft calls immediately above.
                println("wordList.foldRight(0)(_.length + _) = " + wordList.foldRight(0)(_.length + _))
                println("wordList.foldLeft(0)(_+_.length)    = " + wordList.foldLeft(0)(_+_.length))
___ forall - The forall method returns true if ALL elements in the collection meet the condition.
             The exists method returns true if at least one element in the collection meets the condition.
             EXAMPLE:
             val myList:List[Float] = List(123.4F, 456.7F, 78.9F)
             println("myList.forall = " + myList.forall(_ > 100.0F)) // Prints: myList.forall = false
             println("myList.forall = " + myList.forall(_ > 50.0F))  // Prints: myList.forall = true
___ foreach - This method gets passed a function that operates on all elements in the collection,
              and returns nothing.  This method is called only for its side effects.
              EXAMPLE:
              val myList:List[Float] = List(12.1F, 34.2F, 56.3F, 78.4F)
              myList.foreach(x => println(2.0F * x)) // Param passed to foreach is a literal function.
              PRINTS THE FOLLOWING 4 LINES:
              24.2
              68.4
              112.6
              156.8
___ grouped - Runs through the sequence, grouping items into groups of the specified size.
              EXAMPLE:
              val intList:List[Int] = List[Int](7, 4, 6, 3, 9, 1)
              intList.grouped(2).foreach(println)

              var count = 0
              for (x <- intList.grouped(2))
              {
                count += 1
                // Print the same intList.grouped(2) as the above call to foreach.
                println("count = " + count + ", " + x)
              }
___ indexWhere - Pass this method a function that operates on a single element of the collection.
                 Returns the index of the FIRST element for which the function is true.  Returns
                 -1 if the function is NOT true for any of the elements.
                 EXAMPLE:
                 val myList:List[Float] = List(12.1F, 34.2F, 56.3F, 78.4F)
                 val result:Int = myList.indexWhere(_ > 50.0F)
                 println(result) // Prints: 2
___ inits - Provides an iterator going from the full sequence to an empty one, removing elements from the end.
                                                                 // The below println statement PRINTS:
            val intList:List[Int] = List[Int](7, 4, 6, 3, 9, 1)  // count = 1, List(7, 4, 6, 3, 9, 1)
            var count = 0                                        // count = 2, List(7, 4, 6, 3, 9)
            for (x <- intList.inits)                             // count = 3, List(7, 4, 6, 3)
            {                                                    // count = 4, List(7, 4, 6)
              count += 1                                         // count = 5, List(7, 4)
              println("count = " + count + ", " + x)             // count = 6, List(7)
            }                                                    // count = 7, List()
___ lastIndexWhere - Pass this method a function that operates on a single element of the collection
                     and returns a Boolean.  This method returns the index of the LAST element for
                     which the function is true.  Returns -1 if the function is NOT true for any
                     of the elements.
                     EXAMPLE:
                     val myList:List[Float] = List(12.1F, 34.2F, 56.3F, 78.4F)
                     val result:Int = myList.lastIndexWhere(_ > 50.0F)
                     println(result) // Prints: 3
___ map - Pass this method a function that operates on a single element of the collection and returns something.
          The map method then returns a new collection that contains the results of applying that function
          to the contents of each element in the original collection.
          EXAMPLE:
          val intList:List[Int] = List[Int](1, 2, 3, 4, 5, 6, 7);
          val result:List[Int] = intList.map(_*2)
          println(result) //  prints: List(2, 4, 6, 8, 10, 12, 14)
___ partition - Pass this method a function that operates on a single element of the collection
                and returns a Boolean.  This method returns a tuple with TWO new collections.
                The first collection in the tuple contains only the elements for which the
                function is true.  The second collection in the tuple contains only the elements
                for which the function is false.
                EXAMPLE:
                val myList:List[Float] = List(43.7F, 567.89F, 144.8F, 77.7F, 17.7F)
                val result:(List[Float], List[Float]) = myList.partition(_ > 77.0F)
                println(result) // Prints: (List(567.89, 144.8, 77.7),List(43.7, 17.7))
___ permutations - Also see the combinations function.
                   EXAMPLE:
                   val intList:List[Int] = List[Int](7, 4, 6, 3, 9, 1)
                   intList.permutations.foreach(println)
                   var count = 0
                   for (x <- intList.permutations)
                   {
                     count += 1
                     // Print the same intList.permutations as the above call to foreach.
                     println("count = " + count + ", " + x)
                   }
___ reduceLeft - See reduceRight.
___ reduceRight - EXAMPLE of reduceLeft and reduceRight:
    val myList:List[Int] = List(1, 2, 3, 4)
    var result:Int = myList.reduceLeft(_ + _) // result = ((1 + 2) + 3) + 4 = 10
    println("result = " + result) // Prints: 10

    result = myList.reduceRight(_ + _) // result = 1 + (2 + (3 + 4)) = 10
    println("result = " + result) // Prints: 10

    result = myList.reduceLeft(_ - _) // result = ((1 - 2) - 3) - 4 = -8
    println("result = " + result) // Prints: -8

    result = myList.reduceRight(_ - _) // result = 1 - (2 - (3 - 4)) = -2
    println("result = " + result) // Prints: -2

    result = myList.reduceLeft(_ * _) // result = ((1 * 2) * 3) * 4 = 24
    println("result = " + result) // Prints: 24

    result = myList.reduceRight(_ * _) // result = 1 * (2 * (3 * 4)) = 24
    println("result = " + result) // Prints: 24
___ sliding - Provides an iterator that gives the effect of sliding a window of a specified size across the sequence.
              EXAMPLE:
              val intList:List[Int] = List[Int](7, 4, 6, 3, 9, 1)
              intList.sliding(3).foreach(println)
              var count = 0
              for (x <- intList.sliding(3))
              {
                count += 1
                // Print the same intList.sliding(3) as the above call to foreach.
                println("count = " + count + ", " + x)
              }
___ tails - Gives an iterator that runs through sublists, starting with the full list, and ending
            with an empty list--removing one element from the left (removing the head) for each step,
            thus returning the tail.
            EXAMPLE:
            val intList:List[Int] = List[Int](7, 4, 6, 3, 9, 1)
            intList.tails.foreach(println)
            var count = 0
            for (x <- intList.tails)
            {
              count += 1
              // Print the same intList.tails as the above call to foreach.
              println("count = " + count + ", " + x)
            }
___ takeWhile - Also see the dropWhile method, which is the inverse of this takeWhile method.
                Pass this method a function that operates on a single element of the collection
                and returns a Boolean.  This method returns a new collection of all elements
                for which that function is true beginning with the first element.  As soon
                as an element is found for where the function returns false, nothing more
                is returned.  That's why the fourth println below prints the empty List (List()),
                because the function returns false for the first element in myList.

                val myList:List[Float] = List(43.7F, 17.7F, 77.7F, 567.89F, 144.8F)
                println("myList                       = " + myList)
                println("myList.takeWhile(_ == 43.7F) = " + myList.takeWhile(_ == 43.7F))
                println("myList.takeWhile(_ > 43.6F)  = " + myList.takeWhile(_ > 43.6F))
                println("myList.takeWhile(_ > 43.7F)  = " + myList.takeWhile(_ > 43.7F))
                println("myList.takeWhile(_ > 17.6F)  = " + myList.takeWhile(_ > 17.6F))
              // PRINTS THE FOLLOWING:
              // myList                       = List(43.7, 17.7, 77.7, 567.89, 144.8)
              // myList.takeWhile(_ == 43.7F) = List(43.7)
              // myList.takeWhile(_ > 43.6F)  = List(43.7)
              // myList.takeWhile(_ > 43.7F)  = List()
              // myList.takeWhile(_ > 17.6F)  = List(43.7, 17.7, 77.7, 567.89, 144.8)
