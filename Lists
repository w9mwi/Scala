In Scala, Lists are SEQUENCES, which means data is stored
in elements that can be accessed via a sequential Integer
index.  The following line of code creates a List of 3
integers that's initialized to the values of 1, 2 and 3.

val myList:List[Int] = List[Int](1, 2, 3)

The square brackets '[]' in the above code indicates that the
List is a paramaterized type.  In the above example, this
paramaterized type is declared to be of type Int.  Like the
above line of code, the following line of code also creates
a List of 3 integers that's initialized to the values of
1, 2 and 3.

var myList = List(1, 2, 3)

Even though the above myList is declared as a var, we can't change the
values contained in each List element.  A List in Scala is IMMUTABLE,
which means a List's element values can never be altered, even if
its a var.  The var indicates that myList can be used to point
to a different List.  For example, you can do the following:

var myList = List(1, 2, 3);
myList = List(9, 8, 7);  // Allowed because myArray is a var.

Unlike Arrays, Lists cannot be multi-dimensional.  You can PREPEND
values to an existing var List by using the cons operator (::).
Note that this can be done only with a var List, not a val List.
Here's an example.

var myList = List(1, 2, 3);
myList = 0::myList
myList.foreach(println)

Prepending a value to a List, as shown above, literally creates a new List.

Since all Lists (including empty lists) end with a Nil value, you
cannot append values to an existing List, even if it's a var List.
The following example shows us that an empty List contains a single
Nil value.  We can detect that a List is empty by checking to see
if the List == null, or by calling the isEmpty method, which is preferable.

val myList = List()
if (myList == Nil)
{
  println("myList == Nil")
}
if (myList.isEmpty)
{
  println("myList is empty.")
}

Below is Scala code that performs a mathematical operation
on all elements in a List, using a recursive function.
========================================================================
========================================================================
object Demo
{
  def main(args: Array[String])
  {
    val myList:List[Int] = List[Int](1, 2, 3, 4, 5, 6, 7);

    println("operateOnList() result = "  + operateOnList(myList, _+_))
    println("operateOnList2() result = " + operateOnList2(myList, _+_))
  }

  /**
    * This operateOnList() function is identical in behavior to the
    * below operateOnList2() function.
    */
  def operateOnList(list:List[Int], func:(Int, Int) => Int):Int =
  {
    if (list.tail.isEmpty)
    {
      list.head
    }
    else
    {
      func(list.head, operateOnList(list.tail, func))
    }
  }

  /**
    * This operateOnList2() function is identical in behavior to the
    * above operateOnList() function.
    */
  def operateOnList2(list:List[Int], func:(Int, Int) => Int):Int =
  {
    list match
    {
      case a::Nil => a
      case a::t => func(a, operateOnList2(t, func))
      case _ => 0
    }
  }
}
===================================================================
The following is a list of methods that can be called on BOTH
Arrays and Lists.  See pages 143-148 in the Scala book for details.

BASIC METHODS:
=============
___ drop - EXAMPLE:
           val myList:List[String] = List("abc", "def", "ghi", "jkl", "mno", "pqr")
           val newList = myList.drop(1)
           println("newList = " + newList) // Prints:  newList = List(def, ghi, jkl, mno, pqr)
___ init - EXAMPLE:
           val myList:List[String]  = List("abc", "def", "ghi", "jkl", "mno", "pqr")
           val newList:List[String] = myList.init
           println("newList = " + newList) // Prints:  newList = List(abc, def, ghi, jkl, mno)
___ last - EXAMPLE:
           val myList:List[String]  = List("abc", "def", "ghi", "jkl", "mno", "pqr")
           val newList:String = myList.last
           println("newList = " + newList) // Prints:  newList = List(pqr)
___ slice - EXAMPLE:
            val myList:List[String]  = List("abc", "def", "ghi", "jkl", "mno", "pqr")
            val newList:List[String] = myList.slice(2,5)
            println("newList = " + newList) // Prints: newList = List(ghi, jkl, mno)
___ splitAt - EXAMPLE:
              val myList:List[String]  = List("abc", "def", "ghi", "jkl", "mno", "pqr")
              val newList:(List[String], List[String]) = myList.splitAt(3) // newList is a tuple type.
              println("newList = " + newList) // Prints: newList = (List(abc, def, ghi),List(jkl, mno, pqr))
___ take - EXAMPLE:
           val myList:List[String]  = List("abc", "def", "ghi", "jkl", "mno", "pqr")
           val newList:List[String] = myList.take(3)
           println("newList = " + newList) // Prints: newList = List(abc, def, ghi)
___ takeRight - EXAMPLE:
                val myList:List[String]  = List("abc", "def", "ghi", "jkl", "mno", "pqr")
                val newList:List[String] = myList.takeRight(2)
                println("newList = " + newList) // Prints: newList = List(mno, pqr)


BOOLEAN TESTS:
==============
___ contains - EXAMPLE:
               val myList:List[String]  = List("abc", "def", "ghi", "jkl", "mno", "pqr")
               val result:Boolean = myList.contains("pqr")
               println("result = " + result) // Prints: result = true
___ endsWith - EXAMPLE:
               val myList:List[String]  = List("abc", "def", "ghi", "jkl", "mno", "pqr")
               val result:Boolean = myList.endsWith(List("pqr"))
               println("result = " + result) // Prints: result = true
___ isEmpty - EXAMPLE:
              val myList1:List[String] = List()
              val myList2:List[String] = List("abc", "def", "ghi", "jkl", "mno", "pqr")
              val result1:Boolean = myList1.isEmpty
              val result2:Boolean = myList2.isEmpty
              println("result1 = " + result1 + ",  result2 = " + result2) // Prints: result1 = true,  result2 = false
___ nonEmpty - The opposite of the isEmpty method.
___ startsWith - EXAMPLE:
                 val myList1:List[String] = List("abc", "def", "ghi", "jkl", "mno", "pqr")
                 val myList2:List[String] = List("abc", "def")
                 val result:Boolean = myList1.startsWith(myList2)
                 println("result = " + result) // Prints: result = true


SEARCHING:
==========
___ indexOf - EXAMPLE:
              val myList:List[String] = List("abc", "def", "ghi", "jkl", "mno", "mno")
              val result:Int = myList.indexOf("mno")
              println("result = " + result) // Prints: result = 4
___ lastIndexOf - EXAMPLE:
                  val myList:List[String] = List("abc", "def", "ghi", "jkl", "mno", "mno")
                  val result:Int = myList.lastIndexOf("mno")
                  println("result = " + result) // Prints: result = 5
___ diff - EXAMPLE:
           val myList1:List[String] = List("abc", "def", "ghi", "jkl", "mno", "pqr")
           val myList2:List[String] = List("pqr", "mno", "jkl", "ghi", "def", "abc")
           val myList3:List[String] = List("mno", "abc")
           val result1:List[String] = myList1.diff(myList2)
           val result2:List[String] = myList1.diff(myList3)
           println("result1 = " + result1 + ", result2 = " + result2) // Prints: result1 = List(), result2 = List(def, ghi, jkl, pqr)
___ mkString EXAMPLE:
             val myList:List[String] = List("abc", "def", "ghi", "jkl", "mno", "pqr")
             println("myList                               = " + myList)
             println("myList.mkString                      = " + myList.mkString)
             println("myList.mkString(\" + \")               = " + myList.mkString(" + "))
             println("myList.mkString(\"BEGIN\", \"_\", \"END\") = " + myList.mkString("BEGIN", "_", "END"))
             // PRINTS THE FOLLOWING 4 LINES:
             myList                               = List(abc, def, ghi, jkl, mno, pqr)
             myList.mkString                      = abcdefghijklmnopqr
             myList.mkString(" + ")               = abc + def + ghi + jkl + mno + pqr
             myList.mkString("BEGIN", "_", "END") = BEGINabc_def_ghi_jkl_mno_pqrEND
___ reverse - EXAMPLE:
              val myList:List[String] = List("abc", "def", "ghi", "jkl", "mno", "pqr")
              println("myList.reverse = " + myList.reverse) // Prints:  myList.reverse = List(pqr, mno, jkl, ghi, def, abc)
___ toList  - EXAMPLE:
              val myArray:Array[String] = Array("abc", "def", "ghi", "jkl", "mno", "pqr")
              val myList:List[String]   = myArray.toList
              println(myList) // Prints: List(abc, def, ghi, jkl, mno, pqr)
___ toArray - EXAMPLE:
              val myList:List[String]   = List("abc", "def", "ghi", "jkl", "mno", "pqr")
              val myArray:Array[String] = myList.toArray
              myArray.foreach(println)
              // PRINTS THE FOLLOWING 6 LINES:
              abc
              def
              ghi
              jkl
              mno
              pqr
___ zip - EXAMPLE:
          val myList1:List[String] = List("abc", "def", "ghi", "jkl", "mno", "pqr")
          val myList2:List[String] = List("stu", "vwx", "yz")
          println(myList1.zip(myList2)) // Prints:  List((abc,stu), (def,vwx), (ghi,yz))
___ zipWithIndex - EXAMPLE:
                   val myList:List[String]                = List("abc", "def", "ghi", "jkl", "mno", "pqr")
                   val myListWithIndex:List[(String,Int)] = myList.zipWithIndex
                   println("myListWithIndex = " + myListWithIndex)
                   println("myListWithIndex(2)._1 = " + myListWithIndex(2)._1 + ",  myListWithIndex(2)._2 = " + myListWithIndex(2)._2)
                   PRINTS THE FOLLOWING 2 LINES:
                   myListWithIndex = List((abc,0), (def,1), (ghi,2), (jkl,3), (mno,4), (pqr,5))
                   myListWithIndex(2)._1 = ghi,  myListWithIndex(2)._2 = 2
___ product - EXAMPLE:
              val myList:List[Float] = List(123.4F, 456.7F, 78.9F)
              println("myList.product = " + myList.product) // Prints: myList.product = 4446550.0
___ sum - EXAMPLE:
          val myList:List[Float] = List(123.4F, 456.7F, 789.1F)
          println("myList.sum = " + myList.sum) // Prints: myList.sum = 1369.2


HIGHER-ORDER METHODS, ETC.
==========================
___ count - EXAMPLE:
            val myList:List[Float] = List(123.4F, 456.7F, 78.9F)
            println("myList.count = " + myList.count(_ > 100.0F)) // Prints: myList.count = 2
___ dropWhile - EXAMPLE:
                val strList:List[String] = List[String]("str1_abc_junk", "str2_abc_stuff", "str3_qrs_things", "str4_xyz_trash")
                val result:List[String] = strList.dropWhile(_.contains("abc"))
                result.foreach(println) // prints: str3_qrs_things  str4_xyz_trash
___ combinations - Also see the permutations function.
                   EXAMPLE:
                   val intList:List[Int] = List[Int](7, 4, 6, 3, 9, 1)
                   intList.combinations(3).foreach(println)
                   var count = 0
                   for (x <- intList.combinations(3))
                   {
                     count += 1
                     // Print the same intList.combinations(3) as the above call to foreach.
                     println("count = " + count + ", " + x)
                   }
___ exists - EXAMPLE 1:
             val strList:List[String] = List[String]("str1_abc_junk", "str2_jkl_stuff", "str3_qrs_things", "str4_xyz_trash");
             val result:Boolean = strList.exists(_.compareTo("str3_qrs_things") == 0)
             println(result) // result = true
             EXAMPLE 2:
             val intList:List[Int] = List[Int](1, 2, 3, 4, 5, 6, 7);
             val result:Boolean = intList.exists(x => x==7)
             println(result) // result = true
___ filter - EXAMPLE:
             val intList:List[Int] = List[Int](1, 2, 3, 4, 5, 6, 7)
             val result:List[Int] = intList.filter(_ > 6)
             println(result) // result = List(7)
___ filterNot - The opposite of the filter method.
___ flatMap - EXAMPLE:
              The flatMap method is essentially a combination of the map
              method being run first, followed by the flatten method.
              val fish:List[String]               = List[String]("alewife", "bass", "perch", "northern", "walleye")
              val waterBirds:List[String]         = List[String]("eagle", "duck", "goose")
              val waterAnimals:List[List[String]] = List[List[String]](fish, waterBirds)
              val flatMap:List[String]            = waterAnimals.flatMap(x => x)
              println("fish                 = " + fish)
              println("waterBirds           = " + waterBirds)
              println("waterAnimals         = " + waterAnimals)
              println("flatMap waterAnimals = " + flatMap)
              PRINTS THE FOLLOWING 4 LINES:
              fish                 = List(alewife, bass, perch, northern, walleye)
              waterBirds           = List(eagle, duck, goose)
              waterAnimals         = List(List(alewife, bass, perch, northern, walleye), List(eagle, duck, goose))
              flatMap waterAnimals = List(alewife, bass, perch, northern, walleye, eagle, duck, goose)
___ flatten - Read the following web page for explanations and examples of how to use the flatten method:
              https://alvinalexander.com/scala/how-to-flatten-list-lists-in-scala-with-flatten-method
___ foldLeft - See the foldRight example below.
___ foldRight - For more info. regarding foldLeft and foldRight, see "CURRYING EXAMPLE 3" and "CURRYING EXAMPLE 4"
                at the botom of this page:  https://github.com/w9mwi/Scala/blob/master/Currying
                EXAMPLE:
                val intList:List[Int] = List[Int](7, 4, 6, 3, 9, 1)

                // NOTE: foldLeft and foldRight are both CURRIED FUNCTIONS,
                //       as they get passed a value, and return a function
                //       that gets passed a value and returns a value.
                //       When foldLeft and foldRight are called below, they
                //       get called with TWO PARAMETER LISTS.

                // The following foldLeft function works on intList as follows:
                // The first argument list (0) takes the base value that's used
                // as the first operand.  The second argument list (_ - _) is the
                // function to apply.
                // 0−7−4−6−3−9−1 = ((((((0−7)−4)−6)−3)−9)−1) = -30
                println("intList.foldLeft(0)(_ - _) = " + intList.foldLeft(0)(_ - _))

                // The following foldRight function works on intList as follows:
                // The first argument list (0) takes the base value that's used
                // as the first operand.  The second argument list (_ - _) is the
                // function to apply.
                // 0−(1−(9−(3−(6−(4−7))))) = 14
                println("intList.foldRight(0)(_ - _) = " + intList.foldRight(0)(_ - _))
                // ********************************************************************
                val wordList:List[String] = List[String]("How", "many", "characters", "do", "we", "have?")

                // NOTE: The second parameter list for foldRight has its tuple order as (word, count),
                //       which is the reverse order used by the foldLeft function below.
                var wordCount:Int = wordList.foldRight(0)((word:String, count:Int) => count + word.length)
                println("wordCount.foldRight = " + wordCount)

                // NOTE: The second parameter list for foldLeft has its tuple order as (count, word),
                //       which is the reverse order used by the foldRight function above.
                wordCount = wordList.foldLeft(0)((count:Int, word:String) => count + word.length)
                println("wordCount.foldLeft = " + wordCount)

                // The following calls to foldRight and foldLeft perform identically
                // to the foldRight and foldLeft calls immediately above.
                println("wordList.foldRight(0)(_.length + _) = " + wordList.foldRight(0)(_.length + _))
                println("wordList.foldLeft(0)(_+_.length)    = " + wordList.foldLeft(0)(_+_.length))
___ forall - EXAMPLE:
             val myList:List[Float] = List(123.4F, 456.7F, 78.9F)
             println("myList.forall = " + myList.forall(_ > 100.0F)) // Prints: myList.forall = false
             println("myList.forall = " + myList.forall(_ > 50.0F))  // Prints: myList.forall = true
___ foreach - This method gets passed a function that operates on all elements in the collection,
              and returns nothing.  This method is called only for its side effects.
              EXAMPLE:
              val myList:List[Float] = List(12.1F, 34.2F, 56.3F, 78.4F)
              myList.foreach(x => println(2.0F * x)) // Param passed to foreach is a literal function.
              PRINTS THE FOLLOWING 4 LINES:
              24.2
              68.4
              112.6
              156.8
___ grouped - Runs through the sequence, grouping items into groups of the specified size.
              EXAMPLE:
              val intList:List[Int] = List[Int](7, 4, 6, 3, 9, 1)
              intList.grouped(2).foreach(println)

              var count = 0
              for (x <- intList.grouped(2))
              {
                count += 1
                // Print the same intList.grouped(2) as the above call to foreach.
                println("count = " + count + ", " + x)
              }
___ indexWhere - Pass this method a function that operates on a single element of the collection.
                 Returns the index of the FIRST element for which the function is true.  Returns
                 -1 if the function is NOT true for any of the elements.
                 EXAMPLE:
                 val myList:List[Float] = List(12.1F, 34.2F, 56.3F, 78.4F)
                 val result:Int = myList.indexWhere(_ > 50.0F)
                 println(result) // Prints: 2
___ inits - Provides an iterator going from the full sequence to an empty one, removing elements from the end.
            EXAMPLE:
            val intList:List[Int] = List[Int](7, 4, 6, 3, 9, 1)
            var count = 0
            for (x <- intList.inits)
            {
              count += 1
              println("count = " + count + ", " + x)
            }
___ lastIndexWhere - Pass this method a function that operates on a single element of the collection
                     and returns a Boolean.  This method returns the index of the LAST element for
                     which the function is true.  Returns -1 if the function is NOT true for any
                     of the elements.
                     EXAMPLE:
                     val myList:List[Float] = List(12.1F, 34.2F, 56.3F, 78.4F)
                     val result:Int = myList.lastIndexWhere(_ > 50.0F)
                     println(result) // Prints: 3
___ map - Pass this method a function that operates on a single element of the collection and returns something.
          The map method then returns a new collection that contains the results of applying that function
          to the contents of each element in the original collection.
          EXAMPLE:
          val intList:List[Int] = List[Int](1, 2, 3, 4, 5, 6, 7);
          val result:List[Int] = intList.map(_*2)
          println(result) //  prints: List(2, 4, 6, 8, 10, 12, 14)
___ partition - Pass this method a function that operates on a single element of the collection
                and returns a Boolean.  This method returns a tuple with TWO new collections.
                The first collection in the tuple contains only the elements for which the
                function is true.  The second collection in the tuple contains only the elements
                for which the function is false.
                EXAMPLE:
                val myList:List[Float] = List(43.7F, 567.89F, 144.8F, 77.7F, 17.7F)
                val result:(List[Float], List[Float]) = myList.partition(_ > 77.0F)
                println(result) // Prints: (List(567.89, 144.8, 77.7),List(43.7, 17.7))
___ permutations - Also see the combinations function.
                   EXAMPLE:
                   val intList:List[Int] = List[Int](7, 4, 6, 3, 9, 1)
                   intList.permutations.foreach(println)
                   var count = 0
                   for (x <- intList.permutations)
                   {
                     count += 1
                     // Print the same intList.permutations as the above call to foreach.
                     println("count = " + count + ", " + x)
                   }
___ reduceLeft - See reduceRight.
___ reduceRight - EXAMPLE of reduceLeft and reduceRight:
    val myList:List[Int] = List(1, 2, 3, 4)
    var result:Int = myList.reduceLeft(_ + _) // result = ((1 + 2) + 3) + 4 = 10
    println("result = " + result) // Prints: 10

    result = myList.reduceRight(_ + _) // result = 1 + (2 + (3 + 4)) = 10
    println("result = " + result) // Prints: 10

    result = myList.reduceLeft(_ - _) // result = ((1 - 2) - 3) - 4 = -8
    println("result = " + result) // Prints: -8

    result = myList.reduceRight(_ - _) // result = 1 - (2 - (3 - 4)) = -2
    println("result = " + result) // Prints: -2

    result = myList.reduceLeft(_ * _) // result = ((1 * 2) * 3) * 4 = 24
    println("result = " + result) // Prints: 24

    result = myList.reduceRight(_ * _) // result = 1 * (2 * (3 * 4)) = 24
    println("result = " + result) // Prints: 24
___ sliding - Provides an iterator that gives the efect of sliding a window of a specified size across the sequence.
              EXAMPLE:
              val intList:List[Int] = List[Int](7, 4, 6, 3, 9, 1)
              intList.sliding(3).foreach(println)
              var count = 0
              for (x <- intList.sliding(3))
              {
                count += 1
                // Print the same intList.sliding(3) as the above call to foreach.
                println("count = " + count + ", " + x)
              }
___ tails - Gives an iterator that runs through sublists, starting with the full list, and ending
            with an empty list--removing one element from the left (removing the head) for each step,
            thus returning the tail.
            EXAMPLE:
            val intList:List[Int] = List[Int](7, 4, 6, 3, 9, 1)
            intList.tails.foreach(println)
            var count = 0
            for (x <- intList.tails)
            {
              count += 1
              // Print the same intList.tails as the above call to foreach.
              println("count = " + count + ", " + x)
            }
___ takeWhile - Pass this method a function that operates on a single element of the collection
                and returns a Boolean.  This method returns a new collection all elements
                at the beginning for which that function is true.
                val myList:List[Float] = List(43.7F, 17.7F, 77.7F, 567.89F, 144.8F)
                val result1:List[Float] = myList.takeWhile(_ > 43.7F)
                val result2:List[Float] = myList.takeWhile(_ > 43.6F)
                val result3:List[Float] = myList.takeWhile(_ > 17.6F)
                println("result1 = " + result1 + ",  result2 = " + result2 + ",  result3 = " + result3)
                // Prints:  result1 = List(),  result2 = List(43.7),  result3 = List(43.7, 17.7, 77.7, 567.89, 144.8)

