In Scala you can define a function in 2 different ways:

1) A function can be defined as a val (or a var), so the val/var
   actually stores a function instead of storing a typical data
   value like an Int, String, List, etc.

2) A function can be defined by using the 'def' keyword,
   which is the most common way functions are defined.

The compiled code of a function defined as a val/var is
different than the compiled code of a function defined
using the 'def' keyword, even when both of those functions
are defined to perform the identical operation, such as
multiplying an Int value by two (2), and returning an
Int result.

The following sample code defines a function using both ways,
where doubleIntFunc() is stored in a val, and tripleIntFunc()c
is defined using the 'def' keyword.

======================================================================

object Demo
{
  def main(args: Array[String]): Unit = {
    val doubleIntFunc:(Int => Int) = (number:Int) => number * 2

    println(doubleIntFunc(222)) // PRINTS: 444
    println(tripleIntFunc(222)) // PRINTS: 666
  }
  def tripleIntFunc(number:Int):Int = number * 3
}

======================================================================
In the above example, if we want to assign the defined tripleIntFunc()
to a val named tripleIntFunc_2, you'd probably try doing this:

val tripleIntFunc_2 = tripleIntFunc  // WON'T compile!

However, that line WON'T COMPILE because a function defined via the
'def' keyword CAN'T be assigned to a val/var in the manner shown
above.  This problem can be fixed by adding an underscore (_) char
AFTER the function name, like this:

val tripleIntFunc_2 = tripleIntFunc _  // WILL compile!

Adding the underscore char like this performs an Eta Expansion
on the tripleIntFunc so it's treated as a partially applied
function and can then be assigned to a val/var.  The code sample
below demonstrates this by implementing this line of code:

val tripleIntFunc_2 = tripleIntFunc _

Using the underscore (_) char eliminates the need to explicitly
declare the data type of tripleIntFunc_2.  If the code explicitly
declares the data type of tripleIntFunc_2 as shown in the following
line, then the underscore (_) char is NOT required, it's optional.

val tripleIntFunc_2:(Int => Int) = tripleIntFunc    // WILL compile!
val tripleIntFunc_2:(Int => Int) = tripleIntFunc _  // WILL compile!

======================================================================
In the below sample code we perform an Eta expansion on the defined
add() function like this:

val addFunc = add _

Then we show how addFunc can be used to obtain a curried version
of the defined add() function, like this:

val curriedAddFunc = addFunc.curried

Read in-line comments in the below code for details.
======================================================================

object Demo
{
  def main(args: Array[String]): Unit =
  {
    val addFunc = add _  // Perform an Eta expansion so addFunc contains the add() function defined below.
    var result:Int = addFunc(1, 2, 3)
    println("result = " + result) // PRINTS: result = 6

    // Calling addFunc.curried returns a curried version of the add function defined below.
    val curriedAddFunc = addFunc.curried
    result = curriedAddFunc(1)(2)(3)
    println("result = " + result) // PRINTS: result = 6

    // Now call curriedAddFunc() as PARTIALLY APPLIED.
    val func1:(Int => (Int => Int)) = curriedAddFunc(1) // func1  = curriedAddFunc PARTIALLY APPLIED.
    val func2:(Int => Int)          = func1(2)          // func2  = func1 PARTIALLY APPLIED.
    result                          = func2(3)          // result = func2 FULLY APPLIED.
    println("result = " + result) // PRINTS: result = 6

    // func1 and func2 are currently partially applied.
    // Below, func1 and func2 get called so they become FULLY APPLIED.
    result = func1.apply(2).apply(3)
    println("result = " + result) // PRINTS: result = 6
    result = func2.apply(3)
    println("result = " + result) // PRINTS: result = 6

    // The following line shows that the addFunc.isInstanceOf call returns true.
    val tom = addFunc.isInstanceOf[Function3[_, _, _, _]]
    println("tom = " + tom) // PRINTS: tom = true
  }

  def add(x:Int, y:Int, z:Int):Int = x + y + z
}

======================================================================

object Demo
{
  def main(args: Array[String]): Unit = {
    val numbers:List[Int] = List(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
    println(numbers) // PRINTS: List(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10)

    // Define a val to store a function...
    val doubleIntFunc:(Int => Int) = (number:Int) => number * 2

    // Pass the function stored in the doubleIntFunc val to the List.map() function...
    var result:List[Int] = numbers.map(doubleIntFunc)
    println(result) // PRINTS: List(0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20)

    // Pass the tripleIntFunc function (defined near the bottom
    // of this program) to the List.map() function...
    result = numbers.map(tripleIntFunc)
    println(result) // PRINTS: List(0, 3, 6, 9, 12, 15, 18, 21, 24, 27, 30)

    // Here we want to assign the tripleIntFunc (defined near the bottom of this program)
    // to a val.  That can't be done (code won't compile) unless an underscore (_) char
    // is added AFTER tripleIntFunc, as shown in the following line of code.
    val tripleIntFunc_2 = tripleIntFunc _
    result = numbers.map(tripleIntFunc_2)
    println(result) // PRINTS: List(0, 3, 6, 9, 12, 15, 18, 21, 24, 27, 30)

    // You do NOT need to add the underscore (_) char when the data type of
    // the val/var is explicitly declared.  In this example the data type
    // (Int => Int) declaration is specified; therefore, the underscore (_)
    // char is NOT required, it's optional.
    val tripleIntFunc_3:(Int => Int) = tripleIntFunc
    result = numbers.map(tripleIntFunc_3)
    println(result) // PRINTS: List(0, 3, 6, 9, 12, 15, 18, 21, 24, 27, 30)
  }

  def tripleIntFunc(number:Int):Int = number * 3
}

======================================================================

Another code sample of how to use an Eta Expansion is shown below.
Read in-line comments for details.

object Demo
{
  def main(args: Array[String]): Unit = {
    def doubleIntFunc(number:Int) = number * 2
    def tripleIntFunc(number:Int) = number * 3

    // The underscore (_) chars are REQUIRED in the declaration of the
    // val functions because its data type is NOT explicitly declared.
    // In the declaration further below the data type of val functions_2
    // is specified, so the underscore (_) chars are not required.
    val functions = Map("2x" -> doubleIntFunc _,
                        "3x" -> tripleIntFunc _)

    var result:Int = functions("2x").apply(444)
    println("1) " + result) // PRINTS: 1) 888
    // An equivalent way of doing what's done in the 2 lines above...
    var func:(Int => Int) = functions("2x")
    println("2) " + func(444)) // PRINTS: 2) 888

    result = functions("3x").apply(222)
    println("3) " + result) // PRINTS: 3) 666
    // An equivalent way of doing what's done in the 2 lines above...
    func = functions("3x")
    println("4) " + func(222)) // PRINTS: 4) 666

    // The following val functions_2 declaration is identical to the above
    // val functions declaration EXCEPT the underscore (_) chars are NOT
    // required (but could still be included) because the data type
    // of val functions_2 is explicitly declared...
    val functions_2:Map[String, Int => Int] = Map("2x" -> doubleIntFunc,
                                                  "3x" -> tripleIntFunc)
    result = functions_2("2x").apply(444)
    println("5) " + result) // PRINTS: 5) 888
    result = functions_2("3x").apply(222)
    println("6) " + result) // PRINTS: 6) 888
  }
}

======================================================================
