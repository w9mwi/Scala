A Scala Extractor is defined as an object that has a method
named unapply() as one of its methods.  This unapply() method
extracts an object and returns the attributes.  The unapply()
method is also used in Pattern matching and Partial functions.
Extractors also explain the apply() method, which takes arguments
and constructs an object.  The unapply() method reverses the
construction procedure of the apply() method.

The following code shows an example of an apply() and unapply() method.
The unapply() method simply "undoes" what the apply() method does.
========================================================================
object Demo
{
  def main(args: Array[String])
  {
    def apply(firstname: String, lastname: String):String =
    {
      firstname + "James" + lastname
    }

    def unapply(string:String):Option[(String, String)] =
    {
      val array:Array[String] = string.split("James")

      if (array.length == 2)
        Some(array(0), array(1))
      else
        None
    }

    // The following 2 println() statements print:
    // apply("Tom", "Jones"))    = TomJamesJones
    // unapply("JonesJamesTom")) = Some((Jones,Tom))
    println("""apply("Tom", "Jones"))    = """ + apply("Tom", "Jones"))
    println("""unapply("JonesJamesTom")) = """ + unapply("JonesJamesTom"))
  }
}
========================================================================
The following sample shows that your unapply() method doesn't really
need to perform the opposite operation of the apply() method.

object Demo
{
  // Main method
  def main(args: Array[String])
  {
    def apply(q:Double):Double = q * 10

    def unapply(r:Int):Option[Int] =
    {
      if (r % 5 == 0)
        Some(r * 5)
      else
        None
    }

    println("apply(20) = " + apply(20))     // PRINTS: apply(20) = 200.0
    println("unapply(20) = " + unapply(20)) // PRINTS: unapply(20) = Some(100)
    println("unapply(19) = " + unapply(19)) // PRINTS: unapply(19) = None
  }
}
========================================================================
Extractors can be utilized in Pattern Matching.  While comparing the
Object of an Extractor in Pattern Matching, the unapply method will
be executed spontaneously.  The following code shows this example
of Pattern Matching. All "case classes" in Scala already have an
Extractor, so it can be utilized spontaneously with Pattern Matching.

object Demo
{
  def main(args: Array[String])
  {
    // This program prints the following text to the console.
    // apply(25.0) is called.   x = 5.0
    // unapply(5.0) is called.  y = 1.0

    val x:Double = Demo(25) // NOTE: This line of code literally calls: Demo.apply(25) so x = 5.0
    println("x = " + x)

    // Apply pattern matching here...
    x match
    {
      case Demo(y) => println("y = " + y) // This line of code literally calls: Demo.unapply(5.0)
      case _ => println("Can't be evaluated.")
    }
  }

  def apply(x:Double):Double = { print("apply(" + x + ") is called.   "); x / 5 }

  def unapply(z:Double):Option[Double] =
  {
    print("unapply(" + z + ") is called.  ")
    if (z % 5 == 0)
      Some(z / 5)
    else None
  }
}

========================================================================
For more info, on this example, see:
https://www.journaldev.com/8270/scala-extractors-apply-unapply-and-pattern-matching

object Demo
{
  case class Address(city: String, state: String)
  case class Student(name: String, address: Seq[Address])

  object City
  {
    def unapply(s: Student): Option[Seq[String]] =
    { println("unapply() called.");  Some(for(c <- s.address) yield c.state) }
  }

  class StringSeqContains(value: String)
  {
    // NOTE: The contains() method tests whether the sequence contains a given value as an element.
    //       in.contains(value) could also be written as: in contains value
    def unapply(in:Seq[String]): Boolean = { in.contains(value) }
  }

  def main(args: Array[String]):Unit =
  {
    testSeqStr()
    val stud:List[Student] = List(Student("Harris", List(Address("LosAngeles",   "California"))),
                                  Student("Reena",  List(Address("Houston",      "Texas"))),
                                  Student("Rob",    List(Address("Dallas",       "Texas"))),
                                  Student("Chris",  List(Address("Jacksonville", "Florida"))))

    val Texas:StringSeqContains = new StringSeqContains("Texas")
    val students:List[String] = stud.collect { case student@City(Texas()) => student.name }
    println(students) // PRINTS: List(Reena, Rob)
    }

  def testSeqStr():Unit =
  {
    // This method exists just to demonstrate how a Seq[String] data
    // type is used.  A Seq[String] is nearly the same (but NOT
    // identical) data type as List[String], as shown here...
    val seqStr:Seq[String] = Seq("123", "ABC", "789", "XYZ")
    var list:List[String] = List()
    list = seqStr(0) :: seqStr(1) :: seqStr(2) :: seqStr(3) :: list
    println(list)   // PRINTS: List(123, ABC, 789, XYZ)
    println(seqStr) // PRINTS: List(123, ABC, 789, XYZ)
    // list = seqStr;  // This line will NOT compile cuz list and seqStr are different data types.
    val seqStr2:Seq[String] = seqStr  // This line compiles cuz seqStr2 and seqStr are identical data types.
    println(seqStr2) // PRINTS: List(123, ABC, 789, XYZ)
  }
}
========================================================================
