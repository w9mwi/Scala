A Scala class that defines an unapply() method is called an extractor.

Scala Extractor - Defined as an object that has a method named
unapply() as one of its methods.  The unapply() method extracts
an object and returns the argument(s).  The unapply() method is
USED IN PATTERN MATCHING AND PARTIAL FUNCTIONS.  Extractors also
explain the apply() method, which takes arguments and constructs
an object.  The unapply() method REVERSES the construction
procedure of the apply() method.

IMPORTANT:
The unapply() method says:  Pass me the object which was created by
applying a function to argument x, and I will return the argument x.

Since the purpose of unapply() is to extract values from an object,
it is in some sense the exact opposite of a constructor, whose
purpose it is to collect values and hide them in an object.

unapply() (and unapplySeq()) is "silently" called on a class whenever
you attempt to PATTERN MATCH on a class instance.  That is, unapply()
gets called via the case statement that matches the object, which
means Scala calls it in the background--you don't call it directly.

The returned result type of an unapply() method MUST CONTAIN A get()
METHOD, which is used as an extractor pattern.  That's why unapply()
methods typically return an Option type.  Because the Option type
already contains a get() method.  When the unapply() method is called
on a pattern match, it simply "undoes" what the apply() method does.

Whenever you define a regular class (not a case class) that you want
to pattern match on, you must write your own unapply() method, and
then place it inside that class's COMPANION OBJECT.  See the following
sample code for an example of this.

========================================================================
The apply() and unapply() methods defined in this code sample are
the Demo.apply() and Demo.unapply() methods.  They are NOT being
invoked automatically by Scala, but are being called here manually.

This sample code shows that Demo.unapply() method doesn't really
need to perform the opposite operation of the Demo.apply() method.

object Demo
{
  // Main method
  def main(args: Array[String])
  {
    def apply(q:Double):Double = q * 10

    def unapply(r:Int):Option[Int] =
    {
      if (r % 5 == 0)
        Some(r * 5)
      else
        None
    }

    println("apply(20) = " + apply(20))     // PRINTS: apply(20) = 200.0
    println("unapply(20) = " + unapply(20)) // PRINTS: unapply(20) = Some(100)
    println("unapply(19) = " + unapply(19)) // PRINTS: unapply(19) = None
  }
}

========================================================================
The apply() and unapply() methods defined in this code sample are the
Demo.apply() and Demo.unapply() methods.

object Demo
{
  def main(args: Array[String])
  {
    def apply(firstname: String, lastname: String):String =
    {
      firstname + "James" + lastname
    }

    def unapply(string:String):Option[(String, String)] =
    {
      val array:Array[String] = string.split("James")

      if (array.length == 2)
        Some(array(0), array(1))
      else
        None
    }

    // The following 2 println() statements print:
    // apply("Tom", "Jones"))    = TomJamesJones
    // unapply("JonesJamesTom")) = Some((Jones,Tom))
    println("""apply("Tom", "Jones"))    = """ + apply("Tom", "Jones"))
    println("""unapply("JonesJamesTom")) = """ + unapply("JonesJamesTom"))
  }
}

========================================================================
Extractors can be utilized in Pattern Matching.  While comparing the
Object of an Extractor in Pattern Matching, the unapply() method is
invoked by Scala when the "match" statement is executed.  In Scala,
every "case class" has an unapply() method (an Extractor) by default,
so all case classes can be used in pattern matching.

object Demo
{
  def main(args: Array[String])
  {
    val x:Double = Demo(25) // NOTE: This line of code invokes the method:  Demo.apply(25)
    println("2) x = " + x)  // PRINTS: 2) x = 5.0

    // Perform pattern matching...
    x match
    {
      // The following line of code invokes the method: Demo.unapply(5.0)
      case Demo(y) => println("4) y = " + y)  // PRINTS: 4) y = 1.0
      case _ => println("Can't be evaluated.")  // This line NEVER executes.
    }
  }

  def apply(x:Double):Double =
  {
    println("1) apply(" + x + ") is called.   "); x / 5   // PRINTS: 1) apply(25.0) is called.
  }

  def unapply(z:Double):Option[Double] =
  {
    println("3) unapply(" + z + ") is called.  ") // PRINTS: unapply(5.0) is called.
    if (z % 5 == 0)
      Some(z / 5)
    else None
  }
}

========================================================================
import Demo.MyClass

object Demo
{
  class MyClass(val name:String, val id:Int)

  def main(args: Array[String]):Unit =
  {
    val mc = new MyClass("Tom", id = 123456)

    mc match
    {
      // When the following line of code executes, Scala automatically
      // invokes the MyClass.unapply() method, defined below.
      case MyClass(x) => println("2) x.name = " + x.name + ",  x.id = " + x.id) // PRINTS: 2) x.name = Tom,  x.id = 123456
      case _          => println("No pattern match.") // This line of code never executes.
    }

    mc match
    {
      // The following line of code does NOT call the MyClass.unapply()
      // method because it matches on the MyClass class.
      case x:MyClass => println("3) x.name = " + x.name + ",  x.id = " + x.id) // PRINTS: 3) x.name = Tom,  x.id = 123456
      case _         => println("No pattern match.") // This line of code never executes.
    }
  }
}

/**
 * This "object MyClass" is the COMPANION OBJECT to the class MyClass that's
 * defined above inside "object Demo".  This "object Myclass" could be moved
 * inside the above-defined "object Demo", and it would work.
 *
 * The class MyClass is declared above (inside "object Demo") as a regular class
 * (not a case class).  Only a case class contains an unapply() method by default,
 * when it's declared.

  To obtain an unapply() method for a regular class like MyClass,
  you must write your own unapply() method.  Where the unapply()
  method is defined inside the MyClass's COMPANION OBJECT.  And
  the companion object also has the name MyClass, as shown here...
 */
object MyClass
{
  def unapply(x:MyClass):Option[MyClass] =
  {
    // The following line PRINTS:  1) MyClass.unapply() called.  x.name = Tom,  x.id = 123456
    println("1) MyClass.unapply() called.  x.name = " + x.name + ",  x.id = " + x.id)
    Some(x) // Return the Option type because it contains the get() method.
  }
}

========================================================================

object Demo
{
  case class Address(city: String, state: String)
  case class Student(name: String, address: Seq[Address])

  object State
  {
    def unapply(stud:Student):Option[Seq[String]] =
    {
      println("State.unapply() called.")
      // In the following line of code, "for(addr <- stud.address)" will return
      // a SINGLE Address, such as this:  Address(Jacksonville,Florida)
      // Then, "yield addr.state" returns ONLY THE STATE as a Seq[String] wrapped
      // in an Option.  An example of what's returned is this:  Some(List(Florida))
      Some(for(addr <- stud.address) yield addr.state)
    }
  }

  class StrSeqContains(strValue:String)
  {
    def unapply(strSeq:Seq[String]):Boolean =
    {
      println("StrSeqContains.unapply() called.")
      // The following contains() method tests if strSeq contains strValue
      strSeq.contains(strValue) // This line can also be written as: strSeq contains strValue
    }
  }

  def main(args:Array[String]):Unit =
  {
    val stud:List[Student] = List(Student("Harris", List(Address("LosAngeles",   "California"))),
                                  Student("Reena",  List(Address("Houston",      "Texas"))),
                                  Student("Rob",    List(Address("Dallas",       "Texas"))),
                                  Student("Chris",  List(Address("Jacksonville", "Florida"))))

    val Texas:StrSeqContains = new StrSeqContains("Texas")
    // The following line of code calls State.unapply() AND StrSeqContains.unapply().
    // Both those unapply() methods are called 4 times--once for each student.
    val students:List[String] = stud.collect { case student@State(Texas()) => student.name }
    println(students) // PRINTS: List(Reena, Rob)
    testSeqStr()
  }

  def testSeqStr():Unit =
  {
    // This method exists just to demonstrate how a Seq[String] data
    // type is used.  A Seq[String] is nearly the same (but NOT
    // identical) data type as List[String], as shown here...
    val seqStr:Seq[String] = Seq("123", "ABC", "789", "XYZ")
    var list:List[String] = List()
    list = seqStr(0) :: seqStr(1) :: seqStr(2) :: seqStr(3) :: list
    println(list)   // PRINTS: List(123, ABC, 789, XYZ)
    println(seqStr) // PRINTS: List(123, ABC, 789, XYZ)
    // list = seqStr;  // This line will NOT compile cuz list and seqStr are different data types.
    val seqStr2:Seq[String] = seqStr  // This line compiles cuz seqStr2 and seqStr are identical data types.
    println(seqStr2) // PRINTS: List(123, ABC, 789, XYZ)
  }
}
