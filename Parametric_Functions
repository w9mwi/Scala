Functions can have parameter types, just like Arrays (Array[Char], Array[Double], Array[Int])
and Lists (List[Char], List[Double], List[Int]) can have types.

To make a function work with multiple data types (as Array and List functions do),
you need to declare the function as parametric, as in this example:
=================================================================================
See this parametric function...
def map[A,B](func: (A) => B, list:Seq[A]):Seq[B] =
...on this web page. --> https://github.com/w9mwi/Scala/blob/master/Functional_Programming_1
=================================================================================
object Demo
{
  def main(args:Array[String]): Unit =
  {
    println(myFunction('x'))      // Pass myFunction a Char type--it returns the Char you passed it.
    println(myFunction("string")) // Pass myFunction a String type--it returns the String you passed it.
    println(myFunction(123.4F))   // Pass myFunction a Float type--it returns the Float you passed it.
    println(myFunction(987.6D))   // Pass myFunction a Double type--it returns the Double you passed it.
    
    println(makeTuple(987.6D, 123.4F))
    println(makeTuple('x', "string"))

    println(makeThreeElementList('X', 'Y', 'Z'))
    println(makeThreeElementList("Pop", "Stop", "Top"))
  }

  // NOTE: The T character below represents the data TYPE that gets passed to myFunction.
  //       The t character below represents the data VALUE that gets passed to myFunction, and then returned.
  //       The T and t chars shown below could be designated by any valid name, but it's
  //       convention to use a single upper-case char to designate a data type, and a single
  //       lower-case char to designate a data value.
  def myFunction[T](t:T) = t

  // The makeTuple function below take two parameters (parameter a, of type A, and parameter b of type B)
  // and returns the tuple (a, b).
  def makeTuple[A,B](a:A, b:B) = (a, b)

  // The makeThreeElementList function below take three parameters (parameter a1, of type A,
  // parameter a2 of type A, and parameter a3 of type A) and returns a 3-element List
  // containing the 3 values passed to this function.
  def makeThreeElementList[A](a1:A, a2:A, a3:A) = List(a1, a2, a3)
}
=================================================================================
The code below shows how to declare and use a parametric class
named "Sequence", as well the parametic method named "map".

import scala.collection.mutable.ArrayBuffer

object Demo
{
  case class Person(firstName:String, lastName:String)
  case class Sequence[A](initialElems: A*) // NOTE: The A* designates a variable number of args of data type A.
  {
    // NOTE: Every line of code within a class (i.e., this Sequence class) that is
    //       NOT a method gets executed when the class's constructor is called.
    //       Therefore, the following two lines of code get executed when this
    //       Sequence class's constructor is called.  You'd think that because
    //       elems is a val type, the second line below wouldn't compile because
    //       it's the second time elems is being assigned a value.  But that's not
    //       what's happening.  The first line below is only declaring that elems
    //       is an ArrayBuffer of type A.  The only time elems actually gets
    //       assigned a value is in the second line below.
    private val elems = ArrayBuffer[A]()
    elems ++= initialElems // This line of code is equivalent to this:  for { e <- initialElems } elems += e

    def foreach(block: A => Unit):Unit = { elems.foreach(block) }
    def map[B](func: A => B):Sequence[B] =
    {
      val myMap:ArrayBuffer[B] = elems.map(func)
      new Sequence(myMap: _*) // NOTE: The _ char makes Sequence() work with a variable number of arguments.
    }
  }

  def main(args:Array[String]): Unit =
  {
    // NOTE: The Sequence class can work with different types (i.e., String, Int, Person etc.) because
    //       it's defined as a parametric class, where the data type is determined at run time.
    val strings:Sequence[String] = Sequence("one", "two")
    val nums:Sequence[Int]       = Sequence(1, 2, 3, 4, 5)
    val names:Sequence[Person]   = Sequence(Person("Joe", "Blow"), Person("Jack", "Smack"), Person("Frank", "Crank"))

    // NOTE: The following for() loops would cause compile errors if the foreach()
    //       and map() methods weren't defined in the above Sequence class.
    val strResult:Sequence[String]    = for (str <- strings) yield str
    val intResult:Sequence[Int]       = for { i <- nums  }   yield i*2
    val personResult:Sequence[Person] = for (name <- names)  yield name

    for (str <- strResult) print(str + " ") // PRINTS: one two
    println
    for (int <- intResult) print(int + " ") // PRINTS: 2 4 6 8 10
    println
    for (name <- personResult) print(name + " ") // PRINTS: Person(Joe,Blow) Person(Jack,Smack) Person(Frank,Crank)

  }
}
