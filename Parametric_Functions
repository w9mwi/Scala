Functions can have parameter types, just like Arrays can have types...
Array[Char]   - An Array of Chars
Array[Double] - An Array of Doubles
Array[Int]    - An Array of Ints
...and just like Lists can have types...
List[Char]   - A List of Chars
List[Double] - A List of Doubles
List[Int]    - A List of Ints
=================================================================================
In the sample code below, we make 4 different functions work with multiple data
types by declaring them as parametric functions.

object Demo
{
  def main(args:Array[String]): Unit =
  {
    println(myFunction('X'))           // PRINTS: X
    println(myFunction("My string"))   // PRINTS: My string
    println(myFunction(123.4F))        // PRINTS: 123.4
    println(myFunction(987.6D))        // PRINTS: 987.6

    println(makeTuple(987.6D, 123.4F)) // PRINTS: (987.6,123.4)
    println(makeTuple('A', "zip"))     // PRINTS: (A,zip)

    println(makeThreeElementList('X', 'Y', 'Z'))        // PRINTS: List(X, Y, Z)
    println(makeThreeElementList("Pop", "Stop", "Top")) // PRINTS: List(Pop, Stop, Top)

    val intList:List[Int] = List(1, 2, 3, 4, 5, 6)
    val result_1:Int = ourFold(intList, 0)(_+_)
    println("result_1 = " + result_1) // PRINTS: result_1 = 21

    val floatList:List[Float] = List(1.23F, 4.56F, 7.89F)
    val result_2:Float = ourFold(floatList, 0.0F)(_+_)
    println("result_2 = " + result_2) // PRINTS: result_2 = 13.68
  }

  // NOTE: The T character in the myFunction() definition below represents a DATA TYPE.
  //       The 't' character in the myFunction() definition below represents a DATA VALUE.
  //       We read the definition of myFunction() below like this...
  //       1) myFunction() returns the data type T.  That's the [T]
  //       2) myFunction gets passed a t parameter of type T.  That's the (t:T)
  //       2) myFunction returns the data value t.  That's the 't' at the end.
  def myFunction[T](t:T) = t

  // The makeTuple function below take two parameters (parameter a, of type A, and parameter b of type B)
  // and returns the tuple (a, b).
  def makeTuple[A,B](a:A, b:B) = (a, b)

  // The makeThreeElementList function below take three parameters (parameter a1, of type A,
  // parameter a2 of type A, and parameter a3 of type A) and returns a 3-element List
  // containing the 3 values passed to this function.
  def makeThreeElementList[A](a1:A, a2:A, a3:A) = List(a1, a2, a3)

  /**
    * The result returned by this curried function is dependent on the type of List
    * it gets passed (i.e., List[Int], List[Float], etc.) and the function that gets
    * passed to it.  For example, if a List[Int] gets passed to this function,
    * it will return an Int value.  If a List[Float] list gets passed to this function,
    * it will return a Float value.  The value of the returned result is dependent
    * on the function that gets passed to this function.
    *
    * @param list - A Scala List of type A, where A is a parameterized type.
    * @param base - A value of type B, where B is a parameterized type.
    * @param func - A function defined by the programmer that gets passed a value
    *               of type A, and a value of type B.
    * @tparam A See params above
    * @tparam B See params above
    * @return
    */
  def ourFold[A,B](list:List[A], base:B)(func:(A,B) => B):B =
  {
    if   (list.isEmpty) base
    else func(list.head, ourFold(list.tail, base)(func))
  }
}

=================================================================================
The code below shows how to declare and use a parametric class
named "Sequence", as well the parametic method named "map".

import scala.collection.mutable.ArrayBuffer
object Demo
{
  case class Person(firstName:String, lastName:String)
  case class Sequence[A](initialElems: A*) // NOTE: The A* designates a variable number of args of data type A.
  {
    // NOTE: Every line of code within a class (i.e., this Sequence class) that is
    //       NOT a method gets executed when the class's constructor is called.
    //       Therefore, the following two lines of code get executed when this
    //       Sequence class's constructor is called.  You'd think that because
    //       elems is a val type, the second line below wouldn't compile because
    //       it's the second time elems is being assigned a value.  But that's not
    //       what's happening.  The first line below is only declaring that elems
    //       is an ArrayBuffer of type A.  The only time elems actually gets
    //       assigned a value is in the second line below.
    private val elems = ArrayBuffer[A]()
    elems ++= initialElems // This line of code is equivalent to this:  for { e <- initialElems } elems += e

    def foreach(block: A => Unit):Unit = { elems.foreach(block) }
    def map[B](func: A => B):Sequence[B] =
    {
      val myMap:ArrayBuffer[B] = elems.map(func)
      new Sequence(myMap: _*) // NOTE: _* makes Sequence() work with a variable number of arguments.
    }
    def withFilter(p: A => Boolean):Sequence[A] =
    {
      val tempArrayBuffer:ArrayBuffer[A] = elems.filter(p)
      Sequence(tempArrayBuffer: _*) // NOTE: _* makes Sequence() work with a variable number of arguments.
    }
  }

  def main(args:Array[String]): Unit =
  {
    // NOTE: The Sequence class can work with different types (i.e., String, Int, Person etc.) because
    //       it's defined as a parametric class, where the data type is determined at run time.
    val strings:Sequence[String] = Sequence("one", "two", "three")
    val nums:Sequence[Int]       = Sequence(1, 2, 3, 4, 5)
    val names:Sequence[Person]   = Sequence(Person("Joe", "Blow"), Person("Jack", "Smack"), Person("Frank", "Crank"))

    // NOTE: The following 3 for() loops would cause compile errors if the foreach()
    //       and map() methods weren't defined in the above Sequence class.  The
    //       if() statement embedded within the 2nd for() loop below would cause
    //       a compile error if the withFilter() method wasn't defined in the
    //       above Sequence class.  To summarize...
    //       1) The single generators below (i.e., (str < strings)) work because Sequence.foreach() is defined above.
    //       2) The below yield statements work because Sequence.map() is defined above.
    //       3) The below "if i > 2" statement worka because Sequence.withFilter() is defined above.
    val strResult:Sequence[String]    = for (str <- strings)        yield str
    val intResult:Sequence[Int]       = for { i <- nums; if i > 2 } yield i*2
    val personResult:Sequence[Person] = for (name <- names)         yield name

    for (str <- strResult) print(str + " ") // PRINTS: one two three
    println
    for (int <- intResult) print(int + " ") // PRINTS: 6 8 10
    println
    for (name <- personResult) print(name + " ") // PRINTS: Person(Joe,Blow) Person(Jack,Smack) Person(Frank,Crank)

  }
}
=================================================================================
See this parametric function...
def map[A,B](func: (A) => B, list:Seq[A]):Seq[B] =
...on this web page. --> https://github.com/w9mwi/Scala/blob/master/Functional_Programming_1
