
A PARAMETRIC FUNCTION is defined to accept any valid data type that can work with
the function.  For example, instead of defining 3 different add() functions to
work with the Int, Float, and Double data types, you can write a single add()
function as a parametric function, so it'll work with all 3 of those data types.

The following code sample shows this by defining the add()
function so it calls Scala's Numeric.plus() function.
Note that the add() function is a curried function that's
defined to accept TWO (2) parameter lists.  So the add()
function returns a function which takes A as a Numeric
parameter type, and returns type A.


object Demo
{
  // The following add() function is written as a parametric function,
  // where the parametric type A represents any Numeric data type.
  def add[A](x:A, y:A)(implicit numeric:Numeric[A]):A = numeric.plus(x, y)

  def main(args:Array[String]): Unit =
  {
    println("add(1.23F, 4.56F) = " + add(1.23F, 4.56F)) // PRINTS: add(1.23F, 4.56F) = 5.79
    println("add(1.23D, 4.56D) = " + add(1.23D, 4.56D)) // PRINTS: add(1.23D, 4.56S) = 5.789999999999999
    println("add(123, 456)     = " + add(123, 456))     // PRINTS: add(123, 456)     = 579
    println("add(123, 4.56F)   = " + add(123, 4.56F))   // PRINTS: add(123, 456)     = 127.56
  }
}

========================================================================================

In the sample code below, we make 4 different functions work with multiple data
types by declaring them as parametric functions.

object Demo
{
  def main(args:Array[String]): Unit =
  {
    println(myFunction('X'))           // PRINTS: X
    println(myFunction("My string"))   // PRINTS: My string
    println(myFunction(123.4F))        // PRINTS: 123.4
    println(myFunction(987.6D))        // PRINTS: 987.6

    println(makeTuple(987.6D, 123.4F)) // PRINTS: (987.6,123.4)
    println(makeTuple('A', "zip"))     // PRINTS: (A,zip)

    println(makeThreeElementList('X', 'Y', 'Z'))        // PRINTS: List(X, Y, Z)
    println(makeThreeElementList("Pop", "Stop", "Top")) // PRINTS: List(Pop, Stop, Top)

    val intList:List[Int] = List(1, 2, 3, 4, 5, 6)
    val result_1:Int = ourFold(intList, 0)(_+_)
    println("result_1 = " + result_1) // PRINTS: result_1 = 21

    val stringList:List[String] = List("A", "B", "C")
    val result_2:String = ourFold(stringList, "D")(_ + "" + _)
    println("result_2 = " + result_2) // PRINTS: result_2 = ABCD
  }

  /**
   *
   * This is a RECURSIVE, CURRIED FUNCTION.  The List passed to this function can
   * be of any data type that works with the '+' operator, such as Int, Float, String,
   * etc.  The data type must work with the '+' operator because both times this
   * ourFold() function gets called (by the main() function) the 'func' parameter
   * passed to it uses the '+' operator.
   *
   * Since both operands used by the '+' operator must be of the same data type,
   * data type A and data type B MUST BE OF THE SAME DATA TYPE.
   *
   * @param list - A Scala List of type A, where A is a parameterized type.
   * @param base - A value of type B, where B is a parameterized type.
   * @param func - A function defined by the programmer that gets passed a value
   *               of type A, and a value of type B.
   * @return - A value of type A.
   */
  def ourFold[A](list:List[A], base:A)(func:(A,A) => A):A =
  {
    // NOTE: The first line of this ourFold() function can be written either
    //       of these 3 ways, and the returned result will be identical:
    //       1) def ourFold[A](list:List[A], base:A)(func:(A,A) => A):A =
    //       2) def ourFold[A,B](list:List[B], base:A)(func:(B,A) => A):A =
    //       3) def ourFold[B,A](list:List[A], base:B)(func:(A,B) => B):B =

    // NOTE: Every time this ourFold() function gets called recursively below,
    //       the contents of these two (2) arguments remain UNCHANGED:
    //       1) base
    //       2) func
    //       Every time this ourFold() function gets called recursively below,
    //       the list param becomes one (1) element smaller (because list.tail
    //       gets passed to the list argument), until the if() statement
    //       executes, which terminates the recursion.
    if (list.isEmpty) base
    else func(list.head, ourFold(list.tail, base)(func))
  }

  // The 'T' character in the myFunction() definition below represents a DATA TYPE.
  // The 't' character in the myFunction() definition below represents a DATA VALUE.
  // myFunction does nothing but return the same value (and data type) it was passed.
  // Since myFunction uses a parametric type, it will work with ALL data types.
  def myFunction[T](t:T):T = t

  // The below makeTuple() function takes two parameters (one of type A, one of type B),
  // and returns a tuple of type (A, B).
  def makeTuple[A,B](a:A, b:B):(A, B) = (a, b)

  // The below makeThreeElementList() function takes three parameters all of type A,
  // and returns a List of type A, containing the 3 values passed to this function.
  def makeThreeElementList[A](a1:A, a2:A, a3:A):List[A] = List(a1, a2, a3)
}

========================================================================================

The following sample code includes this CURRIED, PARAMETRIC FUNCTION:

def funcOfGunc[A,B,C](func:(B=>C), gunc:(A=>B)):(A=>C) = { x=>func(gunc(x)) }

Recall that a curried function gets called by passing it at least two (2)
separate argument lists.  The code below confirms that funcOfGunc is called
by passing it two (2) argument lists, which means funcOfGunc is a curried
function.  However, notice that funcOfGunc is defined with only one argument
list; yet, it gets called by passing it two (2) argument lists!!!

The following 4 steps describe how we determined the above funcOfGunc signature.

1)
We will pass 2 functions to funcOfGunc in a single parameter list.  Both those
functions get passed a Double, and return a Double.

NOTICE: Recall that a curried function always has at least TWO (2) parameter
        lists.  The second parameter list that funcOfGunc accepts is NOT included
        in the funcOfGunc definition because funcOfGunc returns a function that
        accepts a single parameter.  Therefore, the return value of funcOfGunc
        is where the second parameter list gets defined.

2)
Since the gunc function gets called FIRST, we will begin by saying gunc(x) gets
passed a parameter of type A, and returns type B.  So gunc has this return type:
A=>B

2)
The func function gets called AFTER gunc is called, and gets passed the
value returned by gunc, which is type B.  So func has this return type:
B=>C

4)
After both the func and gunc functions passed to funcOfGunc are called
(i.e., func(gunc(x))), funcOfGunc returns its value, which is a function
that gets passed a parameter.

Therefore, funcOfGunc gets passed the same value passed to gunc (parameter
type A), and it returns the same value returned by func (parameter type C).
So funcOfGunc has this return type:
A=>C


object Demo
{
  def main(args:Array[String]): Unit =
  {
    // The following "plus5" and "square" vals are defined as functions
    // that take a parameter of type Double, and return a type Double.
    val plus5:(Double=>Double)  = { x:Double => x+5.0D }
    val square:(Double=>Double) = { x:Double => x*x }

    // NOTE: 54.0 = 5.0+(7.0*7.0)
    var result:Double = funcOfGunc(plus5, square)(7.0D)
    println("result = " + result) // PRINTS: result = 54.0

    // NOTE: 144.0 = (5.0+7.0)*(5.0+7.0)
    result = funcOfGunc(square, plus5)(7.0D)
    println("result = " + result) // PRINTS: result = 144.0
  }

  def funcOfGunc[A,B,C](func:(B=>C), gunc:(A=>B)):(A=>C) = { x=>func(gunc(x)) }
}

========================================================================================

The funcXYZ function defined below is a parametric function.  It's also a curried function.
In the funcXYZ definition, the letters in the [A,B,C,D] section can appear in ANY ORDER,
for example:
funcXYZ[A,B,C,D]...
funcXYZ[B,A,D,C]...
funcXYZ[D,C,A,B]...
The order won't affect the behavior of the code, but it's best to always
keep them in alphabetical order.  Following that text in the function
definition, the correct parametric type must be used wherever one
is referenced.  Read the explanation below to determine how these
parametric types are determined for the funcXYZ function.

object Demo
{
  def funcX(x:Int):Int = { x + 10 }
  def funcY(y:Int):Int = { y - 3 }
  def funcZ(z:Int):Int = { z * 4 }

  // funcXYZ is identical to the below funcXYZ_2 function,
  // except funcXYZ_2 has 3 PARAMETER LISTS.
  def funcXYZ[A,B,C,D](funcX:(C=>D), funcY:(B=>C), funcZ:(A=>B)):(A=>D) =
  {
    x => funcX(funcY(funcZ(x)))
  }

  def main(args:Array[String]): Unit =
  {
    var result:Int = funcXYZ(funcX, funcY, funcZ)(5)
    println("result = " + result) // PRINTS: result = 27

    result = funcXYZ_2(funcX)(funcY)(funcZ)(5)
    println("result = " + result) // PRINTS: result = 27
  }
}

The funcXYZ definition uses parametric types to designate several return types.
You can choose any letters for the parametric types, but YOU SHOULD ALWAYS
begin using letter A, followed by B, C, D, etc. so it's easy to follow the order.
This part explains how the parametric return types are determined.

We begin by observing what funcXYZ returns.  We see that funcXYZ returns this...

x => funcX(funcY(funcZ(x)))

That's a function, which takes a single parameter (x), and returns this line of code:

funcX(funcY(funcZ(x)))  // Where x is the param passed to funcZ

When that line of code is executed, the first thing that executes is funcZ.
Let's begin by saying funcZ takes parameter A (representing the x parameter
value passed to funcZ), and it returns the value B, like this:

A=>B   (funcZ return type)

The next thing that executes is funcY.  The parameter fed to funcY comes
from the value returned by funcZ.  So the funcY return type is:

B=>C   (funcY return type)

The next thing that executes is funcX.  The parameter fed to funcX comes
from the value returned by funcY.  So the funcX return type is:

C=>D   (funcX return type)

Finally, we need to designate what funcXYZ returns.  funcXYZ RETURNS A FUNCTION that
takes the parameter x.  Notice that this x parmameter is literally the same value
that gets passed to funcZ.  Since funcZ defined that x value as type A, funcXYZ
must also use that same A value in its return type.  Therefore, the funcXYZ
return type is:

A=>D   (funcXYZ return type)

Now we can write the funcXYZ definition (shown below) using these return types...

funcXYZ returns: A=>D
funcZ   returns: A=>B
funcY   returns: B=>C
funcX   returns: C=>D

Those are the return types that get plugged into the funcXYZ definition, like this:

def funcXYZ[A,B,C,D](funcX:(C=>D), funcY:(B=>C), funcZ:(A=>B)):(A=>D) =
{
  x => funcX(funcY(funcZ(x)))
}

TAKE NOTE: The A value in the funcXYZ return type is literally the same value
           as the A value in the funcZ return type.  When funcXYZ is executed
           (either as a partially-applied or fully-applied function) funcZ
           is ALWAYS the FIRST parameter list executed.

           The D value in the funcXYZ return type is literally the same value
           as the D value in the funcX return type.  When funcXYZ becomes
           fully applied, funcX is ALWAYS the LAST parameter list executed.

========================================================================================
This code sample shows how to declare and use a parametric class
named "Sequence", as well the parametic method named "map".


import scala.collection.mutable.ListBuffer
object Demo
{
  case class Person(firstName:String, lastName:String)
  case class Sequence[A](private val initialElems: A*) // A* designates a variable number of args of type A.
  {
    private val elems:ListBuffer[A] = ListBuffer[A]()
    elems ++= initialElems // The ++= operator for the ListBuffer class appends multiple elements.
    // NOTE: "elems ++= initialElems" above could be replaced with:  for { x <- initialElems } elems += x

    /*********************************************************
     * NOTE: This foreach() method enables the main() function
     *       below to implement this type of for loop on this
     *       Sequence case class:
     *       for (x <- ints) println(x)
     ********************************************************/
    def foreach(block: A => Unit):Unit =
    {
      elems.foreach(block)
    }

    /*********************************************************
     * NOTE: This map() method enables the main() function
     *       below to implement this type of for loop on
     *       this Sequence case class:
     *       for { x <- ints } yield x*2
     ********************************************************/
    def map[B](func: A=>B):Sequence[B] =
    {
      val listBuf:ListBuffer[B] = elems.map(func)
      // NOTE: The :_* below is the syntax used when calling a constructor, or a method,
      //       that accepts a variable number of arguments.  In this example, since
      //       the Sequence constructor is written to accept a variable number of args,
      //       the :_* syntax must be used with the listBuf collection.
      Sequence(listBuf.toSeq:_*)
    }

    /*********************************************************
     * NOTE: This flatMap() method enables the main() function
     *       below to implement MULTIPLE GENERATORS within
     *       a for loop on this Sequence case class.
     ********************************************************/
    def flatMap[B](func: A => Sequence[B]):Sequence[B] =
    {
      var listBuf_1:ListBuffer[B] = ListBuffer[B]()
      for (listBuf_2:Sequence[B] <- map(func)) // map(func) calls the above-defined map() method.
      {
        for (elem <- listBuf_2) { listBuf_1 += elem }
      }
      // NOTE: The :_* below is the syntax used when calling a constructor, or a method,
      //       that accepts a variable number of arguments.  In this example, since
      //       the Sequence constructor is written to accept a variable number of args,
      //       the :_* syntax must be used with the listBuf_1 collection.
      Sequence(listBuf_1.toSeq:_*)
    }

    /*********************************************************
     * NOTE: This withFilter() method enables the main()
     *       function below to implement filters within
     *       for loops on this Sequence case class:
     ********************************************************/
    def withFilter(func: A => Boolean):Sequence[A] =
    {
      val listBuf:ListBuffer[A] = elems.filter(func)
      // NOTE: The :_* below is the syntax used when calling a constructor, or a method,
      //       that accepts a variable number of arguments.  In this example, since
      //       the Sequence constructor is written to accept a variable number of args,
      //       the :_* syntax must be used with the listBuf_1 collection.
      Sequence(listBuf.toSeq:_*)
    }
  } // END: case class Sequence[A]

  /*********************************************************
   *
   ********************************************************/
  def main(args:Array[String]): Unit =
  {
    // NOTE: The Sequence class can work with different types (i.e., String, Int, Person etc.) because
    //       it's defined as a parametric class, where the data type is determined at run time.
    val strings:Sequence[String] = Sequence("one", "two", "three")
    val numbers:Sequence[Int]    = Sequence(1, 2, 3, 4, 5)
    val names:Sequence[Person]   = Sequence(Person("Joe", "Blow"), Person("Jack", "Smack"), Person("Frank", "Crank"))

    // NOTE: The following 3 for() loops would cause compile errors if the foreach()
    //       and map() methods weren't defined in the above Sequence class.  The
    //       if() statement embedded within the 2nd for() loop below would cause
    //       a compile error if the withFilter() method wasn't defined in the
    //       above Sequence class.  To summarize...
    //       1) The generators shown below (i.e., "for (str < strings)") work cuz Sequence.foreach() is defined above.
    //       2) The below yield statements work because Sequence.map() is defined above.
    //       3) The below "if i > 2" statement works because Sequence.withFilter() is defined above.
    val strResult:Sequence[String]    = for (str <- strings)           yield str
    val intResult:Sequence[Int]       = for { i <- numbers; if i > 2 } yield i*2
    val personResult:Sequence[Person] = for (name <- names)            yield name

    for (str <- strResult) print(str + " ") // PRINTS: one two three
    println
    for (int <- intResult) print(int + " ") // PRINTS: 6 8 10
    println
    for (name <- personResult) print(name + " ") // PRINTS: Person(Joe,Blow) Person(Jack,Smack) Person(Frank,Crank)
    println

    // The following code REQUIRES the flatMap() method to be defined by the above case class named Sequence.
    val myFriends   = Sequence(Person("Jack", "Daniels"),    Person("Johnny", "Walker"), Person("Jim", "Beam"))
    val joesFriends = Sequence(Person("Joseph", "Schlitz"),  Person("George", "Jones"),  Person("Jim", "Beam"))

    // For a class to work with MULTIPLE for() loop generators (as shown here), that class
    // MUST implement a flatMap() method--as in the above-defined Sequence class.
    val mutualFriends = for
    {
      myFriend   <- myFriends   // This is a GENERATOR.
      joesFriend <- joesFriends // This is another GENERATOR.
      if (myFriend.firstName == joesFriend.firstName &&
        myFriend.lastName  == joesFriend.lastName)
    } yield myFriend
    println("mutualFriends = " + mutualFriends) // PRINTS: mutualFriends = Sequence(ArrayBuffer(Person(Jim,Beam)))
  }
}

========================================================================================
========================================================================================
========================================================================================
========================================================================================
