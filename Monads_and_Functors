MONAD - When speaking casually, some people say that any
        Scala class that implements both the map() and
        flatMap() methods is a MONAD.  That is NOT totally
        accurate, but it is close to being true.  Some
        Scala guy once said...

        "The only thing monads are relevant for, from a
        Scala language perspective, is their ability of
        being used in a for-comprehension."

        In Scala there is no base Monad trait to extend.
        All you have to do is implement map() and flatMap()
        so your class can be used as a generator in for
        expressions.  The List and Option Scala classes
        are true monads!!!

FUNCTOR - At some point in history, someone declared that
          "things that can be mapped-over shall be called
          functors."  Therefore, classes like List, Option,
          Future (and many others) are all functors.  Again...
          "Functors are things that can be mapped over."
          
          Functor = map-able = A class that contains a map() method.

=========================================================================
The following code comes from:
https://blog.redelastic.com/a-guide-to-scala-collections-exploring-monads-in-scala-collections-ef810ef3aec3

object Demo
{
  def main(args: Array[String]):Unit =
  {
    val monad1:List[Int] = List(1,2,3)
    val monad2:List[Int] = List(4,5,6)
    val monad3:List[Int] = List(7,8,9)

    val result1:List[Int] = for
                            {
                              a <- monad1
                              b <- monad2
                              c <- monad3
                            } yield combine(a,b,c)
    println(result1)

    // The following line of code is equivalent to the above for() comprehension.
    // In fact, when the above for() comprehension is executed, Scala converts
    // that for() comprehension into the the following equivalent code.
    val result2:List[Int] = monad1.flatMap(a => monad2.flatMap(b => monad3.map(c => combine(a,b,c))))
    println(result2)
  }

  def combine(a:Int, b:Int, c:Int):Int =
  {
    a + b + c
  }
}

=========================================================================

MORE INFORMATION REGARDING MONADS
=================================

The signature of the List.map method is:  map[B](f: (A) => B): List[B]
The signature of the List.flatMap method is: def flatMap[B](f: (A) => GenTraversableOnce[B]): List[B]
For this example we can simplify that to:    def flatMap[B](f: (A) => List[B]): List[B]

trait M[A]
{
  def flatMap[B](f: A => M[B]): M[B]
}
def unit[A](x: A): M[A]

https://medium.com/free-code-camp/demystifying-the-monad-in-scala-cc716bb6f534

Every Scala “wrapper” that provides the methods/operations of "unit" and flatMap
is essentially a monad, such as the following...

trait M[A]
{
  def flatMap[B](f: A => M[B]): M[B]
}
def unit[A](x: A): M[A]

It’s not enough to just provide methods with those names, those methods
must also follow certain laws, which are covered later.

See more info. here:
https://medium.com/free-code-camp/demystifying-the-monad-in-scala-cc716bb6f534

===========================================================

http://appliedscala.com/blog/2016/understanding-monads/

trait Monad[F[_]]
{
  def flatMap[A, B](fa: F[A])(f: (A) => F[B]): F[B]
  def pure[A](x: A): F[A]
}

===========================================================

https://blog.redelastic.com/a-guide-to-scala-collections-exploring-monads-in-scala-collections-ef810ef3aec3

Monads are containers, which means they contain elements of some type.
The content of a monad container can be any valid Scala type, such as
an Int, Option, List, etc.  A monad can contain no elements, one element,
or multiple elements.  When we create a monad around a value, we say that
we "lift" the value into the container.

Monads have these 3 properties:

1) A paramatized type, such as Option[T]
2) Unit (return), such as Option.apply()
3) FlatMap (bind), such as Option.flatMap()

FYI, Sclala's Option type is a monad.

Unit is defined as:  A => M[A]

In other words, type A is contained in the monad M.  So If the Option is the
monad, and A is of type Int, Unit is defined as Int => Option[Int]

In Scala, Unit is usually the apply() method, a special method that doesn't
have to be explicitly defined inside the class by the programmer.  Although
the programmer may define the apply() method if she desires to do so.
The apply() method does NOT need to be explicitly called by the programmer.
For example, the following 3 code snips are equivalent because when a class's
constructor is called, that class's apply() method gets called.

ClassA() = ClassA.apply() = ClassA{}

NOTE: The curly braces after Class{} allow you to use
      a multi-line expression for the parameter that
      gets passed to the apply() method.  This will
      become more important when using Scala classes
      Try and Future.

FlatMap is defined as:  (M[A], A => M[B]) => M[B]

So FlatMap "lifts" an A inside an M, and takes a function that "lifts" and
converts an A to a B inside an M, and then combines the two to get a B
inside an M.  In other words, we're defining a container type of M[A]
that performs an operation to produce and return an M[B].

FlatMap knows how to do these two things:
1) It can apply a function to A.
2) It can flatten a nested container. When the function
   in question doesn’t lift A, the flattening is unnecessary,
   and we just need to apply the function.

Map is defined as:  M[A] => M[B]

Map is used when you have a function A => B, rather than
A => M[B] and you want to apply it to the A inside an M[A].
Map is NOT one of the defining properties of monads because
it’s technically just a special case of FlatMap.

trait M[A]
{
  def flatMap[B](f: A => M[B]): M[B]
}
  
def unit[A](x: A): M[A]

https://medium.com/free-code-camp/demystifying-the-monad-in-scala-cc716bb6f534

===========================================================

http://appliedscala.com/blog/2016/understanding-monads/

trait Monad[F[_]]
{
  def flatMap[A, B](fa: F[A])(f: (A) => F[B]): F[B]
  def pure[A](x: A): F[A]
}

===========================================================

https://blog.redelastic.com/a-guide-to-scala-collections-exploring-monads-in-scala-collections-ef810ef3aec3

Monads are containers, which means they contain elements of some type.
The container itself has some has certain properties.  One this happens,
we can work with the container, and the container works with the
elements within it.

The content of a monad container can be any valid Scala
type, such as an Int, Option, List, etc.  A monad can
contain no elements, one element, or multiple elements.
When we create a monad around a value, we say that we
"lift" the value into the container.

Monads have these 3 properties:

1) A paramatized type, such as Option[T]
2) Unit (return), such as Option.apply()
3) FlatMap (bind), such as Option.flatMap()

FYI, Sclala's Option type is a monad.


Unit is defined as:  A => M[A]

In other words, type A is contained in the monad M.
So If the Option is the monad, and A is of type Int,
Unit is defined as Int => Option[Int]

In Scala, Unit is usually the apply() method, a
special method that doesn't have to be explicitly
defined inside the class by the programmer.  Although
the programmer may define the apply() method is she
wants.  The apply() method also doesn't need to be
explicitly called by the programmer.  For example,
the following code is equivalent because when a
class's constructor is called, that class's apply()
gets called.

ClassA() = ClassA.apply() = ClassA{}

NOTE: The curly braces after Class{} allow you
to use a multi-line expression for the parameter
that gets passed to the apply() method.  This
will become more important when using Scala
classes Try and Future.

FlatMap is defined as:  (M[A], A => M[B]) => M[B]

So FlatMap "lifts" an A inside an M, and takes a function
that "lifts" and converts an A to a B inside an M, and
then combines the two to get a B inside an M.  In other
words, we're defining a container type of M[A] that performs
an operation to produce and return an M[B].

FlatMap knows how to do two things:

1) It can apply a function to A.

2) It can flatten a nested container. When the function
   in question doesn’t lift A, the flattening is unnecessary,
   and we just need to apply the function.



Map is defined as:  M[A] => M[B]

Map is used when you have a function A => B, rather than
A => M[B] and you want to apply it to the A inside an M[A].
Map is NOT one of the defining properties of monads because
it’s technically just a special case of FlatMap.


nough to just provide methods with
those names, they must also follow certain laws, which we'll
cover later.

===========================================================

http://appliedscala.com/blog/2016/understanding-monads/

trait Monad[F[_]]
{
  def flatMap[A, B](fa: F[A])(f: (A) => F[B]): F[B]
  def pure[A](x: A): F[A]
}

===========================================================

https://blog.redelastic.com/a-guide-to-scala-collections-exploring-monads-in-scala-collections-ef810ef3aec3
https://blog.redelasat comtic.com/a-guide-to-scala-collections-exploring-monads-in-scala-collections-ef810ef3aec3
https://blog.redelastic.com/a-guide-to-scala-collections-exploring-monads-in-scala-collections-ef810ef3aec3

Monads are containers, which means they contain elements of some type.
The container itself has some has certain properties.  One this happens,
we can work with the container, and the container works with the
elements within it.

The content of a monad container can be any valid Scala
type, such as an Int, Option, List, etc.  A monad can
contain no elements, one element, or multiple elements.
When we create a monad around a value, we say that we
"lift" the value into the container.

Monads have these 3 properties:

1) A paramatized type, such as Option[T]
2) Unit (return), such as Option.apply()
3) FlatMap (bind), such as Option.flatMap()

FYI, Sclala's Option type is a monad.


Unit is defined as:  A => M[A]

In other words, type A is contained in the monad M.
So If the Option is the monad, and A is of type Int,
Unit is defined as Int => Option[Int]

In Scala, Unit is usually the apply() method, a
special method that doesn't have to be explicitly
defined inside the class by the programmer.  Although
the programmer may define the apply() method is she
wants.  The apply() method also doesn't need to be
explicitly called by the programmer.  For example,
the following code is equivalent because when a
class's constructor is called, that class's apply()
gets called.

ClassA() = ClassA.apply() = ClassA{}
The signature of the List.map method is:  map[B](f: (A) => B): List[B]

The signature of the List.flatMap method is: def flatMap[B](f: (A) => GenTraversableOnce[B]): List[B]
For this example we can simplify that to:    def flatMap[B](f: (A) => List[B]): List[B]


trait M[A]
{
  def flatMap[B](f: A => M[B]): M[B]
}
  
def unit[A](x: A): M[A]

https://medium.com/free-code-camp/demystifying-the-monad-in-scala-cc716bb6f534
https://medium.com/free-code-camp/demystifying-the-monad-in-scala-cc716bb6f534

Every “wrapper” that provides us with our two beloved
operations, unit, and flatMap, is essentially a monad.
Well, it’s not really enough to just provide methods with
those names, they must also follow certain laws, which we'll
cover later.

===========================================================

http://appliedscala.com/blog/2016/understanding-monads/

trait Monad[F[_]]
{
  def flatMap[A, B](fa: F[A])(f: (A) => F[B]): F[B]
  def pure[A](x: A): F[A]
}

===========================================================

https://blog.redelastic.com/a-guide-to-scala-collections-exploring-monads-in-scala-collections-ef810ef3aec3
https://blog.redelasat comtic.com/a-guide-to-scala-collections-exploring-monads-in-scala-collections-ef810ef3aec3
https://blog.redelastic.com/a-guide-to-scala-collections-exploring-monads-in-scala-collections-ef810ef3aec3

Monads are containers, which means they contain elements of some type.
The container itself has some has certain properties.  One this happens,
we can work with the container, and the container works with the
elements within it.

The content of a monad container can be any valid Scala
type, such as an Int, Option, List, etc.  A monad can
contain no elements, one element, or multiple elements.
When we create a monad around a value, we say that we
"lift" the value into the container.

Monads have these 3 properties:

1) A paramatized type, such as Option[T]
2) Unit (return), such as Option.apply()
3) FlatMap (bind), such as Option.flatMap()

FYI, Sclala's Option type is a monad.


Unit is defined as:  A => M[A]

In other words, type A is contained in the monad M.
So If the Option is the monad, and A is of type Int,
Unit is defined as Int => Option[Int]

In Scala, Unit is usually the apply() method, a
special method that doesn't have to be explicitly
defined inside the class by the programmer.  Although
the programmer may define the apply() method is she
wants.  The apply() method also doesn't need to be
explicitly called by the programmer.  For example,
the following code is equivalent because when a
class's constructor is called, that class's apply()
gets called.

ClassA() = ClassA.apply() = ClassA{}

NOTE: The curly braces after Class{} allow you
to use a multi-line expression for the parameter
that gets passed to the apply() method.  This
will become more important when using Scala
classes Try and Future.

FlatMap is defined as:  (M[A], A => M[B]) => M[B]

So FlatMap "lifts" an A inside an M, and takes a function
that "lifts" and converts an A to a B inside an M, and
then combines the two to get a B inside an M.  In other
words, we're defining a container type of M[A] that performs
an operation to produce and return an M[B].

FlatMap knows how to do two things:

1) It can apply a function to A.

2) It can flatten a nested container. When the function
   in question doesn’t lift A, the flattening is unnecessary,
   and we just need to apply the function.



Map is defined as:  M[A] => M[B]

Map is used when you have a function A => B, rather than
A => M[B] and you want to apply it to the A inside an M[A].
Map is NOT one of the defining properties of monads because
it’s technically just a special case of FlatMap.


The signature of the List.map method is:  map[B](f: (A) => B): List[B]

The signature of the List.flatMap method is: def flatMap[B](f: (A) => GenTraversableOnce[B]): List[B]
For this example we can simplify that to:    def flatMap[B](f: (A) => List[B]): List[B]


trait M[A]
{
  def flatMap[B](f: A => M[B]): M[B]
}
  
def unit[A](x: A): M[A]

https://medium.com/free-code-camp/demystifying-the-monad-in-scala-cc716bb6f534
https://medium.com/free-code-camp/demystifying-the-monad-in-scala-cc716bb6f534

Every “wrapper” that provides us with our two beloved
operations, unit, and flatMap, is essentially a monad.
Well, it’s not really enough to just provide methods with
those names, they must also follow certain laws, which we'll
cover later.

===========================================================

http://appliedscala.com/blog/2016/understanding-monads/

trait Monad[F[_]]
{
  def flatMap[A, B](fa: F[A])(f: (A) => F[B]): F[B]
  def pure[A](x: A): F[A]
}

===========================================================

https://blog.redelastic.com/a-guide-to-scala-collections-exploring-monads-in-scala-collections-ef810ef3aec3
https://blog.redelasat comtic.com/a-guide-to-scala-collections-exploring-monads-in-scala-collections-ef810ef3aec3
https://blog.redelastic.com/a-guide-to-scala-collections-exploring-monads-in-scala-collections-ef810ef3aec3

Monads are containers, which means they contain elements of some type.
The container itself has some has certain properties.  One this happens,
we can work with the container, and the container works with the
elements within it.

The content of a monad container can be any valid Scala
type, such as an Int, Option, List, etc.  A monad can
contain no elements, one element, or multiple elements.
When we create a monad around a value, we say that we
"lift" the value into the container.

Monads have these 3 properties:

1) A paramatized type, such as Option[T]
2) Unit (return), such as Option.apply()
3) FlatMap (bind), such as Option.flatMap()

FYI, Sclala's Option type is a monad.


Unit is defined as:  A => M[A]

In other words, type A is contained in the monad M.
So If the Option is the monad, and A is of type Int,
Unit is defined as Int => Option[Int]

In Scala, Unit is usually the apply() method, a
special method that doesn't have to be explicitly
defined inside the class by the programmer.  Although
the programmer may define the apply() method is she
wants.  The apply() method also doesn't need to be
explicitly called by the programmer.  For example,
the following code is equivalent because when a
class's constructor is called, that class's apply()
gets called.

ClassA() = ClassA.apply() = ClassA{}

NOTE: The curly braces after Class{} allow you
to use a multi-line expression for the parameter
that gets passed to the apply() method.  This
will become more important when using Scala
classes Try and Future.

FlatMap is defined as:  (M[A], A => M[B]) => M[B]

So FlatMap "lifts" an A inside an M, and takes a function
that "lifts" and converts an A to a B inside an M, and
then combines the two to get a B inside an M.  In other
words, we're defining a container type of M[A] that performs
an operation to produce and return an M[B].

FlatMap knows how to do two things:

1) It can apply a function to A.

2) It can flatten a nested container. When the function
   in question doesn’t lift A, the flattening is unnecessary,
   and we just need to apply the function.



Map is defined as:  M[A] => M[B]

Map is used when you have a function A => B, rather than
A => M[B] and you want to apply it to the A inside an M[A].
Map is NOT one of the defining properties of monads because
it’s technically just a special case of FlatMap.



NOTE: The curly braces after Class{} allow you
to use a multi-line expression for the parameter
that gets passed to the apply() method.  This
will become more important when using Scala
classes Try and Future.

FlatMap is defined as:  (M[A], A => M[B]) => M[B]

So FlatMap "lifts" an A inside an M, and takes a function
that "lifts" and converts an A to a B inside an M, and
then combines the two to get a B inside an M.  In other
words, we're defining a container type of M[A] that performs
an operation to produce and return an M[B].

FlatMap knows how to do two things:

1) It can apply a function to A.

2) It can flatten a nested container. When the function
   in question doesn’t lift A, the flattening is unnecessary,
   and we just need to apply the function.



Map is defined as:  M[A] => M[B]

Map is used when you have a function A => B, rather than
A => M[B] and you want to apply it to the A inside an M[A].
Map is NOT one of the defining properties of monads because
it’s technically just a special case of FlatMap.
