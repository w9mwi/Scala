There are three ways to create a data type in Scala...

1) object
2) class
3) trait

You might think that traits are like Java interfaces with concrete methods,
but they can actually do much more.  Traits can, for example, declare fields
and maintain state.  In fact, you can do anything in a trait definition that
you can do in a class definition, and the syntax looks exactly the same,
with only three (3) exceptions...

1) A trait cannot contain arguments/parameters like a class can.
   For example, you can define a class like below, which contains
   the arguments/parameters x and y...
   class Point(x: Int, y: Int) // Will compile

   However, the following attempt to define a trait would
   NOT compile because it contains arguments/parameters...
   trait NoPoint(x: Int, y: Int) // Won't compile

2) Another difference between a class and a trait is this...
   A call to super() IN A CLASS is statically bound.
   A call to super() IN A TRAIT is dynamically bound.

3) A class can inherit from (extend) only one class, but a class can
   inherit from multiple traits.  If a class inherits from only
   traits (and not another class), the FIRST trait a class inherits
   from is preceeded by the "extends" keyword.  All subsequent traits
   inherited by a class are preceded with the "with" keyword, as
   is shown in some sample code below.  If a class inherits from
   another class, and also inherits from traits, the inherited class
   must appear directly after the "extends" keyword, and all inherited
   traits must appear directly after the "with" keyword.
   
A class does NOT allow multiple inheritance.
A trait DOES allow multiple inheritance, but a trait can inherit
ONLY from other traits, and NEVER from a class.


IMPORTANT: A trait is very similar to an abstract class in many ways.
           When a class extends a trait that has an abstract method
           (a method that's declared, but not defined), each abstract
           method contained in the trait must be defined in the
           in the class that extends the trait!!!  Here's an example:

           trait Pet
           {
              def speak() { println("Yo") } // The method speak() is DEFINED, which means it's a concrete method.
              def comeToMaster(): Unit      // comeToMaster() is UNDEFINED, which means it's an abstract method.
           }
           class Dog(name: String) extends Pet
           {
             // Because Dog extends the trait Pet, and the Pet.comeToMaster()
             // method is abstract (meaning it's not defined in the trait),
             // the comeToMaster() method MUST be defined in the Dog class...
             def comeToMaster(): Unit = { println("Woo-hoo, I'm coming!") }
           }

           A class that extends a trait can override a trait's defined method
           by redefining the trait's method inside the class, like this:

           class Cat extends Pet
           {
             // The following speak() method overrides the trait's speak() method
             // defined in the above example...
             override def speak(): Unit = { println("meow") }
             def comeToMaster(): Unit   = { println("That's not gonna happen.") }
           }

If you write "super.toString" in a class, you know exactly which method
implementation will be invoked.  However, when you define a trait, the
method implementation to invoke for super() is undefined.  The implementation
to invoke will be determined anew each time the trait is mixed into a concrete
class, making it dynamically bound.

IMPORTANT: WHEN A CLASS INHERITS FROM MULTIPLE TRAITS, BEHAVIOR
           FROM ONLY ONE SINGLE TRAIT WILL BE IMPLEMENTED.

A trait can inherit ONLY from other traits.  A trait can NOT inherit from a class.
A trait can inherit from zero, one, or multiple traits.
EXAMPLE:
class MyClassA { ... }
trait MyTraitA { ... }
trait MyTraitB { ... }
trait MyTraitC { ... }
trait MyTraitD extends MyTraitA with MyTraitB with MyTraitC { ... }

A class can inherit from only one class, and/or from multiple traits.
EXAMPLE:
class MyClassB extends MyClassA with MyTraitA with MyTraitB with MyTraitC { ... }
...OR...
class MyClassB extends MyTraitA with MyTraitB with MyTraitC { ... }


QUESTION: When coding an abstract type that will be used with inheritance, should
          a trait be used, or an abstract class?

ANSWER: The rule of thumb is to use a trait because it allows the flexibility
        of multiple inheritance.  While a trait cannot take arguments (as can
        an abstract class), any values that you'd want to provide as arguments
        can be put into a trait and left undefined, so the class that implements
        the trait will have to provide those values.
        
METHOD RESOLUTION (LINEARIZATION) - Page 466
============================================
When you use inheritance, it's possible to create types for which there are
multiple different method implementations.  In other words, when using
inheritence, the class/object/trait you're using may have access to multiple
different implementations of a method with the same signature.  For example,
assume we have a class named Class_A, like this...

Class_A extends Class_B with Trait_A with Trait_B
{
   // Class_A definitions are made here...
}

Assume we have a method with this name and signature:
method_A(Int)

If method_A(Int) IS defined in Class_A, that's the method that'll get
called on Class_A, regardless if that same method signature exists in
Class_B, Trait_A, Trait_B, or in some supertype of Class_B, Trait_A, Trait_B.

If method_A(Int) is NOT defined in Class_A, Scala then looks for
method_A(Int) in LAST type in the "extends/with" list, which is Trait_B.
If method_A(Int) IS defined in Trait_B (or its supertypes), that's the
one that'll get called.  If method_A(Int) is NOT defined in Trait_B,
Scala will look for it in Trait_A (or its supertypes).  If method_A(Int)
is NOT found in Trait_A (or its supertypes), Scala will look for it in
Class_B and then its supertypes.

Whenever Scala looks for a method in a supertype, it always begins
with the LAST supertype in the "extends/with" list, moving from right
to left.  This process is called LINEARIZATION.

INHERITING FROM FUNCTION TYPES - Page 467
=========================================
When you treat an object like a function and pass it value arguments,
Scala expands that to call the apply() method on that object.  But for
the type to really be a function type that can be used in places that
expect functions (like calls to map(), filter(), foreach(), etc.) your
type must actually be a subtype of the function type.  To understand
this, run the following Scala code and read the in-line comments...

object Demo
{
  class MultiplyByTwo() extends (Int => Int)
  {
    def apply(i:Int) = 2*i
  }

  def main(args: Array[String])
  {
    val myList = List(1,2,3)
    val multiplyByTwo = new MultiplyByTwo()

    // The following 2 println() statements WORK WITH OR WITHOUT the "extends (Int => Int)"
    // text in the above "class MultiplyByTwo()" declaration.
    println("multiplyByTwo.apply(5) = " + multiplyByTwo.apply(5)) // PRINTS: multiplyByTwo.apply(5) = 10
    println("multiplyByTwo(5) = " + multiplyByTwo(5))             // PRINTS: multiplyByTwo(5) = 10

    // The following println() will NOT compile if you comment out the "extends (Int => Int)"
    // text in the above "class MultiplyByTwo()" declaration.
    println("myList.map(multiplyByTwo) = " + myList.map(multiplyByTwo)) // PRINTS: myList.map(multiplyByTwo) = List(2, 4, 6)
  }
}

===========================================================================
object Demo
{
  // THIS CODE DEMONSTRATES HOW TO USE A SCALA TRAIT
  trait Iterator[A]
  {
    def hasNext: Boolean // NOTE: The hasNext value is implemented in the below class that extends this trait.
    def next(): A        // NOTE: The next() method is implemented in the below class that extends this trait.
  }

  class IntIterator(to: Int) extends Iterator[Int]
  {
    private var current:Int = 0
    override def hasNext:Boolean = { current < to }
    override def next():Int =
    {
      if (hasNext)
      {
        val total:Int = current
        current += 1
        total
      }
      else { 0 } // Once the Iterator is "spent", this "else" statement (which returns zero) always executes.
    }
  }

  /**
    * @param args Arguments passed from the command line.
    */
  def main(args: Array[String])
  {
    val iterator:IntIterator = new IntIterator(10) // iterator is initialized to perform 10 iterations.

    // The 13 print statements below collectively print the following:
    // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 0, 0
    print(iterator.next() + ", ") // PRINTS: 0
    print(iterator.next() + ", ") // PRINTS: 1
    print(iterator.next() + ", ") // PRINTS: 2
    print(iterator.next() + ", ") // PRINTS: 3
    print(iterator.next() + ", ") // PRINTS: 4
    print(iterator.next() + ", ") // PRINTS: 5
    print(iterator.next() + ", ") // PRINTS: 6
    print(iterator.next() + ", ") // PRINTS: 7
    print(iterator.next() + ", ") // PRINTS: 8
    print(iterator.next() + ", ") // PRINTS: 9
    print(iterator.next() + ", ") // PRINTS: 0 // next() returns 0 cuz the Iterator is spent.
    print(iterator.next() + ", ") // PRINTS: 0 // next() returns 0 cuz the Iterator is spent.
    println(iterator.next())      // PRINTS: 0 // next() returns 0 cuz the Iterator is spent.
  }
}

===========================================================================
Here's another sample program showing how to use Scala traits...

object Demo
{
  trait Drawable
  {
    def draw() { }
  }

  trait Cowboy extends Drawable
  {
    override def draw() = { println("BANG!  The Cowboy drew a gun.") }
  }

  trait Artist extends Drawable
  {
    override def draw() = { println("PICTURE!  The Artist drew a painting.") }
  }

  // NOTE: The "with" keyword goes between type names for multiple inheritance.
  //       You can chain on multiple "with X" clauses to mix-in more traits.  If
  //       a class is to be part of the extended type, the class must be specified
  //       BEFORE the first "with X" clause.  READ ALL IN-LINE COMMENTS BELOW...
  class ArtistCowboy extends Artist with Cowboy // Inherits from trait Artist and trait Cowboy.  (Multiple inheritance.)
  class CowboyArtist extends Cowboy with Artist // Inherits from trait Cowboy and trait Artist.  (Multiple inheritance.)

  def main(args: Array[String])
  {
    val artCow = new ArtistCowboy()
    val cowArt = new CowboyArtist()

    // The artCow and cowArt classes both implement multiple inheritance.  So how does Scala know
    // which draw() method to use, the Cowboy.draw() method, or the Artist.draw() method???
    // The answer is the draw() method contained in the LAST class/trait appearing AFTER
    // the "extends" keyword.  So artCow.draw() calls the Cowboy.draw() method, and cowArt.draw()
    // calls the Artist.draw() method...
    artCow.draw() // PRINTS:  BANG!  The Cowboy drew a gun.
    cowArt.draw() // PRINTS:  PICTURE!  The Artist drew a painting.
  }
}

=======================================================================================
Rich Interface - A rich interface has many methods, which makes it convenient to use
                 because the caller is likely to find a method that exactly matches the
                 functionality she needs.

Thin Interface - A thin interface has fewer methods than a rich interface, so it's easier
                 for the programmer to write a thin interface than a rich interface.
                 However, the programmer who uses a thin interface will likely require
                 her to write more code because the thin interface supplies fewer methods
                 than the rich interface.

Traits can be used to enrich a thin interface, transforming it into a rich interface,
as is shown in the following example...

Look at the Point, Rectangle, and Component classes defined here.  Continue reading below.

class Point(val x: Int, val y: Int)
class Rectangle(val topLeft: Point, val bottomRight: Point)
{
  def left = topLeft.x
  def right = bottomRight.x
  def width = right - left
  // Assume more methods belong to this Rectangle class.
}
abstract class Component
{
  def topLeft: Point
  def bottomRight: Point

  def left = topLeft.x
  def right = bottomRight.x
  def width = right - left
  // Assume more methods belong to this abstract class Component.
}

Notice the left, right, and width methods defined above in the Rectangle class
are identical to the ones defined above in the abstract class Component.
These 3 methods will also likely reside in any other classes representing
rectangular objects.

This repetition can be eliminated with an enrichment trait shown immediately
below that's named Rectangular.  This Rectangular trait has two abstract
methods: one that returns the top-left coordinate of the object, and another
that returns the bottom-right coordinate.  It can then supply concrete
implementations of all the other geometric queries.

trait Rectangular
{
  def topLeft: Point
  def bottomRight: Point

  def left = topLeft.x
  def right = bottomRight.x
  def width = right - left
  // Assume more methods belong to this trait named Rectangular.
}

We can now redefine the above class Rectangle, and abstract class Component,
as follows.  This time, both classes are defined by extending the Rectangular
trait.  In other words, both these classes "mix-in" the Rectangular trait...

abstract class Component extends Rectangular
{
  // Assume more methods belong to this abstract class Component.
}
class Rectangle(val topLeft: Point, val bottomRight: Point) extends Rectangular
{
  // Assume more methods belong to this Rectangle class.
}
=======================================================================================
For more info on Scala Traits SEE P.463 of book, or the following web pages:
https://www.artima.com/pins1ed/traits.html
http://docs.scala-lang.org/tour/traits.html

