There are three ways to create a data type in Scala...

1) object
2) class
3) trait

You might think that traits are like Java interfaces with concrete methods,
but they can actually do much more.  Traits can, for example, declare fields
and maintain state.  You can do anything in a trait definition that you can
do in a class definition (and the syntax looks exactly the same), with these
three (3) exceptions...

1) A trait cannot contain arguments/parameters like a class can.
   For example, you can define a class like below, which contains
   the arguments/parameters x and y...
   class Point(x: Int, y: Int) // Will compile

   But the following attempt to define a trait will NOT
   compile because it contains arguments/parameters...
   trait Point(x: Int, y: Int) // Won't compile

2) Another difference between a class and a trait is this...

   A call to super() IN A CLASS is STATICALLY BOUND, which means when
   the super() method is invoked, the same method always gets called.

   A call to super() IN A TRAIT is DYNAMICALLY BOUND, which means when
   the super() method is invoked, the method that gets called can change,
   because it's determined at runtime.

3) A class can extend no more than one class.  A class can also
   extend zero, one, or multiple traits.

   A trait can extend zero, one, or multiple traits.
   A trait can NEVER extend (inherit from) a class.
   
   Below are examples of the syntax used for declaring
   classes and traits which extend other classes/traits.

   // A CLASS that extends one class, and multiple traits is defined like this...
   class Class_1 extends Class_2 with Trait_A with Trait_B { ... }

   // A CLASS that extends no class and multiple traits is defined like this...
   class Class_1 extends Trait_A with Trait_B { ... }

   // A TRAIT that extends multiple traits is defined like this...
   trait Trait_E extends Trait_D with Trait_C with Trait_B with Trait_A { ... }


IMPORTANT: A trait is very similar to an abstract class in many ways.
           When a class extends a trait that has an abstract method
           (a method that's declared, but not defined), each abstract
           method contained in the trait must be defined in the
           in the class that extends the trait!!!  Here's an example:

           trait Pet
           {
              def speak() { println("Bow-Wow") } // speak() is DEFINED, which means it's a CONCRETE method.
              def comeToMaster(): Unit           // comeToMaster() is UNDEFINED, which means it's an ABSTRACT  method.
           }
           class Dog(name: String) extends Pet
           {
             // Because Dog extends the trait Pet, and Pet contains an ABSTRACT method,
             // the ABSTRACT method comeToMaster() MUST be defined in this Dog class...
             def comeToMaster(): Unit = { println("Woo-hoo, I'm coming!") }
           }

           A class that extends a trait can override a trait's defined method
           by redefining the trait's method inside the class, like this:

           class Cat extends Pet
           {
             // The following speak() method overrides the trait's speak() method
             // defined in the above example...
             override def speak(): Unit = { println("Meow") }
             def comeToMaster(): Unit   = { println("That's not gonna happen.") }
           }

If you write "super.toString" in a class, you know exactly which method
implementation will be invoked.  However, when you define a trait, the
method implementation to invoke for super() is undefined.  The implementation
to invoke will be determined anew each time the trait is mixed into a concrete
class, making it DYNAMICALLY BOUND.

IMPORTANT: WHEN A CLASS INHERITS FROM MULTIPLE TRAITS, BEHAVIOR
           FROM ONLY ONE SINGLE TRAIT WILL BE IMPLEMENTED!

QUESTION: When coding an abstract type that will be used with inheritance,
          should a trait be used, or an abstract class?

ANSWER: The rule of thumb is to use a trait because it allows the flexibility
        of multiple inheritance.  While a trait cannot take arguments (as can
        an abstract class), any values that you'd want to provide as arguments
        can be put into a trait and left undefined, so the class that implements
        the trait will have to provide those values.


METHOD RESOLUTION (LINEARIZATION) - Page 466
============================================
Assume we have the following class definition...

Class_A extends Class_B with Trait_A with Trait_B
{
   // Class_A definitions are made here...
}

Also assume that we have defined this function in one or more
of the classes/traits implemented by Class_A:  func_A(Int):Unit

Assume we call func_A(Int) on Class_A.  Which func_A(Int) implementation
will get called?  Here is the order how that is determined...

1) If func_A(Int) IS DEFINED in Class_A, that's the one that'll get called
   on Class_A, regardless if that same function signature exists in Class_B,
   Trait_A, Trait_B, or in some supertype of Class_B, Trait_A, Trait_B.

2) If func_A(Int) is NOT defined in Class_A, Scala then looks for
   func_A(Int) IN THE FOLLOWING ORDER, and will execute the first
   one it finds...

3) If Trait_B contains func_A(Int) in one of its supertypes, the highest
   Trait_B supertype implementing func_A(Int) will get executed.  If
   func_A(Int) can't be found in any Trait_B supertype, but Trait_B
   implements func_A(Int), Trait_B.func_A(Int) gets executed.

4) If func_A(Int) is NOT defined in Trait_B or its supertypes, Scala then
   looks for (and will execute) the highest supertype implementing func_A(Int)
   on Trait_A.  If func_A(Int) can't be found in any Trait_A supertype, but
   Trait_A does implement func_A(Int), Trait_A.func_A(Int) gets executed.

5) If func_A(Int) is NOT defined in Trait_A or its supertypes, Scala then
   looks for (and will execute) func_A(Int) in the highest supertype of
   Class_B.  If func_A(Int) can't be found in any Class_B supertype, but
   Class_B does implement func_A(Int), Class_B.func_A(Int) gets executed.
   
Whenever Scala looks for a method in a supertype, it always begins with
the supertype of the RIGHT-MOST member in the "extends/with" list.  This
process is called LINEARIZATION.  To make this more clear, let's use the
the following Video class declaration to show how a method located in one
of its traits would be found...

class Video extends Trait_A with Trait_B with Trait_C
{ } // Empty class.

Assume a method named playVideo() was declared in Trait_A,
or Trait_B, or Trait_C.  When that playVideo() method is called
on this Video class, Scala looks for the playVideo() method
in this order...

1) In a superclass of Trait_C.
2) In a superclass of Trait_B.
3) In a superclass of Trait_A.
4) In Trait_C.
5) In Trait_B.
6) In Trait_A.

The first playVideo() method found in this search order
is the one that will get called.

You can see an example of this in the following sample code, where
the call to myClass_3.method_A() calls the method_A() located in
Trait_B (which extends Trait_A), instead of calling method_A() located
in Trait_A, as you might expect to happen.  This result occurs because
Scala FIRST searches for the method in the superclass of every trait,
and then searches for the method in each trait.  NOTE: If you COMMENT
OUT this line in the code sample shown below and then run the program...

// override def method_A() = { println("Trait_B.method_A() is called.") }

This line will get printed for Class_3:            Trait_A.method_A() is called.
Instead of this line getting printed for Class_3:  Trait_B.method_A() is called.

Inspect and run the following program to understand how it's determined
which method gets called from which corresponding trait.
==========================================================================================
object Demo
{
  trait Trait_A
  {
    def func_A() = { println("Trait_A.func_A() is called.") }
  }
  trait Trait_B extends Trait_A
  {
    // Trait_B extends Trait_A, and Trait_A implements func_A().  Therefore,
    // the func_A() declared here in Trait_B must contain the 'override' keyword
    // or it won't compile.
    override def func_A() = { println("Trait_B.func_A() is called.") }
    def func_B()          = { println("Trait_B.func_B() is called.") }
  }
  trait Trait_C extends Trait_B
  {
    def func_C() = { println("Trait_C.func_C() is called.") }
  }

  // NOTICE the extends/with order in the Class_1 declaration below.
  class Class_1 extends Trait_A with Trait_B with Trait_C  {  } // Empty class.

  // NOTICE the extends/with order in the Class_2 declaration below.
  class Class_2 extends Trait_A with Trait_B  {  } // Empty class.

  // NOTICE the extends/with order in Class_3 declaration below.
  class Class_3 extends Trait_C with Trait_B with Trait_A  {  } // Empty class.

  // NOTICE the extends/with order in Class_4 declaration below.
  class Class_4 extends Trait_C with Trait_B  {  } // Empty class.


  def main(args: Array[String]):Unit =
  {
    println("=============================")
    val myClass_1:Class_1 = new Class_1()
    println("Class_1...")
    myClass_1.func_A()  // PRINTS: Trait_B.func_A() is called.
    myClass_1.func_B()  // PRINTS: Trait_B.func_B() is called.
    myClass_1.func_C()  // PRINTS: Trait_C.func_C() is called.
    println("=============================")
    val myClass_2:Class_2 = new Class_2()
    println("Class_2...")
    myClass_2.func_A()  // PRINTS: Trait_B.func_A() is called.
    myClass_2.func_B()  // PRINTS: Trait_B.func_B() is called.
    println("=============================")
    val myClass_3:Class_3 = new Class_3()
    println("Class_3...")
    myClass_3.func_A()  // PRINTS: Trait_B.func_A() is called.
    myClass_3.func_B()  // PRINTS: Trait_B.func_B() is called.
    myClass_3.func_C()  // PRINTS: Trait_C.func_C() is called.
    println("=============================")
    val myClass_4:Class_4 = new Class_4()
    println("Class_4...")
    myClass_4.func_A()  // PRINTS: Trait_B.func_A() is called.
    myClass_4.func_B()  // PRINTS: Trait_B.func_B() is called.
    myClass_4.func_C()  // PRINTS: Trait_C.func_C() is called.
  }
}

==========================================================================================

INHERITING FROM FUNCTION TYPES - Page 467
=========================================
When you treat an object like a function and pass it value arguments,
Scala expands that to call the apply() method on that object.  But for
the type to really be a function type that can be used in places that
expect functions (like calls to map(), filter(), foreach(), etc.) your
type must actually be a subtype of the function type.  To understand
this, run the following Scala code and read the in-line comments...

object Demo
{
  class MultiplyByTwo() extends (Int => Int)
  {
    def apply(i:Int) = 2*i
  }

  def main(args: Array[String])
  {
    val myList = List(1,2,3)
    val multiplyByTwo = new MultiplyByTwo()

    // The following 2 println() statements WORK WITH OR WITHOUT the "extends (Int => Int)"
    // text in the above "class MultiplyByTwo()" declaration.
    println("multiplyByTwo.apply(5) = " + multiplyByTwo.apply(5)) // PRINTS: multiplyByTwo.apply(5) = 10
    println("multiplyByTwo(5) = " + multiplyByTwo(5))             // PRINTS: multiplyByTwo(5) = 10

    // The following println() will NOT compile if you comment out the "extends (Int => Int)"
    // text in the above "class MultiplyByTwo()" declaration.
    println("myList.map(multiplyByTwo) = " + myList.map(multiplyByTwo)) // PRINTS: myList.map(multiplyByTwo) = List(2, 4, 6)
  }
}

===========================================================================
object Demo
{
  // THIS CODE DEMONSTRATES HOW TO USE A SCALA TRAIT
  trait Iterator[A]
  {
    // The following 2 functions (hasNext and next) are abstract because they're
    // only declared here, and NOT defined.  Any class/trait that inherits
    // from this trait will need to implement the behavior of these functions.
    def hasNext: Boolean // NOTE: The hasNext function is implemented in the below class that extends this trait.
    def next(): A        // NOTE: The next() function is implemented in the below class that extends this trait.
  }

  class IntIterator(to: Int) extends Iterator[Int]
  {
    private var current:Int = 0
    override def hasNext:Boolean = { current < to }
    override def next():Int =
    {
      if (hasNext)
      {
        val total:Int = current
        current += 1
        total
      }
      else { 0 } // Once the Iterator is "spent", this "else" statement (which returns zero) always executes.
    }
  }

  /**
    * @param args Arguments passed from the command line.
    */
  def main(args: Array[String])
  {
    val iterator:IntIterator = new IntIterator(10) // iterator is initialized to perform 10 iterations.

    // The 13 print statements below collectively print the following:
    // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 0, 0
    print(iterator.next() + ", ") // PRINTS: 0
    print(iterator.next() + ", ") // PRINTS: 1
    print(iterator.next() + ", ") // PRINTS: 2
    print(iterator.next() + ", ") // PRINTS: 3
    print(iterator.next() + ", ") // PRINTS: 4
    print(iterator.next() + ", ") // PRINTS: 5
    print(iterator.next() + ", ") // PRINTS: 6
    print(iterator.next() + ", ") // PRINTS: 7
    print(iterator.next() + ", ") // PRINTS: 8
    print(iterator.next() + ", ") // PRINTS: 9
    print(iterator.next() + ", ") // PRINTS: 0 // next() returns 0 cuz the Iterator is spent.
    print(iterator.next() + ", ") // PRINTS: 0 // next() returns 0 cuz the Iterator is spent.
    println(iterator.next())      // PRINTS: 0 // next() returns 0 cuz the Iterator is spent.
  }
}

===========================================================================
Here's another sample program showing how to use Scala traits...

object Demo
{
  trait Drawable
  {
    def draw() { }
  }

  trait Cowboy extends Drawable
  {
    override def draw() = { println("BANG!  The Cowboy drew a gun.") }
  }

  trait Artist extends Drawable
  {
    override def draw() = { println("PICTURE!  The Artist drew a painting.") }
  }

  // NOTE: The "with" keyword goes between type names for multiple inheritance.
  //       You can chain on multiple "with X" clauses to mix-in more traits.  If
  //       a class is to be part of the extended type, the class must be specified
  //       BEFORE the first "with X" clause.  READ ALL IN-LINE COMMENTS BELOW...
  class ArtistCowboy extends Artist with Cowboy // Inherits from trait Artist and trait Cowboy.  (Multiple inheritance.)
  class CowboyArtist extends Cowboy with Artist // Inherits from trait Cowboy and trait Artist.  (Multiple inheritance.)

  def main(args: Array[String])
  {
    val artCow = new ArtistCowboy()
    val cowArt = new CowboyArtist()

    // The artCow and cowArt classes both implement multiple inheritance.  So how does Scala know
    // which draw() method to use, the Cowboy.draw() method, or the Artist.draw() method???
    // The answer is the draw() method contained in the LAST class/trait appearing AFTER
    // the "extends" keyword.  So artCow.draw() calls the Cowboy.draw() method, and cowArt.draw()
    // calls the Artist.draw() method...
    artCow.draw() // PRINTS:  BANG!  The Cowboy drew a gun.
    cowArt.draw() // PRINTS:  PICTURE!  The Artist drew a painting.
  }
}

=======================================================================================
Rich Interface - A rich interface has many methods, which makes it convenient to use
                 because the caller is likely to find a method that exactly matches the
                 functionality she needs.

Thin Interface - A thin interface has fewer methods than a rich interface, so it's easier
                 for the programmer to write a thin interface than a rich interface.
                 However, the programmer who uses a thin interface will likely require
                 her to write more code because the thin interface supplies fewer methods
                 than the rich interface.

Traits can be used to enrich a thin interface, transforming it into a rich interface,
as is shown in the following example...

Look at the Point, Rectangle, and Component classes defined here.  Continue reading below.

class Point(val x: Int, val y: Int)
class Rectangle(val topLeft: Point, val bottomRight: Point)
{
  def left = topLeft.x
  def right = bottomRight.x
  def width = right - left
  // Assume more methods belong to this Rectangle class.
}
abstract class Component
{
  def topLeft: Point
  def bottomRight: Point

  def left = topLeft.x
  def right = bottomRight.x
  def width = right - left
  // Assume more methods belong to this abstract class Component.
}

Notice the left, right, and width methods defined above in the Rectangle class
are identical to the ones defined above in the abstract class Component.
These 3 methods will also likely reside in any other classes representing
rectangular objects.

This repetition can be eliminated with an enrichment trait shown immediately
below that's named Rectangular.  This Rectangular trait has two abstract
methods: one that returns the top-left coordinate of the object, and another
that returns the bottom-right coordinate.  It can then supply concrete
implementations of all the other geometric queries.

trait Rectangular
{
  def topLeft: Point
  def bottomRight: Point

  def left = topLeft.x
  def right = bottomRight.x
  def width = right - left
  // Assume more methods belong to this trait named Rectangular.
}

We can now redefine the above class Rectangle, and abstract class Component,
as follows.  This time, both classes are defined by extending the Rectangular
trait.  In other words, both these classes "mix-in" the Rectangular trait...

abstract class Component extends Rectangular
{
  // Assume more methods belong to this abstract class Component.
}
class Rectangle(val topLeft: Point, val bottomRight: Point) extends Rectangular
{
  // Assume more methods belong to this Rectangle class.
}
=======================================================================================
For more info on Scala Traits SEE P.463 of book, or the following web pages:
https://www.artima.com/pins1ed/traits.html
http://docs.scala-lang.org/tour/traits.html

