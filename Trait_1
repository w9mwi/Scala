There are three ways to create a data type in Scala...

1) object
2) class
3) trait

You might think that traits are like Java interfaces with concrete methods,
but they can actually do much more.  Traits can, for example, declare fields
and maintain state.  In fact, you can do anything in a trait definition that
you can do in a class definition, and the syntax looks exactly the same,
with only two (2) exceptions...

1) A trait cannot contain parameters like a class can contain paramaters.
   In other words, although you can define a class like this:
   class Point(x: Int, y: Int)

   The following attempt to define a trait would NOT compile because
   it contains parameters:
   trait NoPoint(x: Int, y: Int) // Won't compile

2) Another difference between a classes and a trait is that a call
   to super() in a class is statically bound, but in traits a call
   to super() is dynamically bound.
   
IMPORTANT: When a class extends a trait that has an abstract method
           (a method that's declared, but not defined), each abstract
           method in contained in that trait must be defined in the
           in the class that extends the trait!!!  Here's an example:

           trait Pet
           {
              def speak { println("Yo") } // concrete implementation of a speak method
              def comeToMaster(): Unit    // abstract
           }
           class Dog(name: String) extends Pet
           {
             // Because Dog extends the trait Pet, and the Pet.comeToMaster()
             // method is abstract (meaning it's not defined in the trait),
             // the comeToMaster() method MUST be defined in the Dog class...
             def comeToMaster(): Unit = { println("Woo-hoo, I'm coming!") }
           }

           A class that extends a trait can override a trait's defined method
           by redefining the trait's method inside the class, like this:

           class Cat extends Pet
           {
             // The following speak() method overrides the trait's speak() method
             // defined in the above example...
             override def speak(): Unit = { println("meow") }
             def comeToMaster(): Unit   = { println("That's not gonna happen.") }
           }



If you write "super.toString" in a class, you know exactly which method
implementation will be invoked.  When you write the same thing in a trait,
however, the method implementation to invoke for the super call is undefined
when you define the trait. Rather, the implementation to invoke will be
determined anew each time the trait is mixed into a concrete class.

===================================================================

When you inherit from a trait, you use the "with" keyword, whereas
inheriting from a class you use the "extends" keyword.

A trait is similar to an abstract class in many ways.  The two primary differences are:

1) A trait CAN'T take arguments/parameters, as an abstract class CAN.
2) A class can be defined as inheriting from from multiple traits, but when the
   code is executed, BEHAVIOR FROM ONLY ONE SINGLE TRAIT WILL BE IMPLEMENTED.
   Because this is very important, we'll say it again...

IMPORTANT: WHEN A CLASS INHERITS FROM MULTIPLE TRAITS, BEHAVIOR
           FROM ONLY ONE SINGLE TRAIT WILL BE IMPLEMENTED.
   

A TRAIT CAN ONLY INHERIT FROM ANOTHER TRAIT.  A trait CAN'T inherit from a class.
For a trait to inherit from another trait, the "extends" keyword is used, just as
the "extends" keyword is used for a class to inherit from another class.

A class does NOT allow multiple inheritance.
A trait DOES allow multiple inheritance.

Scala will NOT allow a class to have multiple inheritance, so you CAN'T list
multiple classes after the extends keyword.  However, Scala allows a class to
use multiple traits, which is done using the "with" keyword.  Here's an example...

Assume you want to represent a Person, but there are multiple categories
of a Person...  Parent, Child, GeneralAdult, Father, Mother, Male, Female

Since a Father is a Person + Parent + Male, a Father class could NOT inherit
from Person + Parent + Male, because that would be inheriting from multiple
classes, which isn't allowed.  Here is how you could use traits to do this...

trait Person {...} // NOTE: Person is a trait!
trait Parent extends Person {...}
trait Male   extends Person {...}
class Father extends Parent with Male {...}

An alternative to constructing a Father class would be to use traits
as mix-in types, like this...

class Person {...}  // NOTE: Person is a class!
trait Parent {...}
trait Male {...}
class Father extends Person with Parent with Male {...}

In this example, Parent and Male are traits that do NOT inherit from the
Person.  Instead, they are MIXED IN with the Person to create Father.
This approach is perhaps a bit more advanced, and if the Parent and Male
types involve code that requires them to know they will be used with a Person,
you will need to use SELF-TYPES, which are discussed in Appendix B of the book.

QUESTION: Which should be used, a trait, or an abstract class?...

When coding an abstract type that will be used with inheritance, should
a trait be used, or an abstract class?...  The rule of thumb is to use
a trait because it allows the flexibility of multiple inheritance.  While
a trait cannot take arguments (as can an abstract class), any values that
you'd want to provide as arguments can be put into a trait and left
undefined, so the class that implements the trait will have to provide
those values.

===========================================================================
object Demo
{
  // THIS CODE DEMONSTRATES HOW TO USE A SCALA TRAIT
  trait Iterator[A]
  {
    def hasNext: Boolean // NOTE: The hasNext value is implemented in the below class that extends this trait.
    def next(): A        // NOTE: The next() method is implemented in the below class that extends this trait.
  }

  class IntIterator(to: Int) extends Iterator[Int]
  {
    private var current = 0
    override def hasNext: Boolean = { current < to }
    override def next(): Int =
    {
      if (hasNext)
      {
        val total = current
        current += 1
        total
      }
      else { 0 } // Once the Iterator is "spent", this "else" statement (which returns zero) always executes.
    }
  }

  /**
    * @param args Arguments passed from the command line.
    */
  def main(args: Array[String])
  {
    val iterator = new IntIterator(10)
    // The 13 print statements below collectively print the following:
    // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 0, 0
    print(iterator.next() + ", ") // PRINTS: 0
    print(iterator.next() + ", ") // PRINTS: 1
    print(iterator.next() + ", ") // PRINTS: 2
    print(iterator.next() + ", ") // PRINTS: 3
    print(iterator.next() + ", ") // PRINTS: 4
    print(iterator.next() + ", ") // PRINTS: 5
    print(iterator.next() + ", ") // PRINTS: 6
    print(iterator.next() + ", ") // PRINTS: 7
    print(iterator.next() + ", ") // PRINTS: 8
    print(iterator.next() + ", ") // PRINTS: 9
    print(iterator.next() + ", ") // PRINTS: 0
    print(iterator.next() + ", ") // PRINTS: 0
    println(iterator.next())      // PRINTS: 0
  }
}
===========================================================================
Here's some more sample code showing how to use Scala traits...

object Demo
{
  trait Drawable
  {
    def draw() { }
  }

  trait Cowboy extends Drawable
  {
    override def draw() { println("BANG!  The Cowboy drew a gun.") }
  }

  trait Artist extends Drawable
  {
    override def draw() { println("PICTURE!  The Artist drew a painting.") }
  }

  // NOTE: The "with" keyword goes between type names for multiple inheritance.
  //       You can chain on multiple "with X" clauses to mix in more traits.  If
  //       a class is to be part of the extended type, it must be specified BEFORE
  //       the first "with X" clause.  READ ALL IN-LINE COMMENTS BELOW...
  class ArtistCowboy extends Artist with Cowboy // Inherits from trait Artist and trait Cowboy.  (Multiple inheritance.)
  class CowboyArtist extends Cowboy with Artist // Inherits from trait Cowboy and trait Artist.  (Multiple inheritance.)

  def main(args: Array[String])
  {
    val artCow = new ArtistCowboy()
    val cowArt = new CowboyArtist()

    // The artCow and cowArt classes both implement multiple inheritance.  So how does Scala know
    // which draw() method to use, the Cowboy.draw() method, or the Artist.draw() method?
    // The answer is the draw() method contained in the LAST class/trait appearing AFTER
    // the "extends" keyword.  So artCow.draw() calls the Cowboy.draw() method, and cowArt.draw()
    // calls the Artist.draw() method...
    artCow.draw() // PRINTS:  BANG!  The Cowboy drew a gun.
    cowArt.draw() // PRINTS:  PICTURE!  The Artist drew a painting.
  }
}

=======================================================================================
Rich Interface - A rich interface has many methods, which makes it convenient to use
                 because the caller is likely to find a method that exactly matches the
                 functionality she needs.

Thin Interface - A thin interface has fewer methods than a rich interface, so it's easier
                 for the programmer to write a thin interface than a rich interface.
                 However, the programmer who uses a thin interface will likely require
                 her to write more code because the thin interface supplies fewer methods
                 than the rich interface.

Traits can be used to enrich a thin interface, transforming it into a rich interface,
as is shown in the following example...

Look at the Point, Rectangle, and Component classes defined here.  Continue reading below.

class Point(val x: Int, val y: Int)
class Rectangle(val topLeft: Point, val bottomRight: Point)
{
  def left = topLeft.x
  def right = bottomRight.x
  def width = right - left
  // Assume more methods belong to this Rectangle class.
}
abstract class Component
{
  def topLeft: Point
  def bottomRight: Point

  def left = topLeft.x
  def right = bottomRight.x
  def width = right - left
  // Assume more methods belong to this abstract class Component.
}

Notice the left, right, and width methods defined above in the Rectangle class
are identical to the ones defined above in the abstract class Component.
These 3 methods will also likely reside in any other classes representing
rectangular objects.

This repetition can be eliminated with an enrichment trait shown immediately
below that's named Rectangular.  This Rectangular trait has two abstract
methods: one that returns the top-left coordinate of the object, and another
that returns the bottom-right coordinate.  It can then supply concrete
implementations of all the other geometric queries.

trait Rectangular
{
  def topLeft: Point
  def bottomRight: Point

  def left = topLeft.x
  def right = bottomRight.x
  def width = right - left
  // Assume more methods belong to this trait named Rectangular.
}

We can now redefine the above class Rectangle, and abstract class Component,
as follows.  This time, both classes are defined by extending the Rectangular
trait.  In other words, both these classes "mix in" the Rectangular trait...

abstract class Component extends Rectangular
{
  // Assume more methods belong to this abstract class Component.
}
class Rectangle(val topLeft: Point, val bottomRight: Point) extends Rectangular
{
  // Assume more methods belong to this Rectangle class.
}
=======================================================================================
For more info on Scala Traits SEE P.463 of book, or the following web pages:
https://www.artima.com/pins1ed/traits.html
http://docs.scala-lang.org/tour/traits.html

