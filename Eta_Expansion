In Scala you can define a function in 2 different ways:

1) A function can be defined by using the 'def' keyword,
   which is the most common way functions are defined.

2) A function can also be defined upon the declaration of
   a val/var.  Typically, a val/var stores a value of some
   some data type (i.e., Int, String, List, etc.).  But a
   val/var can also store a function.

The compiled code of a function defined as a val/var is
different than the compiled code of a function defined
using the 'def' keyword, even when both of those functions
are defined to perform the identical operation, such as
multiplying an Int value by 2 and returning an Int result.

object Demo
{
  def main(args: Array[String])
  {
    // The doubleInt_1 function is defined using the "def" keyword...
    def doubleInt_1(number:Int):Int = number * 2
    // The doubleInt_2 function is defined as a val...
    val doubleInt_2:(Int => Int) = (number:Int) => number * 2

    // doubleInt_1() and doubleInt_2() are called in the same manner...
    var result:Int = doubleInt_1(33)
    println(s"result = $result") // PRINTS: result = 66
    result = doubleInt_2(44)
    println(s"result = $result") // PRINTS: result = 88

    // NOTICE:  If you assign doubleInt_1 function to a val/var the code WON'T COMPILE...
    //          var func = doubleInt_1  // WON'T COMPILE!
    //          But if you assign doubleInt_2 to a val/var the code will compile...
    var func = doubleInt_2
    result = func(11)
    println(s"result = $result") // PRINTS: result = 22

    // If you want to assign doubleInt_1 to the "var func" declared above,
    // you must perform an Eta Expansion on it by adding the underscore
    // character (_) to the line of code, like this...
    func = doubleInt_1 _  // Equivalent to the line below.
    func = doubleInt_1(_) // Equivalent to the line above.

    // You can now invoke the doubleInt_1 function via the func var, like this...
    result = func(15)
    println(s"result = $result") // PRINTS: result = 30
  }
}


======================================================================
In the above example, if we want to assign the defined tripleIntFunc()
to a val named tripleIntFunc_2, you'd probably try doing this:

val tripleIntFunc_2 = tripleIntFunc  // WON'T compile!

However, that line WON'T COMPILE because a function defined via the
'def' keyword CAN'T be assigned to a val/var in the manner shown
above.  This problem can be fixed by adding an underscore (_) char
AFTER the function name, like this:

val tripleIntFunc_2 = tripleIntFunc _  // WILL compile!

Adding the underscore char like this performs an Eta Expansion
on the tripleIntFunc so it's treated as a partially applied
function and can then be assigned to a val/var.  The code sample
below demonstrates this by implementing this line of code:

val tripleIntFunc_2 = tripleIntFunc _

Using the underscore (_) char eliminates the need to explicitly
declare the data type of tripleIntFunc_2.  If the code explicitly
declares the data type of tripleIntFunc_2 as shown in the following
line, then the underscore (_) char is NOT required, it's optional.

val tripleIntFunc_2:(Int => Int) = tripleIntFunc    // WILL compile!
val tripleIntFunc_2:(Int => Int) = tripleIntFunc _  // WILL compile!

======================================================================
To pass a List[String] data type to a function that accepts a VARIABLE
NUMBER of String arguments, use an Eta Expansion.  Read in-line
comments for details.

object Demo
{
  def main(args: Array[String])
  {
    var result:String = makeSentence("Today", "is", "another", "day")
    println(s"1) result = $result") // PRINTS: 1) result = Today is another day.

    val listOfWords:List[String] = List("Tomorrow", "is", "a", "different", "day")
    val myStringFunc:(Seq[String] => String) = makeSentence _  // The underscore represents an Eta Expansion.
    result = myStringFunc(listOfWords)
    println(s"2) result = $result") // PRINTS: 2) result = Tomorrow is a different day.
  }

  /**
   * Pass this function a variable number of String arguments.
   * A single string is returned with all word args separated
   * by a space character, and a period char appended to the end.
   */
  def makeSentence(word:String*):String = word.toSeq.mkString(" ") + "."
}

======================================================================
In the below sample code we perform an Eta expansion on the defined
add() function like this:

val addFunc = add _

Then we show how addFunc can be used to obtain a curried version
of the defined add() function, like this:

val curriedAddFunc = addFunc.curried

Read in-line comments in the below code for details.
======================================================================

object Demo
{
  def main(args: Array[String]): Unit =
  {
    val addFunc = add _  // Perform an Eta expansion so addFunc contains the add() function defined below.
    var result:Int = addFunc(1, 2, 3)
    println("result = " + result) // PRINTS: result = 6

    // Calling addFunc.curried returns a curried version of the add function defined below.
    val curriedAddFunc = addFunc.curried
    result = curriedAddFunc(1)(2)(3)
    println("result = " + result) // PRINTS: result = 6

    // Now call curriedAddFunc() as PARTIALLY APPLIED.
    val func1:(Int => (Int => Int)) = curriedAddFunc(1) // func1  = curriedAddFunc PARTIALLY APPLIED.
    val func2:(Int => Int)          = func1(2)          // func2  = func1 PARTIALLY APPLIED.
    result                          = func2(3)          // result = func2 FULLY APPLIED.
    println("result = " + result) // PRINTS: result = 6

    // func1 and func2 are currently partially applied.
    // Below, func1 and func2 get called so they become FULLY APPLIED.
    result = func1.apply(2).apply(3)
    println("result = " + result) // PRINTS: result = 6
    result = func2.apply(3)
    println("result = " + result) // PRINTS: result = 6

    // The following line shows that the addFunc.isInstanceOf call returns true.
    val tom = addFunc.isInstanceOf[Function3[_, _, _, _]]
    println("tom = " + tom) // PRINTS: tom = true
  }

  def add(x:Int, y:Int, z:Int):Int = x + y + z
}

======================================================================
In this code sample an Eta Expansion is performed on the defined
tripleIntFunc function.

object Demo
{
  def main(args: Array[String]): Unit = {
    val numbers:List[Int] = List(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
    println(numbers) // PRINTS: List(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10)

    // Define a val to store a function...
    val doubleIntFunc:(Int => Int) = (number:Int) => number * 2

    // Pass the function stored in the doubleIntFunc val to the List.map() function...
    var result:List[Int] = numbers.map(doubleIntFunc)
    println(result) // PRINTS: List(0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20)

    // Pass the tripleIntFunc function (defined near the bottom
    // of this program) to the List.map() function...
    result = numbers.map(tripleIntFunc)
    println(result) // PRINTS: List(0, 3, 6, 9, 12, 15, 18, 21, 24, 27, 30)

    // Here we want to assign the tripleIntFunc (defined near the bottom of this program)
    // to a val.  That can't be done (code won't compile) unless an underscore (_) char
    // is added AFTER tripleIntFunc, as shown in the following line of code.
    val tripleIntFunc_2 = tripleIntFunc _
    result = numbers.map(tripleIntFunc_2)
    println(result) // PRINTS: List(0, 3, 6, 9, 12, 15, 18, 21, 24, 27, 30)

    // You do NOT need to add the underscore (_) char when the data type of
    // the val/var is explicitly declared.  In this example the data type
    // (Int => Int) declaration is specified; therefore, the underscore (_)
    // char is NOT required, it's optional.
    val tripleIntFunc_3:(Int => Int) = tripleIntFunc
    result = numbers.map(tripleIntFunc_3)
    println(result) // PRINTS: List(0, 3, 6, 9, 12, 15, 18, 21, 24, 27, 30)
  }

  def tripleIntFunc(number:Int):Int = number * 3
}

======================================================================
This is another code sample of how to use an Eta Expansion.
Read in-line comments for details.

object Demo
{
  def main(args: Array[String]): Unit = {
    def doubleIntFunc(number:Int) = number * 2
    def tripleIntFunc(number:Int) = number * 3

    // The underscore (_) chars are REQUIRED in the declaration of the
    // val functions because its data type is NOT explicitly declared.
    // In the declaration further below the data type of val functions_2
    // is specified, so the underscore (_) chars are not required.
    val functions = Map("2x" -> doubleIntFunc _,
                        "3x" -> tripleIntFunc _)

    var result:Int = functions("2x").apply(444)
    println("1) " + result) // PRINTS: 1) 888
    // An equivalent way of doing what's done in the 2 lines above...
    var func:(Int => Int) = functions("2x")
    println("2) " + func(444)) // PRINTS: 2) 888

    result = functions("3x").apply(222)
    println("3) " + result) // PRINTS: 3) 666
    // An equivalent way of doing what's done in the 2 lines above...
    func = functions("3x")
    println("4) " + func(222)) // PRINTS: 4) 666

    // The following val functions_2 declaration is identical to the above
    // val functions declaration EXCEPT the underscore (_) chars are NOT
    // required (but could still be included) because the data type
    // of val functions_2 is explicitly declared...
    val functions_2:Map[String, Int => Int] = Map("2x" -> doubleIntFunc,
                                                  "3x" -> tripleIntFunc)
    result = functions_2("2x").apply(444)
    println("5) " + result) // PRINTS: 5) 888
    result = functions_2("3x").apply(222)
    println("6) " + result) // PRINTS: 6) 888
  }
}

======================================================================

Read in-line comments in the following code sample to see an example
of a Nullary Function, as well as the difference between a Scala
method and a Scala function.  A Scala method can be transformed into
a Scala function by performing an Eta Expansion on it.

object Demo
{
  /****************************************************************
   * This is a METHOD named square_method.  It takes an Int
   * parameter, and returns an Int value.
   ***************************************************************/
  def square_method(x:Int):Int = x * x

  /****************************************************************
   * This is a FUNCTION named square_function.  A FUNCTION does
   * NOT take a parameter!!!  A function (as opposed to a method)
   * RETURNS A FUNCTION
   *
   * A FUNCTION (as opposed to a method) is sometimes called a
   * NULLARY FUNCTION because its definition (as shown below)
   * DOESN'T contain an argument/parameter.  Its definition
   * contains only its return type, which is a function (i.e.,
   * Int => Int), and the block of code it returns (i.e.,
   * x => x * x).
   ***************************************************************/
  def square_function:(Int => Int) = { x => x * x }

  /*********************************************************
   *
   ********************************************************/
  def main(args:Array[String]): Unit =
  {
    println("square_method(2) = " + square_method(2))     // PRINTS: square_method(2) = 4
    println("square_function(2) = " + square_function(2)) // PRINTS: square_function(2) = 4

    val method:(Int => Int) = square_method
    println("method(2) = " + method(2)) // PRINTS: method(2) = 4

    // In the code below we perform an Eta Expansion on square_method,
    // which returns a FUNCTION (not a method) that's EQUIVALENT to
    // square_function defined above.
    val function:(Int => Int) = square_method _ // Performs an Eta Expansion on square_method
    println("function(2) = " + function(2)) // PRINTS: function(2) = 4
  }
}
