In Scala you can define a function in 2 different ways:

1) A function can be defined as a val (or a var), so the val/var
   actually stores a function instead of storing a typical data
   value like an Int, String, List, etc.

2) A function can be defined by using the 'def' keyword,
   which is the most common way functions are defined.

The compiled code of a function defined as a val/var is
different than the compiled code of a function defined
using the 'def' keyword, even when both of those functions
are defined to perform the identical operation, such as
multiplying an Int value by two (2).

The following sample code defines a function using both ways,
where doubleIntFunc() is stored in a val, and tripleIntFunc()
is defined using the 'def' keyword.

======================================================================

object Demo
{
  def main(args: Array[String]): Unit = {
    val doubleIntFunc:(Int => Int) = (number:Int) => number * 2

    println(doubleIntFunc(222)) // PRINTS: 444
    println(tripleIntFunc(222)) // PRINTS: 666
  }
  def tripleIntFunc(number:Int):Int = number * 3
}

======================================================================
In the above example, if we want to assign the defined tripleIntFunc()
to a val named tripleIntFunc_2, you'd probably try doing this:

val tripleIntFunc_2 = tripleIntFunc  // WON'T compile!

However, that line WON'T COMPILE because a function defined via the
'def' keyword CAN'T be assigned to a val/var in the manner shown
above.  This problem can be fixed by adding an underscore (_) char
AFTER the function name, like this:

val tripleIntFunc_2 = tripleIntFunc _  // WILL Compile!

Adding the underscore char like this performs an "Eta Expansion"
on the tripleIntFunc so it's treated as a partially applied
function and can then be assigned to a val/var.  The following
code shows an example of doing that.

======================================================================
======================================================================

object Demo
{
  def main(args: Array[String]): Unit = {
    val doubleIntFunc:(Int => Int) = (number:Int) => number * 2

    println(doubleIntFunc(222)) // PRINTS: 444
    println(tripleIntFunc(222)) // PRINTS: 666

    val numbers:List[Int] = List(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10)

    var result = numbers.map(doubleIntFunc)
    println(result) // PRINTS: List(0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20)

    result = numbers.map(tripleIntFunc)
    println(result) // PRINTS: List(0, 3, 6, 9, 12, 15, 18, 21, 24, 27, 30)

    // In the following code, we want to assign the tripleIntFunc() defined
    // further below to a val (tripleIntFunc_2), and then pass that val to
    // the List.map() function, so map() will execute the function stored
    // in that val.  When you assign a function that has been defined
    // using the 'def' keyword to a val/var, IT WON'T COMPILE UNLESS AN
    // UNDERSCORE (_) CHAR IS APPENDED AFTER THE FUNCTION NAME, AS THE
    // FOLLOWING LINE SHOWS...
    val tripleIntFunc_2 = tripleIntFunc _ // The underscore (_) char IS REQUIRED.
    result = numbers.map(tripleIntFunc_2)
    println(result) // PRINTS: List(0, 3, 6, 9, 12, 15, 18, 21, 24, 27, 30)
  }
  def tripleIntFunc(number:Int):Int = number * 3
}

======================================================================



Read the in-line comments in the below sample code.  For more details
about "Eta Expansion", do a web search on it.
======================================================================
object Demo
{
  def main(args: Array[String])
  {
    val intList = List(7, 9)

    // When you write your own functions/methods (like mySquare() below),
    // you can convert them to functions which can be used by the map() method.
    // You do this by performing an "Eta Expansion" on the function, as shown
    // in the following line of code by adding the underscore character (_)
    // after the function name.  If you remove the underscore char after
    // the mySquare function name below, that line will NOT compile.  Using the
    // underscore (_) char eliminates the need to declare the squareFunction's
    // data type!!!  Keep reading all comments below...
    val squareFunction = mySquare _

    // When the squareFunction declaration is made above, the Scala compiler
    // translates that code into the following commented-out code, where the
    // "new Function1[Int, Int]" text shown below is optional...
    // val squareFunction:(Int => Int) = new Function1[Int, Int]
    // {
    //   def apply(x: Int):Int = mySquare(x)
    // }

    // If you replace the above squareFunction declaration with either
    // of the two commented-out declarations below, those declarations
    // will compile and function properly...
    // val squareFunction:(Int => Int) = mySquare
    // val squareFunction:(Int => Int) = mySquare _  // NOTE the underscore (_) char.

    var result:List[Int] = intList.map(squareFunction)
    println("result = " + result) // PRINTS: result = List(49, 81)

    // The following result is identical to the result obtained above...
    result = intList.map(i => i*i)
    println("result = " + result) // PRINTS: result = List(49, 81)
  }

  /****************************
  * The mySquare() function.
  ****************************/
  def mySquare(x:Int):Int = { x * x }
}
