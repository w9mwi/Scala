In Scala you can define a function in 2 different ways:

1) A function can be defined as a val (or a var), so the val/var
   actually stores a function instead of storing a typical data
   value like an Int, String, List, etc.

2) A function can be defined by using the 'def' keyword,
   which is the most common way functions are defined.

The compiled code of a function defined as a val/var is
different than the compiled code of a function defined
using the 'def' keyword, even when both of those functions
are defined to perform the identical operation, such as
multiplying an Int value by two (2).

The following sample code defines a function using both ways,
where doubleIntFunc() is stored in a val, and tripleIntFunc()
is defined using the 'def' keyword.

======================================================================

object Demo
{
  def main(args: Array[String]): Unit = {
    val doubleIntFunc:(Int => Int) = (number:Int) => number * 2

    println(doubleIntFunc(222)) // PRINTS: 444
    println(tripleIntFunc(222)) // PRINTS: 666
  }
  def tripleIntFunc(number:Int):Int = number * 3
}

======================================================================
In the above example, if we want to assign the defined tripleIntFunc()
to a val named tripleIntFunc_2, you'd probably try doing this:

val tripleIntFunc_2 = tripleIntFunc  // WON'T compile!

However, that line WON'T COMPILE because a function defined via the
'def' keyword CAN'T be assigned to a val/var in the manner shown
above.  This problem can be fixed by adding an underscore (_) char
AFTER the function name, like this:

val tripleIntFunc_2 = tripleIntFunc _  // WILL compile!

Adding the underscore char like this performs an "Eta Expansion"
on the tripleIntFunc so it's treated as a partially applied
function and can then be assigned to a val/var.  The code sample
below demonstrates this by implementing this line of code:

val tripleIntFunc_2 = tripleIntFunc _

Using the underscore (_) char eliminates the need to explicitly
declare the data type of tripleIntFunc_2.  If the code explicitly
declares the data type of tripleIntFunc_2, as shown in the following
line, then the underscore (_) char is NOT required.

val tripleIntFunc_2:(Int => Int) = tripleIntFunc  // WILL compile!

======================================================================

object Demo
{
  def main(args: Array[String]): Unit = {
    val numbers:List[Int] = List(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
    println(numbers) // PRINTS: List(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10)

    // Define a val to store a function...
    val doubleIntFunc:(Int => Int) = (number:Int) => number * 2

    // Pass the function stored in the doubleIntFunc val to the List.map() function...
    var result:List[Int] = numbers.map(doubleIntFunc)
    println(result) // PRINTS: List(0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20)

    // Pass the tripleIntFunc function (defined near the bottom
    // of this program) to the List.map() function...
    result = numbers.map(tripleIntFunc)
    println(result) // PRINTS: List(0, 3, 6, 9, 12, 15, 18, 21, 24, 27, 30)

    // Here we want to assign the tripleIntFunc (defined near the bottom of this program)
    // to a val.  That can't be done (code won't compile) unless an underscore (_) char
    // is added AFTER tripleIntFunc, as shown in the following line of code.
    val tripleIntFunc_2 = tripleIntFunc _
    result = numbers.map(tripleIntFunc_2)
    println(result) // PRINTS: List(0, 3, 6, 9, 12, 15, 18, 21, 24, 27, 30)

    // You do NOT need to add the underscore (_) char when the data type of
    // the val/var is explicitly declared.  In this example the data type
    // declaration is specified, which is: (Int => Int)
    val tripleIntFunc_3:(Int => Int) = tripleIntFunc
    result = numbers.map(tripleIntFunc_3)
    println(result) // PRINTS: List(0, 3, 6, 9, 12, 15, 18, 21, 24, 27, 30)
  }

  def tripleIntFunc(number:Int):Int = number * 3
}

======================================================================



======================================================================



Read the in-line comments in the below sample code.  For more details
about "Eta Expansion", do a web search on it.
======================================================================
object Demo
{
  def main(args: Array[String])
  {
    val intList = List(7, 9)

    // When you write your own functions/methods (like mySquare() below),
    // you can convert them to functions which can be used by the map() method.
    // You do this by performing an "Eta Expansion" on the function, as shown
    // in the following line of code by adding the underscore character (_)
    // after the function name.  If you remove the underscore char after
    // the mySquare function name below, that line will NOT compile.  Using the
    // underscore (_) char eliminates the need to declare the squareFunction's
    // data type!!!  Keep reading all comments below...
    val squareFunction = mySquare _

    // When the squareFunction declaration is made above, the Scala compiler
    // translates that code into the following commented-out code, where the
    // "new Function1[Int, Int]" text shown below is optional...
    // val squareFunction:(Int => Int) = new Function1[Int, Int]
    // {
    //   def apply(x: Int):Int = mySquare(x)
    // }

    // If you replace the above squareFunction declaration with either
    // of the two commented-out declarations below, those declarations
    // will compile and function properly...
    // val squareFunction:(Int => Int) = mySquare
    // val squareFunction:(Int => Int) = mySquare _  // NOTE the underscore (_) char.

    var result:List[Int] = intList.map(squareFunction)
    println("result = " + result) // PRINTS: result = List(49, 81)

    // The following result is identical to the result obtained above...
    result = intList.map(i => i*i)
    println("result = " + result) // PRINTS: result = List(49, 81)
  }

  /****************************
  * The mySquare() function.
  ****************************/
  def mySquare(x:Int):Int = { x * x }
}
