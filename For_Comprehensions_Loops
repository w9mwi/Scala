================================================================================
A Scala for comprehension can contain the following 3 expressions:
1) Generator.  Every for comprehension begins with a generator.  for compehensions
               can have multiple generators.  The left side of a generator can
               also be a pattern, such as in this example:
               def getTheSquirrel = for { (dog, cat, squirrel) <- getAnimals yield squirrel }
2) Definition.  A definition binds the pattern on the left to the value of the expression on the right.
3) Filter.      A filter drops all elements from the iteration for which the expression returns false.

Here is an example:
for
{
  p <- persons           // Generator  (Iterates over all elements contained in persons.)
  n = p.name             // Definition
  if (n startsWith "To") // Filter
} yield x                // The for comprehension result is stored in x.

A generator has this general form:   pattern <- expression
A definition has this general form:  pattern = expression
A filter has this general form:      if (expression)

The Scala compiler translates for comprehensions into a series of method calls
that may include map(), flatMap(), foreach(), and withFilter().  Just as for
comprehensions are compiled into those 4 functions, the opposite is also true.
If you write a class that implements those functions, that class can be used
inside a for comprehension.

HOW TO WRITE A DATA TYPE THAT CAN BE USED IN A FOR COMPREHENSION
================================================================
1) If a custom data type defines a foreach() method, it allows
   for loops (with single and multiple generators) like this:
   for (x <- intList) println(x)
2) If a custom data type defines ONLY map(), it can be used in
   for expressions consisting of a SINGLE generator.
3) If a custom data type defines BOTH flatMap() and map(),
   it allows for expressions using multiple generators.
4) If a custom data type defines withFilter(), it allows
   for expressions containing an if() statement (aka, a filter).

If you want your custom class to work well with a for expression,
it should generally implement the following methods having the
signatures shown below.

abstract class MyCustomClass[A]
{
  def map[B](func: A => B):                    MyCustomClass[B]
  def flatMap[B](func: A => MyCustomClass[B]): MyCustomClass[B]
  def withFilter(x: A => Boolean):             MyCustomClass[A]
  def foreach((x: A => Unit):                  Unit
}
The following code sample implements a Sequence class that has implemented
these four (4) methods.

================================================================================
import scala.collection.mutable.ArrayBuffer
object Demo
{
  case class Person(firstName:String, lastName:String)
  case class Sequence[A](initialElems: A*) // NOTE: The A* designates a variable number of args of data type A.
  {
    // NOTE: Every line of code within a class (i.e., this Sequence class) that is
    //       NOT a method gets executed when the class's constructor is called.
    //       Therefore, the following two lines of code get executed when this
    //       Sequence class's constructor is called.  You'd think that because
    //       elems is a val type, the second line below wouldn't compile because
    //       it's the second time elems is being assigned a value.  But that's not
    //       what's happening.  The first line below is only declaring that elems
    //       is an ArrayBuffer of type A.  The only time elems actually gets
    //       assigned a value is in the second line below.
    private val elems = ArrayBuffer[A]()
    elems ++= initialElems // This line of code is equivalent to this:  for { e <- initialElems } elems += e

    def foreach(block: A => Unit):Unit = { elems.foreach(block) }
    def map[B](func: A => B):Sequence[B] =
    {
      val myMap:ArrayBuffer[B] = elems.map(func)
      new Sequence(myMap: _*) // NOTE: _* makes Sequence() work with a variable number of arguments.
    }
    def withFilter(p: A => Boolean):Sequence[A] =
    {
      val tempArrayBuffer:ArrayBuffer[A] = elems.filter(p)
      Sequence(tempArrayBuffer: _*) // NOTE: _* makes Sequence() work with a variable number of arguments.
    }
    def flatMap[B](func: A => Sequence[B]): Sequence[B] =
    {
      val mapResult:Sequence[Sequence[B]] = map(func)
      flatten(mapResult) // This flatten() method is defined immediately below.
    }
    def flatten[B](seqOfSeq:Sequence[Sequence[B]]):Sequence[B] =
    {
      var arrayBuf:ArrayBuffer[B] = ArrayBuffer[B]()
      for (listB <- seqOfSeq)
      {
        for (e <- listB)
        {
          arrayBuf += e
        }
      }
      Sequence(arrayBuf: _*) // This converts the type ArrayBuffer[B] to type Sequence[B]
    }
  }

  def main(args:Array[String]): Unit =
  {
    // NOTE: The Sequence class can work with different types (i.e., String, Int, Person etc.) because
    //       it's defined as a parametric class, where the data type is determined at run time.
    val strings:Sequence[String] = Sequence("one", "two", "three")
    val numbers:Sequence[Int]    = Sequence(1, 2, 3, 4, 5)
    val names:Sequence[Person]   = Sequence(Person("Joe", "Blow"), Person("Jack", "Smack"), Person("Frank", "Crank"))

    // NOTE: The following 3 for() loops would cause compile errors if the foreach()
    //       and map() methods weren't defined in the above Sequence class.  The
    //       if() statement embedded within the 2nd for() loop below would cause
    //       a compile error if the withFilter() method wasn't defined in the
    //       above Sequence class.  To summarize...
    //       1) The generators shown below (i.e., "for (str < strings)") work cuz Sequence.foreach() is defined above.
    //       2) The below yield statements work because Sequence.map() is defined above.
    //       3) The below "if i > 2" statement works because Sequence.withFilter() is defined above.
    val strResult:Sequence[String]    = for (str <- strings)           yield str
    val intResult:Sequence[Int]       = for { i <- numbers; if i > 2 } yield i*2
    val personResult:Sequence[Person] = for (name <- names)            yield name

    for (str <- strResult) print(str + " ") // PRINTS: one two three
    println
    for (int <- intResult) print(int + " ") // PRINTS: 6 8 10
    println
    for (name <- personResult) print(name + " ") // PRINTS: Person(Joe,Blow) Person(Jack,Smack) Person(Frank,Crank)
    println

    // The following code REQUIRES the flatMap() method to be defined by the above case class named Sequence.
    val myFriends   = Sequence(Person("Jack", "Daniels"),    Person("Johnny", "Walker"), Person("Jim", "Beam"))
    val joesFriends = Sequence(Person("Joseph", "Schlitz"),  Person("George", "Jones"),  Person("Jim", "Beam"))

    // For a class to work with MULTIPLE for() loop generators (as shown here), that class
    // MUST implement a flatMap() method--as in the above-defined Sequence class.
    val mutualFriends = for
                        {
                          myFriend   <- myFriends   // This is a GENERATOR.
                          joesFriend <- joesFriends // This is another GENERATOR.
                          if (myFriend.firstName == joesFriend.firstName &&
                              myFriend.lastName  == joesFriend.lastName)
                        } yield myFriend
    println("mutualFriends = " + mutualFriends) // PRINTS: mutualFriends = Sequence(ArrayBuffer(Person(Jim,Beam)))
  }
}
================================================================================

A simple example of how a for comprehension works.

object Demo
{
  def main(args:Array[String])
  {
    println(increment(1,30)) // PRINTS: List(5, 10, 15, 20, 25)
  }

  def increment(from: Int, to:Int):List[Int] =
  {
    for(idx <- List.range(from,to) if (idx % 5) == 0) yield idx
  }
}

================================================================================

The following code show many examples of how to use Scala's for() loop and
foreach() statement, including examples that implement the "yield" keyword.

object Demo
{
  def main(args: Array[String]):Unit =
  {
    val range1:Range = 0 to 9
    val range2:Range = 0 until 9

    for (x <- range1) { print(x) }; println  // PRINTS: 0123456789
    for (x <- range2) { print(x) }; println  // PRINTS: 012345678

    val list1:List[Int] = List(1,2,3)
    val list2:List[Int] = List(4,5,6)
    val list3:List[Int] = List(7,8,9)

    // NOTICE: Each of the following 4 for() loops uses a different
    //         combination of parenthesis () and curly braces {}.
    for (x <- list1) ( print(x) ); println // PRINTS: 123
    for (x <- list1) { print(x) }; println // PRINTS: 123
    for {x <- list1} ( print(x) ); println // PRINTS: 123
    for {x <- list1} { print(x) }; println // PRINTS: 123

    // The following commented-out for() loop will NOT compile cuz when a for() loop executes
    // more than one statement, it REQUIRES curly braces {} instead of parenthesis ().
    // for (x <- list1; y <- list2; z <- list3) ( print(x); print(y); print(z + "-") )

    // The following for() loop REQUIRES curly braces {} cuz it executes more than one statement.
    // The following for() loop prints a total of 81 single-digit Ints ranging from 1 through 9.
    // (9 X 9 = 81)  The following for() loop prints this:
    // 147-148-149-157-158-159-167-168-169-247-248-249-257-258-259-267-268-269-347-348-349-357-358-359-367-368-369-
    for (x <- list1; y <- list2; z <- list3) { print(x); print(y); print(z + "-")}; println;

    // To iterate through any collection (like a List), you can use a foreach() statement
    // instead of using a for() loop, as shown in the following line of code.
    list1.foreach(print); println // PRINTS: 123

    val numbers = Map("ThreePointZero" -> 3.0, "FourPointZero"  -> 4.0, "ThreePointFive" -> 3.5)
    numbers.foreach // This foreach() loops through each element of numbers...
    {
      // The following case statement prints this:
      // key: ThreePointZero, value: 3.0
      // key: FourPointZero, value: 4.0
      // key: ThreePointFive, value: 3.5
      case(key, value) => println(s"key: $key, value: $value")
    }
    // The following foreach() statement prints IDENTICAL results as the above foreach() statement.
    numbers.foreach(x => println(s"key: ${x._1}, value: ${x._2}"))

    numbers.values.foreach(x => print(x + " ")) // PRINTS: 3.0 4.0 3.5
    println
    numbers.keys.foreach(print) // PRINTS: ThreePointZeroFourPointZeroThreePointFive
    println
    numbers.keys.foreach(x => print(x + " ")) // PRINTS: ThreePointZero FourPointZero ThreePointFive
    println

    // A for() loop can contain one or multiple if() statements to "filter" its results, as shown here...
    for (x <- list1 if (x > 1); if (x < 3) ) { println("x = " + x) } // PRINTS: x = 2


    // *****************************************************************************************
    // USING FOR LOOPS WITH THE YIELD KEYWORD.

    // NOTE: The variable used by the yield statement must be the same variable the
    //       for() loop uses to obtain a value.  In the following line of code
    //       that variable is x.
    var result1:List[Int] = for { x <- list1 if (x > 1)} yield x
    println(result1) // PRINTS: List(2, 3)

    // NOTE: The variable(s) used by the yield statement must be the same variable(s)
    //       the for() loop uses to obtain value(s).  In the following line of code
    //       those variables are: a, b, c
    result1 = for { a <- list1; b <- list2; c <- list3 } yield sum(a,b,c)
    // The following println(result1) prints this:
    // List(12, 13, 14, 13, 14, 15, 14, 15, 16, 13, 14, 15, 14, 15, 16, 15, 16, 17, 14, 15, 16, 15, 16, 17, 16, 17, 18)
    // Those Int values are THE SUM of the single-digit Int values printed above.  For example:
    // 147-148-149-157-158-... = 1+4+7=12, 1+4+8=13, 1+4+9=14, 1+5+7=13, 1+5+8=14,...
    println(result1)

    // The following line of code is equivalent to the for() loop immediately above.
    // In fact, when the above for() loop is executed, Scala literally converts
    // that for() loop into the following code when it's executed.
    result1 = list1.flatMap(a => list2.flatMap(b => list3.map(c => sum(a,b,c))))
    println(result1) // PRINTS: List(12, 13, 14, 13, 14, 15, 14, 15, 16, 13, 14, 15, 14, 15, 16, 15, 16, 17, 14, 15, 16, 15, 16, 17, 16, 17, 18)


    // Using a for() loop on a Map collection...
    val nameMap = Map("firstName" -> "Joe", "lastName" -> "Blow")
    val poop = for ((k,v) <- nameMap) yield { s"key = $k, value = $v" }
    println(poop) // PRINTS: List(key = firstName, value = Joe, key = lastName, value = Blow)


    val nums:Seq[Int]     = Seq(1,2,3)
    val letters:Seq[Char] = Seq('a', 'b', 'c')
    val result2:Seq[(Int, Char)] = for { n <- nums; c <- letters } yield (n, c)
    println(result2) // PRINTS: List((1,a), (1,b), (1,c), (2,a), (2,b), (2,c), (3,a), (3,b), (3,c))


    val names:Seq[String]            = Seq("joe", "jack", "jennifer")
    val namesCapitalized:Seq[String] = for (x <- names) yield x.capitalize
    println(namesCapitalized) // PRINTS: List(Joe, Jack, Jennifer)
  }

  def sum(a:Int, b:Int, c:Int):Int = { a + b + c }
}
================================================================================

object Demo
{
  def main(args:Array[String])
  {
    // The following for() loop exists only to help understand the
    // for() loop in the multiples() function below.  It prints every
    // permutation from (0,0) to (0,41)
    //                  (1,1) to (1,41)
    //                  ...
    //                  (40,40) to (40,41)
    //                  (41,41)
    // So the for() loop in the matches() function iterates through the same permutations.
    for (a <- 0 until 42; b <- a until 42) { print(a,b) }
    println("\n=======================")

    // NOTICE:  1) The following line of code calls the foreach() function.
    //          2) The following line of code generates results identical
    //             to the code further below using the case statements.
    multiples(42,40).foreach(print) // PRINTS: (1,40)(2,20)(4,10)(5,8)
    println("\n=======================")
    multiples(42,40) foreach
    {
      case(a,b) => print("(" + a + ", " + b + ")") // PRINTS: (1, 40)(2, 20)(4, 10)(5, 8)
      case _    => println("NOTHING!")
    }
  }

  /**
    * This function returns a tuple of numbers that when multiplied
    * equals the value of y passed to this function.
    */
  def multiples(x:Int, y:Int) =
  {
    // NOTE: Tuple2() is a Scala API function--replacing it with (a,b) also works.
    for (a <- 0 until x; b <- a until x if a * b == y) yield Tuple2(a,b);
  }
}
===================================================================================================
object Demo
{
  def main(args:Array[String])
  {
    // The following 2 for() loops generate identical results.
    for (i <- Iterator.range(0, 15);  j <- Iterator.range(i, 15)  if i*j == 12)
    {
      print("(" + i + "," + j + ")") // PRINTS: (1,12)(2,6)(3,4)
    }
    println("\n================")
    val result = for (i <- Iterator.range(0, 15);  j <- Iterator.range(i, 15)  if i*j == 12) yield (i,j)
    result.foreach(print) // PRINTS: (1,12)(2,6)(3,4)
  }
}
===================================================================================================
