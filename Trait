There are three ways to create a data type in Scala:

1) object
2) class
3) trait

Use a Scala class/object to represent a "thing" such as
Person, Automobile, Aircraft, Animal, etc.  Use a Scala
trait to represent a "behavior", such as talk, ride,
fly, walk, etc.

A member of a class or trait is abstract if that member
DOESN'T have a complete definition in the class/trait.

Scala traits are mostly used to contain abstract (undefined)
vals/vars, methods, and types.  However, a Scala trait
CAN contain vals/vars, methods, and types that are defined
as shown in this sample code...
==============================================================
object Demo
{
  abstract trait TomsTrait  // The "abstract" keyword is optional here.
  {
    val weight:Int   = 123
    def getMyAge:Int = 17
    def undefinedMethod():String
  }
  case class Person(name:String) extends TomsTrait {
    override def undefinedMethod():String = "This method IS defined."
  }

  def main(args: Array[String]):Unit = {
    val tom:Person = Person("Tom")
    println(s"TomsTrait.weight = ${tom.weight}")     // PRINTS: TomsTrait.weight = 123
    println(s"TomsTrait.getMyAge = ${tom.getMyAge}") // PRINTS: TomsTrait.getMyAge = 17
    println(tom.undefinedMethod())                   // PRINTS: This method IS defined.
  }
}
==============================================================

IMPORTANT:
BY DEFINITION, A SCALA TRAIT IS ALWAYS ABSTRACT, WHICH MEANS A TRAIT
CAN'T BE INSTANTIATED.  However, it's possible to instantiate a Scala
trait via an anonymous class.  See the section below titled:
"HOW TO INSTANTIATE A TRAIT AS AN ANONYMOUS CLASS"

A trait is always abstract because it can't be instantiated.
When a trait's members are not defined (which is usually the
case), then those members (vals/vars, methods, types) are also
abstract.  Abstract members (of a trait or class) are intended
to be implemented in a subclass that inherits from the trait/class.

A Scala class, object or trait can extend ONLY ONE class/object,
but can all extend ANY NUMBER of traits.

Traits look nearly the same as a class.  However, just like objects,
traits CAN'T take parameters.  (NOTE: In Scala 3, traits CAN take
parameters.)

sealed trait - When a Scala trait definition is preceded with the Scala keyword "sealed"
               it means no other Scala file can extend that trait.  In other words,
               a sealed trait can only be extended by the file that contains the
               sealed trait definition.  Example:

               sealed trait Weather
               case object Sunny  extends Weather
               case object Windy  extends Weather
               case object Rainy  extends Weather
               case object Cloudy extends Weather

Scala lets you define the following inside a class or trait...

1) An abstract field (val/var).
2) An abstract method.
3) An abstract type.  Scala has the keyword "type" which works like this:
   
   type Number        = Int         // Allows you to use "Number" in place of Int
   type IntFloatTuple = (Int,Float) // Allows you to use "IntFloatTuple" in place of (Int,Float)

   Just as you can declare an abstract val/var, and an abstract
   method, you can also declare an abstract type.  The following
   code shows how to define an abstract type in a trait, and how
   to implment it in a subclass.

   trait Base
   {
     type T                 // An abstract type is declared.
     def square(number:T):T // An abstract method is declared.
     val initialValue:T     // An abstract val is declared.
     var currentValue:T     // An abstract var is declared.
   }
   class Parent extends Base // Inherits from the above trait named Base.
   {
     type T = Int
     def square(number:T):T = number * number
     val initialValue:T = 123
     var currentValue:T = initialValue
   }

When a class/object/trait inherits from another class/object/trait,
the "extends" keyword can be used ONLY ONCE, and it MUST APPEAR BEFORE
any "with" keyword(s).  The "extends" keyword can be used to inherit from
a class, an object, or a trait.  But the "with" keyword can be used
ONLY to inherit from traits.

Below are four (4) sample declarations that show how to inherit from traits.

1) A CLASS that extends one class and multiple traits:
   class Class_1 extends Class_2 with Trait_A with Trait_B { ... }

2) A CLASS that extends no class and multiple traits:
   class Class_1 extends Trait_A with Trait_B with Trait_C { ... }

3) A TRAIT that extends one class and multiple traits:
   trait Trait_A extends Class_A with Trait_B with Trait_C { ... }

4) A TRAIT that extends no class and multiple traits:
   trait Trait_E extends trait_D with trait_C with trait_B with trait_A { ... }
   
HOW TO INSTANTIATE A TRAIT AS AN ANONYMOUS CLASS
================================================
A trait can't be instantiated.  However, a trait can be used to
instantiate an anonymous class.  So it may appear as though a
trait can be instantiated, but it's an anonymous class that's
getting instantiated via the trait.

Read the in-line comments in the following two (2) code samples
below, which show how this is done.

==================================================================================

object Demo
{
  trait Person {
  def name:String
  def age:Int
  override def toString = s"name = $name,  age = $age"
  }

  def main(args: Array[String]): Unit =
  {
    val tom:Person = new Person { val name:String = "tom"
                                  val age:Int = 17 }
    println(tom) // PRINTS: name = tom,  age = 17

    // Even though Person is defined above as a trait, the following
    // below to println() reveals that "val tom" is an anonymous class.
    // Because it prints the text 'anon' as part of the class name.
    // So the "new Person {...}" code above instantiates an anonymous
    // class, NOT a trait.
    println(tom.getClass.toString) // PRINTS: class Demo$$anon$1
  }
}

==================================================================================
Here is another example where a trait is instantated via an anonymous class.

object Demo
{
  trait RationalTrait {
    def numerArg:Int // An abstract method, defined in main() when RationalTrait is called.
    def denomArg:Int // An abstract method, defined in main() when RationalTrait is called.
    private def calculateGcd(numer:Int, denom:Int):Int =
    {
      // This is a RECURSIVE method.
      if (denom == 0) numer
      else calculateGcd(denom, numer % denom)
    }
    require(denomArg !=0) // The require() method is always visible via Scala's PreDef class.
    private val gcd:Int = calculateGcd(numerArg, denomArg)
    def myStringResult:String = (numerArg/gcd) + "/" + (denomArg/gcd)
  }

  def main(args: Array[String]): Unit =
  {
    // IMPORTANT: Calling "new RationalTrait {...}" below does NOT
    //            instantiate a trait, because that's impossible.
    //            It instead instantiates an ANONYMOUS CLASS.
    var result:RationalTrait = new RationalTrait { override def numerArg: Int = 42;
                                                   override def denomArg: Int = 420 }
    println(s"result.myStringResult = ${result.myStringResult}") // PRINTS: result.myStringResult = 1/10

    // Here we see that result (of type RationalTrait) is an ANONYMOUS CLASS
    // because the text "anon" appears in the following println.
    println(s"result = $result") // PRINTS: result = Demo$$anon$1@782663d3
  }
}

==================================================================================

The following sample code shows how to use a Scala trait, and shows how
both abstract and concrete trait methods are implemented.

object Demo
{
  trait Pet
  {
    // comeToMaster is an ABSTRACT method because it's just declared, but not defined.
    // speak is a CONCRETE method because it's defined.
    def comeToMaster:Unit
    def speak:Unit = { println("I speak the universal Pet language.") }
  }

  class Dog extends Pet
  {
    def comeToMaster:Unit = { println("I'm a Dog, so I come when called.") }
  }

  class Cat extends Pet
  {
    override def speak:Unit = { println("MEOW") } // The override key word is required here.
    def comeToMaster:Unit   = { println("I'm a Cat, so I don't follow orders.") }
  }

  def main(args: Array[String])
  {
    val catPet:Cat = new Cat()
    catPet.speak        // PRINTS: MEOW
    catPet.comeToMaster // PRINTS: I'm a Cat, so I don't follow orders.

    val dogPet:Dog = new Dog()
    dogPet.speak        // PRINTS: I speak the universal Pet language.
    dogPet.comeToMaster // PRINTS: I'm a Dog, so I come when called.
  }
}

===================================================================================================

TRAIT LINEARIZATION (TRAIT METHOD RESOLUTION)
=============================================

When the following THREE (3) conditions occurs, Scala uses its Trait Linearization
algorithm to determine which traits get called, and in which order.

1) Two or more traits inherit from a single class/trait. (Multiple inheritance!)

2) These child traits override a method contained in the parent class/trait.

3) These overridden methods (contained in the child traits) also invoke a call
   to the the parent's overridden method via the 'super' keyword.

EXAMPLE: Look at the inheritance diagram immediately below.  Class_A, Trait_B,
         Trait_C, and Trait_D all contain a method named info().  Trait_B and
         Trait_D inherit from Class_A.  Trait_C inherits from Trait_B.
         
         Both Trait_B.info() and Trait_D.info() methods override Class_A.info(),
         and they both call super.info().  But ONLY ONE of those two methods
         will actually invoke super.info(), which means the Class_A parent
         class will invoke Class_A.info() ONLY ONE TIME.

         To determine which trait methods get called, and in which order they
         get called, is determined by Scala's Trait Linearization algorithm.
         
Follow this 5-STEP process to obtain the results of performing trait linearization
on the sample code shown below.

STEP 1)
Draw the inheritance diagram of the class/traits contained in the sample code's declaration.

                       -----------
                       | Class_A |
                       -----------
                            |
                     ----------------
                     |              |
                -----------    -----------
                | Trait_B |    | Trait_D |
                -----------    -----------
                     |              |
                -----------         |
                | Trait_C |         |
                -----------         |
                     |              |
                     ----------------
                            |
                      ------------
                      |  myClass |
                      ------------

STEP 2)
Define the linearization path for each trait/class shown in the above inheritance diagram.

L(Class_A) = (Class_A)
L(Trait_B) = (Trait_B -> Class_A)
L(Trait_C) = (Trait_C -> Trait_B -> Class_A)
L(Trait_D) = (Trait_D -> Class_A)

STEP 3)
USE THIS DECLARATION FROM THE CODE:  val myClass = new Class_A with Trait_D with Trait_C with Trait_B
Substitute values obtained in STEP 2) to obtain the linearization path.
OBTAIN LINEARIZATION PATH:  (Class_A) -> (Trait_D -> Class_A) -> (Trait_C -> Trait_B -> Class_A) -> (Trait_B -> Class_A)

STEP 4)
Reverse the order of the linearization path just obtained.  Like this:
(Trait_B -> Class_A) -> (Trait_C -> Trait_B -> Class_A) -> (Trait_D -> Class_A) -> (Class_A)

STEP 5)
Simplify the linearization path obtained in STEP 4) by removing all duplicate path names.
BEGIN WITH THE RIGHT-MOST ELEMENT (Class_A).  Keep the right-most element, and remove all
other duplicate references appearing to its left.  So we keep the right-most Class_A,
and remove all other Class_A references to its left, resulting in this:

(Trait_B) -> (Trait_C -> Trait_B) -> (Trait_D) -> (Class_A)

Repeat STEP 4) beginning with next right-most element (Trait_D), and remove
all Trait_D duplicates to its left.  No Trait_D duplicates exist, so the
linearization path remains unchanged:

(Trait_B) -> (Trait_C -> Trait_B) -> (Trait_D) -> (Class_A)

Repeat STEP 4) beginning with next right-most element (Trait_B), and remove
all Trait_B duplicates to its left, which results in this:

(Trait_C -> Trait_B) -> (Trait_D) -> (Class_A)

The linearization algorithm is done when there are no more
duplicate elements in the linearization path.  Remove the
parenthesis to obtain the final result:

FINAL LINEARIZATION PATH:  Trait_C -> Trait_B -> Trait_D -> Class_A

From this result we can determine that the println(myClass.info) statement
in the below code sample will print this:

Trait_C.info() called.
Trait_B.info() called.
Trait_D.info() called.
Class_A.info() called.

object Demo
{
  class Class_A {
    def info() = "Class_A.info() called."
  }

  trait Trait_B extends Class_A {
    override def info() = "Trait_B.info() called.\n" + super.info()
  }

  trait Trait_C extends Trait_B {
    override def info() = "Trait_C.info() called.\n" + super.info()
  }

  trait Trait_D extends Class_A {
    override def info() = "Trait_D.info() called.\n" + super.info()
  }

  def main(args: Array[String])
  {
    val myClass = new Class_A with Trait_D with Trait_C with Trait_B
    println(myClass.info) // PRINTS: Trait_C.info() called.
                          //         Trait_B.info() called.
                          //         Trait_D.info() called.
                          //         Class_A.info() called.
  }
}

===================================================================================================

The code sample below shows another example of multiple inheritance,
for which we determine the trait linearization path.


STEP 1)
Draw the inheritance diagram of the class/traits contained in the sample code's declaration.

                        -----------
                        | Trait_A |
                        -----------
                            |
                     ---------------
                     |             |
               -----------     -----------
               | Trait_B |     | Trait_C |
               -----------     -----------
                    |              |
                    ----------------
                           |
                     --------------
                     | Grandchild |
                     --------------


STEP 2)
Define the linearization path for each trait/class shown in the above inheritance diagram.

L(Trait_A)    = (Trait_A)
L(Trait_B)    = (Trait_B -> Trait_A)
L(Trait_C)    = (Trait_C -> Trait_A)

STEP 3)
USE THIS DECLARATION FROM THE CODE:  class GrandChild extends TraitB with TraitC
                                     val grandChild_1:GrandChild = new GrandChild
Substitute values obtained in STEP 2) to obtain the linearization path.
OBTAIN LINEARIZATION PATH:  (Trait_B -> Trait_A) -> (Trait_C -> Trait_A)

STEP 4)
Reverse the order of the linearization path just obtained.  Like this:
(Trait_C -> Trait_A) -> (Trait_B -> Trait_A)
 
 
STEP 5)
Simplify the linearization path obtained in STEP 4) by removing all duplicate path names.
BEGIN WITH THE RIGHT-MOST ELEMENT (Trait_A).  Keep the right-most element, and remove all
other duplicate references appearing to its left.  So we keep the right-most Trait_A,
and remove all other Trait_A references to its left, resulting in this:

(Trait_C) -> (Trait_B) -> Trait_A

The linearization algorithm is done when there are no more
duplicate elements in the linearization path.  Remove the
parenthesis to obtain the final result:

FINAL LINEARIZATION PATH:  Trait_C -> Trait_B -> Trait_A

From this result we can determine that the grandChild_1.name
statement in the below code sample will print this:

TraitC.name called.
TraitB.name called.
TraitA.name called.


object Demo
{
  trait TraitA {
    def name = println("TraitA.name called.")
  }

  trait TraitB extends TraitA {
    override def name = {
      println("TraitB.name called.")
      super.name
    }
  }

  trait TraitC extends TraitA {
    override def name = {
      println("TraitC.name called.")
      super.name
    }
  }

  def main(args: Array[String])
  {
    class GrandChild extends TraitB with TraitC
    val grandChild_1:GrandChild = new GrandChild
    grandChild_1.name // PRINTS: TraitC.name called.
                      //         TraitB.name called.
                      //         TraitA.name called.

    println("\n====================================\n")
    // Same thing as above, except when an object is instantiated,
    // the 'new' keyword isn't used.
    object grandChild_2 extends TraitB with TraitC
    grandChild_2.name // PRINTS: TraitC.name called.
                      //         TraitB.name called.
                      //         TraitA.name called.
  }
}

===================================================================================================

When a class extends another class/trait, the in-line code contained in each
class/trait gets executed upon instantiation of the base class.  The sample
code shown below reveals the execution order of this in-line code.

class Class_B extends Class_A with Trait_A with Trait_B
val classB:Class_B = new Class_B

When that code executes, the in-line code contained
in each class/trait is executed in this order:

1) Class_A in-line code executes.
2) Trait_A in-line code executes.
3) Trait_B in-line code executes.
4) Class_B in-line code executes.

Notice that this sample code performs multiple inheritance, and
Trait_A and Trait_B inherit from Class_A, but this sample code
does NOT contain a call to 'super'.  So when class_B.test()
is called below, it prints ONLY this line:  Trait_B.test() called.

Here is how Scala's Trait Linearization algorithm determines
that ONLY 

1) From the code, wee see that Class_B inherits from the following classes/traits.

   Class_B extends Class_A with Trait_A with Trait_B

2) Write the linearization path order of this declaration.

   L(Class_A) = Class_A
   L(Trait_A) = (Trait_A -> Class_A)
   L(Trait_B) = (Trait_B -> Class_A)
   
   Class_A -> (Trait_A -> Class_A) -> (Trait_B -> Class_A)

3) Reverse the order, and remove parenthesis.

  (Trait_B -> Class_A) -> (Trait_A -> Class_A) -> Class_A
   Trait_B -> Class_A  ->  Trait_A -> Class_A  -> Class_A

4) Simplify the linearization path obtained in STEP 3) by removing
   all duplicate path names.  BEGIN WITH THE RIGHT-MOST ELEMENT (Class_A).
   Keep the right-most element, and remove all other duplicate references
   appearing to its left.  So we keep the right-most Class_A, and remove
   all other Class_A references to its left, resulting in this:

   FINAL LINEARIZATION PATH: Trait_B -> Trait_A -> Class_A

5) Because none of the test() methods call super.test() the
   only test() method that executes is THE FIRST ONE FOUND
   IN THE LINEARIZATION PATH, which is the Trait_B.test() method.
   So the call to classB.test() prints:  Trait_B.test() called.

object Demo
{
  class Class_A
  {
    println("Class_A in-line code executes.")
    def test():Unit = println("Class_A.test() called.")
  }

  trait Trait_A extends Class_A
  {
    println("Trait_A in-line code executes.")
    override def test():Unit = println("Trait_A.test() called.")
  }
  trait Trait_B extends Class_A
  {
    println("Trait_B in-line code executes.")
    override def test():Unit = println("Trait_B.test() called.")
  }
  class Class_B extends Class_A with Trait_A with Trait_B
  {
    println("Class_B in-line code executes.")
  }

  def main(args: Array[String])
  {
    val classB:Class_B = new Class_B // PRINTS:  Class_A in-line code executes.
                                     //          Trait_A in-line code executes.
                                     //          Trait_B in-line code executes.
                                     //          Class_B in-line code executes.
    classB.test() // PRINTS: Trait_B.test() called.
  }
}

===================================================================================================

The following sample code is identical to the program immediately above,
except that Trait_A and Trait_B both invoke a call to super.test().
In the code sample above, Class_A, Trait_A, and Trait_B all contain
a method named test(). So the only test() method that gets called
(in the code above) is the first one found in the Trait Linearization
path, which is a call to classB.test()

The Trait Linearization path for the code below is identical
to the above sample program.

FINAL LINEARIZATION PATH: Trait_B -> Trait_A -> Class_A

But the behavior of the code below is different because it calls super.test()
in both Trait_A and Trait_B.  So when classB.test() is called in the below code,
it calls these 3 methods in the following order:

1)  Trait_B.test()
2)  Trait_A.test()
3)  Class_A.test()

Notice that both Trait_A.test() and Trait_B.test() get called in the below code,
and they both call Class_A.test() via a call to super.test().  But Class_A.test()
gets called ONLY ONCE, via the call to super.test() in Trait_A.  Trait_B does NOT
invoke super.test().  This follows Scala's Trait Linearization algorithm, where
ONLY ONE of the calls to super.methodName() gets invoked from a child class--the
last call to super.methodName() found in the linearization path.

object Demo
{
  class Class_A
  {
    println("Class_A in-line code executes.")
    def test():Unit = println("Class_A.test() called.")
  }

  trait Trait_A extends Class_A
  {
    println("Trait_A in-line code executes.")
    override def test():Unit = { println("Trait_A.test() called."); super.test() }
  }
  trait Trait_B extends Class_A
  {
    println("Trait_B in-line code executes.")
    override def test():Unit = { println("Trait_B.test() called."); super.test() }
  }
  class Class_B extends Class_A with Trait_A with Trait_B
  {
    println("Class_B in-line code executes.")
  }

  def main(args: Array[String])
  {
    val classB:Class_B = new Class_B // PRINTS:  Class_A in-line code executes.
                                     //          Trait_A in-line code executes.
                                     //          Trait_B in-line code executes.
                                     //          Class_B in-line code executes.
    classB.test() // PRINTS:  Trait_B.test() called.
                  //          Trait_A.test() called.
                  //          Class_A.test() called.
  }
}

===================================================================================================

The code below contains this declaration, from which
we'll determine the Trait Linearization path.

val classA:Class_A = new Class_A with Trait_B with Trait_A

L(Class_A) -> Class_A
L(Trait_A) -> (Trait_A -> Class_A)
L(Trait_B) -> (Trait_B -> Class_A)

Write the linearization path order of this declaration.

Class_A -> (Trait_A -> Class_A) -> (Trait_B -> Class_A)

Reverse the order, and remove parenthesis.

Trait_B -> Class_A -> Trait_A -> Class_A -> Class_A

Simplify the linearization path obtained in STEP 3) by removing
all duplicate path names.  BEGIN WITH THE RIGHT-MOST ELEMENT (Class_A).
Keep the right-most element, and remove all other duplicate references
appearing to its left.  So we keep the right-most Class_A, and remove
all other Class_A references to its left, resulting in this:

FINAL LINEARIZATION PATH: Trait_B -> Trait_A -> Class_A

The reason classA.test1("YELLOW") prints the color BLUE instead of the color
YELLOW is because the first test1() method found is Trait_B.test1(), and
Trait_B.test1() calls Class_A.test1() via super.test1("BLUE" with the
color BLUE hard-coded.

object Demo
{
  class Class_A
  {
    println("Class_A in-line code executes.")
    def test1(color:String):Unit = println(s"Class_A.test1() called.  color = $color")
    def test2(color:String):Unit = println(s"Class_A.test2() called.  color = $color")
  }
  trait Trait_A extends Class_A
  {
    println("Trait_A in-line code executes.")
    override def test1(color:String):Unit = super.test1("GREEN")
  }
  trait Trait_B extends Class_A
  {
    println("Trait_B in-line code executes.")
    override def test1(color:String):Unit = super.test1("BLUE")
  }

  def main(args: Array[String])
  {
    val classA:Class_A = new Class_A with Trait_B with Trait_A // PRINTS: Class_A in-line code executes.
                                                               //         Trait_B in-line code executes.
                                                               //         Trait_A in-line code executes.
    classA.test1("YELLOW") // PRINTS: Class_A.test1() called.  color = BLUE
    classA.test2("ORANGE") // PRINTS: Class_A.test2() called.  color = ORANGE
  }
}

===================================================================================================

BELOW ARE SEVERAL MORE SAMPLE PROGRAMS USING TRAITS.
BELOW ARE SEVERAL MORE SAMPLE PROGRAMS USING TRAITS.
BELOW ARE SEVERAL MORE SAMPLE PROGRAMS USING TRAITS.

BELOW ARE SEVERAL MORE SAMPLE PROGRAMS USING TRAITS.
BELOW ARE SEVERAL MORE SAMPLE PROGRAMS USING TRAITS.
BELOW ARE SEVERAL MORE SAMPLE PROGRAMS USING TRAITS.

BELOW ARE SEVERAL MORE SAMPLE PROGRAMS USING TRAITS.
BELOW ARE SEVERAL MORE SAMPLE PROGRAMS USING TRAITS.
BELOW ARE SEVERAL MORE SAMPLE PROGRAMS USING TRAITS.

===================================================================================================

object Demo
{
  class Ball {
    def roll(ball : String): Unit = println("Rolling: " + ball)
  }

  trait Red extends Ball {
    override def roll(ball: String): Unit = super.roll("Red-" + ball)
  }

  trait Green extends Ball {
    override def roll(ball: String): Unit = super.roll("Green-" + ball)
  }

  trait Shiny extends Ball {
    override def roll(ball: String): Unit = super.roll("Shiny-" + ball)
  }

  def main(args: Array[String]):Unit = {
    val ball1 = new Ball() with Shiny with Red
    ball1.roll("Ball-1") // Rolling: Shiny-Red-Ball-1

    val ball2 = new Ball with Green with Shiny
    ball2.roll("Ball-2") // Rolling: Green-Shiny-Ball-2

    val ball3 = new Ball with Red with Shiny
    ball3.roll("Ball-3") // Rolling: Red-Shiny-Ball-3

    val ball4 = new Ball with Shiny with Green
    ball4.roll("Ball-4") // Rolling: Shiny-Green-Ball-4
  }
}
=====================================================================================

object Demo
{
  class Vehicle
  {
    def method:String= "Vehicle "
  }

  trait Bike extends Vehicle
  {
    override def method:String = "Bike -> "+ super.method
  }

  trait MuscleBike extends Vehicle
  {
    override def method:String = "Muscle Bike -> "+ super.method
  }

  trait Harley extends Vehicle
  {
    override def method:String ="Harley Davidson -> "+ super.method
  }

  class Iron1 extends Bike with MuscleBike with Harley
  {
    override def method:String = "Iron1 -> "+ super.method
  }

  class Iron2 extends Harley with MuscleBike with Bike
  {
    override def method:String = "Iron2 -> "+ super.method
  }

  def main(args: Array[String])
  {
    val myBike1:Iron1 = new Iron1
    println(myBike1.method)

    val myBike2:Iron2 = new Iron2
    println(myBike2.method)
  }
}

=====================================================================================

The following sample code does NOT deal with trait Linearization.
Just read the code and comments to understand it.

object Demo
{
  trait Equal {
    def isEqual(x: Any): Boolean
    def isNotEqual(x: Any): Boolean = !isEqual(x)
  }

  class Point(xc: Int, yc: Int) extends Equal {
    val x: Int = xc // This line executes ONLY when a Point class is instantiated.
    val y: Int = yc // This line executes ONLY when a Point class is instantiated.

    def isEqual(obj: Any):Boolean =
    {
      if (obj.isInstanceOf[Point] && obj.asInstanceOf[Point].x == xc && obj.asInstanceOf[Point].y == yc)
      {
        println("xc = " + xc + ",  yc = " + yc +
                "\nobj.asInstanceOf[Point].x = " + obj.asInstanceOf[Point].x + ",  obj.asInstanceOf[Point].y = " + obj.asInstanceOf[Point].y)
        true
      }
      else false
    }
  }

  def main(args: Array[String]) {
    val p1 = new Point(1, 2)
    val p2 = new Point(3, 4)
    val p3 = new Point(5, 6)
    val p4 = new Point(1, 2)

    println(p1.isEqual(p2)) // PRINTS: false
    println("--------------------------")
    println(p1.isEqual(p3)) // PRINTS: false
    println("--------------------------")
    println(p1.isEqual(p4)) // PRINTS: xc = 1,  yc = 2
                            //         obj.asInstanceOf[Point].x = 1,  obj.asInstanceOf[Point].y = 2
                            //         true
    println("--------------------------")
    println(p1.isNotEqual(p4)) // PRINTS: xc = 1,  yc = 2
                               //         obj.asInstanceOf[Point].x = 1,  obj.asInstanceOf[Point].y = 2
                               //         false
    println("--------------------------")
    println(p1.isNotEqual(1)) // PRINTS: true
  }
}

===================================================================

object Demo
{
  trait trait_A
  {
    println("trait_A constructed.")
    def func_A() = { println("trait_A.func_A() is called.") }
  }
  trait trait_B
  {
    println("trait_B constructed.")
    def func_B() = { println("trait_B.func_B() is called.") }
  }
  trait trait_C
  {
    println("trait_C constructed.")
    def func_C() = { println("trait_C.func_C() is called.") }
  }
  trait trait_D
  {
    println("trait_D constructed.")
    // def func_A() = { println("trait_D.func_A() is called.") }
    def func_D() = { println("trait_D.func_D() is called.") }
  }
  class class_1
  {
    println("class_1 constructed.")
  }
  class class_2 extends class_1 with trait_D  with trait_C  with trait_B  with trait_A
  {
    println("class_2 constructed.")
  }

  /**********************
   * main() function.
   *********************/
  def main(args: Array[String]):Unit =
  {
    val class_2:class_2 = new class_2()
    class_2.func_A()
  }
}

====================================================================

object Demo
{
  class class_A {
    println("class_A construted.")
    def func():String = "class_A"
  }

  trait trait_B extends class_A {
    println("trait_B construted.")
    override def func():String = "trait_B"
  }

  trait trait_C extends class_A {
    println("trait_C construted.")
    override def func():String = "trait_C"
  }

  trait trait_D extends class_A {
    println("trait_D construted.")
    override def func():String = "trait_D"
  }

  trait trait_B2 extends class_A {
    println("trait_B2 construted.")
    override def func():String = "trait_B2 " + super.func()
  }

  trait trait_C2 extends trait_B2 {
    println("trait_C2 construted.")
    override def func():String = "trait_C2 " + super.func()
  }

  trait trait_D2 extends class_A {
    println("trait_D2 construted.")
    override def func():String = "trait_D2 " + super.func()
  }

  /**********************
   * main() function.
   *********************/
  def main(args: Array[String]): Unit = {
    var classA:class_A = new class_A with trait_D with trait_C with trait_B
    println(classA.func()) // PRINTS: trait_B
    println("===========================")
    classA = new class_A with trait_D2 with trait_C2 with trait_B2
    println(classA.func()) // PRINTS: trait_C2 trait_B2 trait_D2 class_A
  }
}

==================================================================================

object Demo
{
  trait Trait_A
  {
    println("Trait_A constructed.")
    def func_A() = { println("Trait_A.func_A() is called.") }
  }
  trait Trait_B extends Trait_A
  {
    println("Trait_B constructed.")
    def func_B() = { println("Trait_B.func_B() is called.") }
  }
  trait Trait_C extends Trait_B
  {
    println("Trait_C constructed.")
    def func_C() = { println("Trait_C.func_C() is called.") }
    def func_D() = { println("Trait_C.func_D() is called.") }
  }
  trait Trait_D extends Trait_C
  {
    println("Trait_D constructed.")
  }
  class Class_1 extends Trait_D
  {
    println("Class_1 constructed.")
  }
  class Class_2
  {
    println("Class_2 constructed.")
    def func_A() = { println("Class_2.func_A() is called.") }
  }
  class Class_3 extends Class_2
  {
    println("Class_3 constructed.")
  }

  /**********************
   * main() function.
   *********************/
  def main(args: Array[String]):Unit =
  {
    println("=============================")
    val myClass_1:Class_1 = new Class_1()
    myClass_1.func_A()  // PRINTS: Trait_A.func_A() is called.
    myClass_1.func_B()  // PRINTS: Trait_B.func_B() is called.
    myClass_1.func_C()  // PRINTS: Trait_C.func_C() is called.
    myClass_1.func_D()  // PRINTS: Trait_D.func_D() is called.
    println("=============================")
    val myClass_3:Class_3 = new Class_3()
    // NOTE: When myClass_3.func_A() below executes, Class_2.func_A() gets called.
    myClass_3.func_A()  // PRINTS: Class_2.func_A() is called.
  }
}

==================================================================================
The following sample code shows the similarities and
differences of a Scala trait versus a Scala abstract class.

object Demo
{
  abstract class Person_Abstract_Class
  {
    val name:String
    val age:Int
    override def toString = s"name: $name, age: $age"
  }

  trait Person_Trait
  {
    def name:String // Equivalent to:  val name:String
    def age:Int     // Equivalent to:  val age:Int
    override def toString = s"name: $name, age: $age"
  }

  def main(args: Array[String]): Unit =
  {
    val tom_1:Person_Trait =  new Person_Trait {
      val name:String = "Tom"
      val age:Int = 63
    }
    println(tom_1) // PRINTS: name: Tom, age: 63

    val tom_2:Person_Abstract_Class = new Person_Abstract_Class {
      val name = "Tom_2"
      val age = 6363
    }
    println(tom_2) // PRINTS: name: Tom_2, age: 6363
   }
}

==========================================================================================

object Demo
{
  // THIS CODE DEMONSTRATES HOW TO USE A SCALA TRAIT
  trait Iterator[A]
  {
    // The following 2 functions (hasNext and next) are abstract because they're
    // NOT defined here, only declared.  Any class/trait that inherits from this
    // trait MUST define (implement) these 2 functions.
    def hasNext: Boolean // NOTE: The hasNext function is implemented in the below class that extends this trait.
    def next: A          // NOTE: The next    function is implemented in the below class that extends this trait.
  }

  /**
   *
   * @param maxIterIndex - This Int value designates the maximum upper limit of the iteration index.
   */
  class IntIterator(maxIterIndex: Int) extends Iterator[Int]
  {
    private var currentIterIndex:Int = 0  // NOTE: currentIterIndex is a var type!
    override def hasNext:Boolean = { currentIterIndex < maxIterIndex }
    override def next:Int =
    {
      if (hasNext)
      {
        val nextIterIndex:Int = currentIterIndex
        currentIterIndex += 1
        nextIterIndex
      }
      else { 0 } // Once the Iterator is "spent" this "else" statement (which returns zero) always executes.
    }
  }

  /**
   * @param args Arguments passed from the command line.
   */
  def main(args: Array[String])
  {
    val iterator:IntIterator = new IntIterator(10) // iterator is initialized to perform 10 iterations.

    // The following print statements collectively print this single line:
    // 0, 1, 2, 3, 4, 5, 6, 7, 8, true, 9, false, 0, 0, 0
    print(iterator.next + ", ") // PRINTS: 0
    print(iterator.next + ", ") // PRINTS: 1
    print(iterator.next + ", ") // PRINTS: 2
    print(iterator.next + ", ") // PRINTS: 3
    print(iterator.next + ", ") // PRINTS: 4
    print(iterator.next + ", ") // PRINTS: 5
    print(iterator.next + ", ") // PRINTS: 6
    print(iterator.next + ", ") // PRINTS: 7
    print(iterator.next + ", ") // PRINTS: 8
    // The following line returns true cuz the iterator is NOT yet spent.
    print(iterator.hasNext + ", ") // PRINTS: true
    print(iterator.next + ", ") // PRINTS: 9
    // The following line returns false cuz the iterator IS spent.
    print(iterator.hasNext + ", ") // PRINTS: false
    // The following 3 lines return 0 cuz the iterator IS spent.
    print(iterator.next + ", ") // PRINTS: 0
    print(iterator.next + ", ") // PRINTS: 0
    println(iterator.next)      // PRINTS: 0
  }
}

===========================================================================
Here's another sample program showing how to use Scala traits...

object Demo
{
  trait Drawable
  {
    def draw() { }
  }

  trait Cowboy extends Drawable
  {
    override def draw() = { println("BANG!  The Cowboy drew a gun.") }
  }

  trait Artist extends Drawable
  {
    override def draw() = { println("PICTURE!  The Artist drew a painting.") }
  }

  class ArtistCowboy extends Artist with Cowboy
  class CowboyArtist extends Cowboy with Artist

  def main(args: Array[String])
  {
    val artCow = new ArtistCowboy()
    val cowArt = new CowboyArtist()

    // For artCow, Scala searches for the draw() function first in the Cowboy trait, then
    // in the Artist trait.  The Cowboy.draw() function is found first, so it gets called.
    artCow.draw() // PRINTS:  BANG!  The Cowboy drew a gun.

    // For cowArt, Scala searches for the draw() function first in the Artist trait, then
    // in the Cowboy trait.  The Artist.draw() function is found first, so it gets called.
    cowArt.draw() // PRINTS:  PICTURE!  The Artist drew a painting.
  }
}

=======================================================================================

Rich Interface - A rich interface has many methods, which makes it convenient to use
                 because the caller is likely to find a method that exactly matches the
                 functionality she needs.

Thin Interface - A thin interface has fewer methods than a rich interface, so it's easier
                 for the programmer to write a thin interface than a rich interface.
                 However, the programmer who uses a thin interface will likely require
                 her to write more code because the thin interface supplies fewer methods
                 than the rich interface.

Traits can be used to enrich a thin interface, transforming it into a rich interface,
as is shown in the following example...

Look at the Point, Rectangle, and Component classes defined here.  Continue reading below.

class Point(val x: Int, val y: Int)
class Rectangle(val topLeft: Point, val bottomRight: Point)
{
  def left = topLeft.x
  def right = bottomRight.x
  def width = right - left
  // Assume more methods belong to this Rectangle class.
}
abstract class Component
{
  def topLeft: Point
  def bottomRight: Point

  def left = topLeft.x
  def right = bottomRight.x
  def width = right - left
  // Assume more methods belong to this abstract class Component.
}

Notice the left, right, and width methods defined above in the Rectangle class
are identical to the ones defined above in the abstract class Component.
These 3 methods will also likely reside in any other classes representing
rectangular objects.

This repetition can be eliminated with an enrichment trait shown immediately
below that's named Rectangular.  This Rectangular trait has two abstract
methods: one that returns the top-left coordinate of the object, and another
that returns the bottom-right coordinate.  It can then supply concrete
implementations of all the other geometric queries.

trait Rectangular
{
  def topLeft: Point
  def bottomRight: Point

  def left = topLeft.x
  def right = bottomRight.x
  def width = right - left
  // Assume more methods belong to this trait named Rectangular.
}

We can now redefine the above class Rectangle, and abstract class Component,
as follows.  This time, both classes are defined by extending the Rectangular
trait.  In other words, both these classes "mix-in" the Rectangular trait...

abstract class Component extends Rectangular
{
  // Assume more methods belong to this abstract class Component.
}
class Rectangle(val topLeft: Point, val bottomRight: Point) extends Rectangular
{
  // Assume more methods belong to this Rectangle class.
}
=======================================================================================
For more info on Scala Traits SEE P.463 of book, or the following web pages:
https://www.artima.com/pins1ed/traits.html
http://docs.scala-lang.org/tour/traits.html
