There are three ways to create a data type in Scala:

1) object
2) class
3) trait

NOTE: In the Scala API documentation...
      1) A circled 'c' represents a class.
      2) A circled 'o' represents an object.
      3) A circled 'p' represents a package.
      4) A circled 't' represents a trait.

A Scala class, case class, object or trait can extend ONLY ONE
class/object, but they can all extend any number of traits.
A trait can extend ONLY ONE class/object.

Traits look nearly the same as a class.  However, just like objects,
traits CAN'T take parameters.  (NOTE: In Scala 3 Traits CAN take
parameters.)  This is the syntax for defining a trait:

trait <identifier> [extends <identifier>] [{ fields, methods, and classes }]

Below are four (4) declarations that show how to extend traits.

// A CLASS that extends one class and multiple traits...
class Class_1 extends Class_2 with Trait_A with Trait_B { ... }

// A CLASS that extends no class and multiple traits...
class Class_1 extends Trait_A with Trait_B with Trait_C { ... }

// A TRAIT that extends one class and multiple traits...
trait Trait_A extends Class_A with Trait_B with Trait_C { ... }

// A TRAIT that extends no class and multiple traits...
trait Trait_E extends trait_D with trait_C with trait_B with trait_A { ... }

QUESTION: When coding an abstract type that WILL BE USED WITH INHERITANCE,
          should a "trait" or an "abstract class" be used?

ANSWER: The rule of thumb is to use a trait because traits are capable of
        always functioning properly when multiple inheritance is implemented.
        While a trait can't take arguments (as can an abstract class can),
        any vals/vars that you'd generally provide as arguments can be put
        into a trait and left undefined, so the class that implements
        the trait will have to provide those values.

Some important differences between a Scala class/object and a trait are:

1) Traits allow multiple inheritance to always function properly because Scala's
   trait linearization algorithm always resolves the ambiguity of which method
   should get called when multiple inheritance encounters "the diamond problem."
   Trait lineraization and the "diamond problem" is explained further below.

2) A class/object can extend any number of traits.
   A trait can extend ONLY ONE class/object, and any number of traits.

3) A trait CAN'T contain arguments/parameters like a class can.
   (NOTE: In Scala 3 Traits can take args/params.)
   For example, you can define a class like below, which contains
   the arguments/parameters x and y...
   class Point(x: Int, y: Int) // Will compile

   The following attempt to define a trait WON'T compile
   because it contains arguments/parameters...
   trait Point(x: Int, y: Int) // Won't compile

4) A call to super.methodName() IN A CLASS is STATICALLY BOUND if the
   super.methodName() is contained in a PARENT CLASS (not in a parent
   trait).  This means the PARENT CLASS METHOD that gets called is
   DETERMINED AT COMPILE-TIME.

   If a class/trait inherits a method that EXISTS IN TWO (2) OR MORE PARENT
   TRAITS, a call to super.methodName() is DYNAMICALLY BOUND.  This means
   the PARENT TRAIT METHOD that gets called is DETERMINED AT RUNTIME via
   the Scala trait linearization algorithm.

5) A class/object CAN be instantiated.
   A trait CAN'T be instantiated.
   
   NOTE: A trait is always abstract by definition, which means a trait CAN'T be
         instantiated.  The code below defines Person as a trait.  The main()
         function then APPEARS to instantiate a trait by calling:  new Person...

         The code compiles and successfully executes, but it DOESN'T instatiate
         the Person trait!!!  Instead, the code is instantiating an ANONYMOUS CLASS
         using the Person trait.  An anonynous class is NOT abstract so an anonymous
         class CAN be instantiated.  So a trait can be used to instantiate an
         anonymous class.  But you CAN'T instantiate a trait.  Read in-line comments
         in the code sample for details.

         For more info on anonymous classes see:
         https://github.com/w9mwi/Scala/blob/master/Class_Anonymous
==================================================================================
 object Demo
 {
   trait Person {
     def name:String
     def age:Int
     override def toString = s"name = $name,  age = $age"
   }

   def main(args: Array[String]): Unit = {
     val tom:Person = new Person { val name:String = "tom"
                                   val age:Int = 17 }
     println(tom) // PRINTS: name = tom,  age = 17

     // Even though Person is defined above as a trait, the following
     // println reveals that Person tom is an anonymous class because
     // the text 'anon' is contained in the class name.  So the above
     // "new Person..." instantiates an anonymous class, NOT a trait.
     println(tom.getClass.toString) // PRINTS: class Demo$$anon$1
   }
 }

==================================================================================
If a trait/class contains a member function that     IS defined, that member method is concrete.
If a trait/class contains a member function that  ISN'T defined, that member method is abstract.
If a trait/class contains a member value that    IS initialized, that member value is concrete.
If a trait/class contains a member value that ISN'T initialized, that member value is abstract.

A trait is very similar to an abstract class in many ways.  When a class extends a
trait that has an abstract method (a method that's declared, but not defined), each
abstract method contained in the trait must be defined in the class that extends
the trait.  The following sample code shows how to use a Scala trait, and shows how
both abstract and concrete trait methods are implemented.

object Demo
{
  trait Pet
  {
    // comeToMaster is an ABSTRACT method because it's just declared, but not defined.
    // speak is a CONCRETE method because it's defined.
    def comeToMaster:Unit
    def speak:Unit = { println("I speak the universal Pet language.") }
    
  }

  class Dog extends Pet
  {
    def comeToMaster:Unit = { println("I'm a Dog, so I come when called.") }
  }

  class Cat extends Pet
  {
    override def speak:Unit = { println("MEOW") } // The override key word is required here.
    def comeToMaster:Unit   = { println("I'm a Cat, so I don't follow orders.") }
  }

  def main(args: Array[String])
  {
    val catPet:Cat = new Cat()
    catPet.speak        // PRINTS: MEOW
    catPet.comeToMaster // PRINTS: I'm a Cat, so I don't follow orders.

    val dogPet:Dog = new Dog()
    dogPet.speak        // PRINTS: I speak the universal Pet language.
    dogPet.comeToMaster // PRINTS: I'm a Dog, so I come when called.
  }
}


===================================================================================================

TRAIT LINEARIZATION (TRAIT METHOD RESOLUTION)
=============================================

When the following THREE (3) conditions occurs, Scala uses its Trait Linearization
algorithm to determine which traits get called, and in which order.

1) Two or more traits inherit from a single class/trait. (Multiple inheritance!)

2) These child traits override a method contained in the parent class/trait.

3) These overridden methods (contained in the child traits) also invoke a call
   to the the parent's overridden method via the 'super' keyword.

EXAMPLE: Look at the inheritance diagram immediately below.  Class_A, Trait_B,
         Trait_C, and Trait_D all contain a method named info().  Trait_B and
         Trait_D inherit from Class_A.  Trait_C inherits from Trait_B.
         
         Both Trait_B.info() and Trait_D.info() methods override Class_A.info(),
         and they both call super.info().  But ONLY ONE of those two methods
         will actually invoke super.info(), which means the Class_A parent
         class will invoke Class_A.info() ONLY ONE TIME.

         To determine which trait methods get called, and in which order they
         get called, is determined by Scala's Trait Linearization algorithm.
         
Follow this 5-STEP process to obtain the results of performing trait linearization
on the sample code shown below.

STEP 1)
Draw the inheritance diagram of the class/traits contained in the sample code's declaration.

                       -----------
                       | Class_A |
                       -----------
                            |
                     ----------------
                     |              |
                -----------    -----------
                | Trait_B |    | Trait_D |
                -----------    -----------
                     |              |
                -----------         |
                | Trait_C |         |
                -----------         |
                     |              |
                     ----------------
                            |
                      ------------
                      |  myClass |
                      ------------

STEP 2)
Define the linearization path for each trait/class shown in the above inheritance diagram.

L(Class_A) = (Class_A)
L(Trait_B) = (Trait_B -> Class_A)
L(Trait_C) = (Trait_C -> Trait_B -> Class_A)
L(Trait_D) = (Trait_D -> Class_A)

STEP 3)
USE THIS DECLARATION FROM THE CODE:  val myClass = new Class_A with Trait_D with Trait_C with Trait_B
Substitute values obtained in STEP 2) to obtain the linearization path.
OBTAIN LINEARIZATION PATH:  (Class_A) -> (Trait_D -> Class_A) -> (Trait_C -> Trait_B -> Class_A) -> (Trait_B -> Class_A)

STEP 4)
Reverse the order of the linearization path just obtained.  Like this:
(Trait_B -> Class_A) -> (Trait_C -> Trait_B -> Class_A) -> (Trait_D -> Class_A) -> (Class_A)

STEP 5)
Simplify the linearization path obtained in STEP 4) by removing all duplicate path names.
BEGIN WITH THE RIGHT-MOST ELEMENT (Class_A).  Keep the right-most element, and remove all
other duplicate references appearing to its left.  So we keep the right-most Class_A,
and remove all other Class_A references to its left, resulting in this:

(Trait_B) -> (Trait_C -> Trait_B) -> (Trait_D) -> (Class_A)

Repeat STEP 4) beginning with next right-most element (Trait_D), and remove
all Trait_D duplicates to its left.  No Trait_D duplicates exist, so the
linearization path remains unchanged:

(Trait_B) -> (Trait_C -> Trait_B) -> (Trait_D) -> (Class_A)

Repeat STEP 4) beginning with next right-most element (Trait_B), and remove
all Trait_B duplicates to its left, which results in this:

(Trait_C -> Trait_B) -> (Trait_D) -> (Class_A)

The linearization algorithm is done when there are no more
duplicate elements in the linearization path.  Remove the
parenthesis to obtain the final result:

FINAL LINEARIZATION PATH:  Trait_C -> Trait_B -> Trait_D -> Class_A

From this result we can determine that the println(myClass.info) statement
in the below code sample will print this:

Trait_C.info() called.
Trait_B.info() called.
Trait_D.info() called.
Class_A.info() called.

object Demo
{
  class Class_A {
    def info() = "Class_A.info() called."
  }

  trait Trait_B extends Class_A {
    override def info() = "Trait_B.info() called.\n" + super.info()
  }

  trait Trait_C extends Trait_B {
    override def info() = "Trait_C.info() called.\n" + super.info()
  }

  trait Trait_D extends Class_A {
    override def info() = "Trait_D.info() called.\n" + super.info()
  }

  def main(args: Array[String])
  {
    val myClass = new Class_A with Trait_D with Trait_C with Trait_B
    println(myClass.info) // PRINTS: Trait_C.info() called.
                          //         Trait_B.info() called.
                          //         Trait_D.info() called.
                          //         Class_A.info() called.
  }
}

===================================================================================================

The code sample below shows another example of multiple inheritance,
for which we determine the trait linearization path.


STEP 1)
Draw the inheritance diagram of the class/traits contained in the sample code's declaration.

                        -----------
                        | Trait_A |
                        -----------
                            |
                     ---------------
                     |             |
               -----------     -----------
               | Trait_B |     | Trait_C |
               -----------     -----------
                    |              |
                    ----------------
                           |
                     --------------
                     | Grandchild |
                     --------------


STEP 2)
Define the linearization path for each trait/class shown in the above inheritance diagram.

L(Trait_A)    = (Trait_A)
L(Trait_B)    = (Trait_B -> Trait_A)
L(Trait_C)    = (Trait_C -> Trait_A)

STEP 3)
USE THIS DECLARATION FROM THE CODE:  class GrandChild extends TraitB with TraitC
                                     val grandChild_1:GrandChild = new GrandChild
Substitute values obtained in STEP 2) to obtain the linearization path.
OBTAIN LINEARIZATION PATH:  (Trait_B -> Trait_A) -> (Trait_C -> Trait_A)

STEP 4)
Reverse the order of the linearization path just obtained.  Like this:
(Trait_C -> Trait_A) -> (Trait_B -> Trait_A)
 
 
STEP 5)
Simplify the linearization path obtained in STEP 4) by removing all duplicate path names.
BEGIN WITH THE RIGHT-MOST ELEMENT (Trait_A).  Keep the right-most element, and remove all
other duplicate references appearing to its left.  So we keep the right-most Trait_A,
and remove all other Trait_A references to its left, resulting in this:

(Trait_C) -> (Trait_B) -> Trait_A

The linearization algorithm is done when there are no more
duplicate elements in the linearization path.  Remove the
parenthesis to obtain the final result:

FINAL LINEARIZATION PATH:  Trait_C -> Trait_B -> Trait_A

From this result we can determine that the grandChild_1.name
statement in the below code sample will print this:

TraitC.name called.
TraitB.name called.
TraitA.name called.


object Demo
{
  trait TraitA {
    def name = println("TraitA.name called.")
  }

  trait TraitB extends TraitA {
    override def name = {
      println("TraitB.name called.")
      super.name
    }
  }

  trait TraitC extends TraitA {
    override def name = {
      println("TraitC.name called.")
      super.name
    }
  }

  def main(args: Array[String])
  {
    class GrandChild extends TraitB with TraitC
    val grandChild_1:GrandChild = new GrandChild
    grandChild_1.name // PRINTS: TraitC.name called.
                      //         TraitB.name called.
                      //         TraitA.name called.

    println("\n====================================\n")
    // Same thing as above, except when an object is instantiated,
    // the 'new' keyword isn't used.
    object grandChild_2 extends TraitB with TraitC
    grandChild_2.name // PRINTS: TraitC.name called.
                      //         TraitB.name called.
                      //         TraitA.name called.
  }
}

===================================================================================================

BELOW ARE SEVERAL MORE SAMPLE PROGRAMS USING TRAITS.
BELOW ARE SEVERAL MORE SAMPLE PROGRAMS USING TRAITS.
BELOW ARE SEVERAL MORE SAMPLE PROGRAMS USING TRAITS.

BELOW ARE SEVERAL MORE SAMPLE PROGRAMS USING TRAITS.
BELOW ARE SEVERAL MORE SAMPLE PROGRAMS USING TRAITS.
BELOW ARE SEVERAL MORE SAMPLE PROGRAMS USING TRAITS.

BELOW ARE SEVERAL MORE SAMPLE PROGRAMS USING TRAITS.
BELOW ARE SEVERAL MORE SAMPLE PROGRAMS USING TRAITS.
BELOW ARE SEVERAL MORE SAMPLE PROGRAMS USING TRAITS.


===================================================================================================

When a class extends another class/trait, the in-line code contained in each
class/trait gets executed upon instantiation of the base class.  The sample
code shown below reveals the execution order of this in-line code.

class Class_B extends Class_A with Trait_A with Trait_B
val classB:Class_B = new Class_B

When that code executes, the in-line code contained
in each class/trait is executed in this order:

1) Class_A in-line code executes.
2) Trait_A in-line code executes.
3) Trait_B in-line code executes.
4) Class_B in-line code executes.

Notice that this sample code performs multiple inheritance, and
Trait_A and Trait_B inherit from Class_A, but this sample code
does NOT contain a call to 'super'.  So when class_B.test()
is called below, it prints ONLY this line:  Trait_B.test() called.

Here is how Scala's Trait Linearization algorithm determines
that ONLY 

1) From the code, wee see that Class_B inherits from the following classes/traits.

   Class_B extends Class_A with Trait_A with Trait_B

2) Write the linearization path order of this declaration.

   L(Class_A = Class_A
   L(Trait_A) = (Trait_A -> Class_A)
   L(Trait_B) = (Trait_B -> Class_A)
   
   Class_A -> (Trait_A -> Class_A) -> (Trait_B -> Class_A)

3) Reverse the order, and remove parenthesis.

  (Trait_B -> Class_A) -> (Trait_A -> Class_A) -> Class_A
   Trait_B -> Class_A  ->  Trait_A -> Class_A  -> Class_A

4) Remove duplicates.

   FINAL LINEARIZATION PATH: Trait_B -> Trait_A -> Class_A

5) Because none of the test() methods call super.test() the
   only test() method that executes is THE FIRST ONE FOUND
   IN THE LINEARIZATION PATH, which is the Trait_B.test() method.
   So the call to classB.test(), prints:  Trait_B.test() called.

object Demo
{
  class Class_A
  {
    println("Class_A in-line code executes.")
    def test():Unit = println("Class_A.test() called.")
  }

  trait Trait_A extends Class_A
  {
    println("Trait_A in-line code executes.")
    override def test():Unit = println("Trait_A.test() called.")
  }
  trait Trait_B extends Class_A
  {
    println("Trait_B in-line code executes.")
    override def test():Unit = println("Trait_B.test() called.")
  }
  class Class_B extends Class_A with Trait_A with Trait_B
  {
    println("Class_B in-line code executes.")
  }

  def main(args: Array[String])
  {
    val classB:Class_B = new Class_B // PRINTS the following text:
                                     // Class_A in-line code executes.
                                     // Trait_A in-line code executes.
                                     // Trait_B in-line code executes.
                                     // Class_B in-line code executes.
    classB.test() // PRINTS: Trait_B.test() called.
  }
}

===================================================================================================

Notice the following sample code contains a method named test1() in Class_A,
Trait_A, and Trait_B, all having identical signatures.  The test1() methods
in Trait_A and Trait_B both override the Class_A.test1() method, and also
call super.test1(), which is the Class_A.test1() method.


classA.test1("YELLOW") // PRINTS: Class_A.test1() called.  color = BLUE
classA.test2("ORANGE") // PRINTS: Class_A.test2() called.  color = ORANGE

The reason classA.test1("YELLOW") prints the color BLUE instead of the color
YELLOW is because the first test1() method found is Trait_B.test1(), and
Trait_B.test1() calls Class_A.test1() with the color BLUE hard-coded.

object Demo
{
  class Class_A
  {
    println("Class_A in-line code executes.")
    def test1(color:String):Unit = println(s"Class_A.test1() called.  color = $color")
    def test2(color:String):Unit = println(s"Class_A.test2() called.  color = $color")
  }
  trait Trait_A extends Class_A
  {
    println("Trait_A in-line code executes.")
    override def test1(color:String):Unit = super.test1("GREEN")
  }
  trait Trait_B extends Class_A
  {
    println("Trait_B in-line code executes.")
    override def test1(color:String):Unit = super.test1("BLUE")
  }

  def main(args: Array[String])
  {
    val classA:Class_A = new Class_A with Trait_B with Trait_A // PRINTS: Class_A in-line code executes.
                                                               //         Trait_B in-line code executes.
                                                               //         Trait_A in-line code executes.
    classA.test1("YELLOW") // PRINTS: Class_A.test1() called.  color = BLUE
    classA.test2("ORANGE") // PRINTS: Class_A.test2() called.  color = ORANGE
  }
}

===================================================================================================

Using the Scala Trait Linearization Algorithm described above,
the following sample code has this trait linearization path:

Trait_B -> Trait_A -> Class_A

When Class_A.test("SILVER") is called in the following code sample,
this is what happens...

1) Trait_B.test("SILVER") gets called, which prints this text:  Trait_B.test(SILVER) called.
   Then super.test(color) calls Trait_A.test("SILVER").

2) Trait_A.test("SILVER") gets called, which prints this text:  Trait_A.test(SILVER) called.
   Then super.test(color) calls Class_A.test("SILVER").
   
3) Class_A.test("SILVER") gets called, which prints this text:  Class_A.test(SILVER) called.


object Demo
{
  class Class_A
  {
    println("Class_A in-line code executes.")
    def test(color:String):Unit = println(s"Class_A.test($color) called.")
  }
  trait Trait_A extends Class_A
  {
    println("Trait_A in-line code executes.")
    override def test(color:String):Unit = { println(s"Trait_A.test($color) called."); super.test(color) }
  }
  trait Trait_B extends Class_A
  {
    println("Trait_B in-line code executes.")
    override def test(color:String):Unit = { println(s"Trait_B.test($color) called."); super.test(color) }
  }

  def main(args: Array[String])
  {
    val classA:Class_A = new Class_A with Trait_A with Trait_B // PRINTS: Class_A in-line code executes.
                                                               //         Trait_A in-line code executes.
                                                               //         Trait_B in-line code executes.

    classA.test("SILVER") // PRINTS: Trait_B.test(SILVER) called.
                          //         Trait_A.test(SILVER) called.
                          //         Class_A.test(SILVER) called.
  }
}

========================================================================================

object Demo
{
  class Ball {
    def roll(ball : String): Unit = println("Rolling: " + ball)
  }

  trait Red extends Ball {
    override def roll(ball: String): Unit = super.roll("Red-" + ball)
  }

  trait Green extends Ball {
    override def roll(ball: String): Unit = super.roll("Green-" + ball)
  }

  trait Shiny extends Ball {
    override def roll(ball: String): Unit = super.roll("Shiny-" + ball)
  }

  def main(args: Array[String]):Unit = {
    val ball1 = new Ball() with Shiny with Red
    ball1.roll("Ball-1") // Rolling: Shiny-Red-Ball-1

    val ball2 = new Ball with Green with Shiny
    ball2.roll("Ball-2") // Rolling: Green-Shiny-Ball-2

    val ball3 = new Ball with Red with Shiny
    ball3.roll("Ball-3") // Rolling: Red-Shiny-Ball-3

    val ball4 = new Ball with Shiny with Green
    ball4.roll("Ball-4") // Rolling: Shiny-Green-Ball-4
  }
}
=====================================================================================

object Demo
{
  class Vehicle
  {
    def method:String= "Vehicle "
  }

  trait Bike extends Vehicle
  {
    override def method:String = "Bike -> "+ super.method
  }

  trait MuscleBike extends Vehicle
  {
    override def method:String = "Muscle Bike -> "+ super.method
  }

  trait Harley extends Vehicle
  {
    override def method:String ="Harley Davidson -> "+ super.method
  }

  class Iron1 extends Bike with MuscleBike with Harley
  {
    override def method:String = "Iron1 -> "+ super.method
  }

  class Iron2 extends Harley with MuscleBike with Bike
  {
    override def method:String = "Iron2 -> "+ super.method
  }

  def main(args: Array[String])
  {
    val myBike1:Iron1 = new Iron1
    println(myBike1.method)

    val myBike2:Iron2 = new Iron2
    println(myBike2.method)
  }
}

=====================================================================================

The following sample code does NOT deal with trait Linearization.
Just read the code and comments to understand it.

object Demo
{
  trait Equal {
    def isEqual(x: Any): Boolean
    def isNotEqual(x: Any): Boolean = !isEqual(x)
  }

  class Point(xc: Int, yc: Int) extends Equal {
    val x: Int = xc // This line executes ONLY when a Point class is instantiated.
    val y: Int = yc // This line executes ONLY when a Point class is instantiated.

    def isEqual(obj: Any):Boolean =
    {
      if (obj.isInstanceOf[Point] && obj.asInstanceOf[Point].x == xc && obj.asInstanceOf[Point].y == yc)
      {
        println("xc = " + xc + ",  yc = " + yc +
                "\nobj.asInstanceOf[Point].x = " + obj.asInstanceOf[Point].x + ",  obj.asInstanceOf[Point].y = " + obj.asInstanceOf[Point].y)
        true
      }
      else false
    }
  }

  def main(args: Array[String]) {
    val p1 = new Point(1, 2)
    val p2 = new Point(3, 4)
    val p3 = new Point(5, 6)
    val p4 = new Point(1, 2)

    println(p1.isEqual(p2)) // PRINTS: false
    println("--------------------------")
    println(p1.isEqual(p3)) // PRINTS: false
    println("--------------------------")
    println(p1.isEqual(p4)) // PRINTS: xc = 1,  yc = 2
                            //         obj.asInstanceOf[Point].x = 1,  obj.asInstanceOf[Point].y = 2
                            //         true
    println("--------------------------")
    println(p1.isNotEqual(p4)) // PRINTS: xc = 1,  yc = 2
                               //         obj.asInstanceOf[Point].x = 1,  obj.asInstanceOf[Point].y = 2
                               //         false
    println("--------------------------")
    println(p1.isNotEqual(1)) // PRINTS: true
  }
}

===================================================================

object Demo
{
  trait trait_A
  {
    println("trait_A constructed.")
    def func_A() = { println("trait_A.func_A() is called.") }
  }
  trait trait_B
  {
    println("trait_B constructed.")
    def func_B() = { println("trait_B.func_B() is called.") }
  }
  trait trait_C
  {
    println("trait_C constructed.")
    def func_C() = { println("trait_C.func_C() is called.") }
  }
  trait trait_D
  {
    println("trait_D constructed.")
    // def func_A() = { println("trait_D.func_A() is called.") }
    def func_D() = { println("trait_D.func_D() is called.") }
  }
  class class_1
  {
    println("class_1 constructed.")
  }
  class class_2 extends class_1 with trait_D  with trait_C  with trait_B  with trait_A
  {
    println("class_2 constructed.")
  }

  /**********************
   * main() function.
   *********************/
  def main(args: Array[String]):Unit =
  {
    val class_2:class_2 = new class_2()
    class_2.func_A()
  }
}

====================================================================

object Demo
{
  class class_A {
    println("class_A construted.")
    def func():String = "class_A"
  }

  trait trait_B extends class_A {
    println("trait_B construted.")
    override def func():String = "trait_B"
  }

  trait trait_C extends class_A {
    println("trait_C construted.")
    override def func():String = "trait_C"
  }

  trait trait_D extends class_A {
    println("trait_D construted.")
    override def func():String = "trait_D"
  }

  trait trait_B2 extends class_A {
    println("trait_B2 construted.")
    override def func():String = "trait_B2 " + super.func()
  }

  trait trait_C2 extends trait_B2 {
    println("trait_C2 construted.")
    override def func():String = "trait_C2 " + super.func()
  }

  trait trait_D2 extends class_A {
    println("trait_D2 construted.")
    override def func():String = "trait_D2 " + super.func()
  }

  /**********************
   * main() function.
   *********************/
  def main(args: Array[String]): Unit = {
    var classA:class_A = new class_A with trait_D with trait_C with trait_B
    println(classA.func()) // PRINTS: trait_B
    println("===========================")
    classA = new class_A with trait_D2 with trait_C2 with trait_B2
    println(classA.func()) // PRINTS: trait_C2 trait_B2 trait_D2 class_A
  }
}

==================================================================================

object Demo
{
  trait Trait_A
  {
    println("Trait_A constructed.")
    def func_A() = { println("Trait_A.func_A() is called.") }
  }
  trait Trait_B extends Trait_A
  {
    println("Trait_B constructed.")
    def func_B() = { println("Trait_B.func_B() is called.") }
  }
  trait Trait_C extends Trait_B
  {
    println("Trait_C constructed.")
    def func_C() = { println("Trait_C.func_C() is called.") }
    def func_D() = { println("Trait_C.func_D() is called.") }
  }
  trait Trait_D extends Trait_C
  {
    println("Trait_D constructed.")
  }
  class Class_1 extends Trait_D
  {
    println("Class_1 constructed.")
  }
  class Class_2
  {
    println("Class_2 constructed.")
    def func_A() = { println("Class_2.func_A() is called.") }
  }
  class Class_3 extends Class_2
  {
    println("Class_3 constructed.")
  }

  /**********************
   * main() function.
   *********************/
  def main(args: Array[String]):Unit =
  {
    println("=============================")
    val myClass_1:Class_1 = new Class_1()
    myClass_1.func_A()  // PRINTS: Trait_A.func_A() is called.
    myClass_1.func_B()  // PRINTS: Trait_B.func_B() is called.
    myClass_1.func_C()  // PRINTS: Trait_C.func_C() is called.
    myClass_1.func_D()  // PRINTS: Trait_D.func_D() is called.
    println("=============================")
    val myClass_3:Class_3 = new Class_3()
    // NOTE: When myClass_3.func_A() below executes, Class_2.func_A() gets called.
    myClass_3.func_A()  // PRINTS: Class_2.func_A() is called.
  }
}

==================================================================================
The following sample code shows the similarities and
differences of a Scala trait versus a Scala abstract class.

object Demo
{
  abstract class Person_Abstract_Class
  {
    val name:String
    val age:Int
    override def toString = s"name: $name, age: $age"
  }

  trait Person_Trait
  {
    def name:String // Equivalent to:  val name:String
    def age:Int     // Equivalent to:  val age:Int
    override def toString = s"name: $name, age: $age"
  }

  def main(args: Array[String]): Unit =
  {
    val tom_1:Person_Trait =  new Person_Trait {
      val name:String = "Tom"
      val age:Int = 63
    }
    println(tom_1) // PRINTS: name: Tom, age: 63

    val tom_2:Person_Abstract_Class = new Person_Abstract_Class {
      val name = "Tom_2"
      val age = 6363
    }
    println(tom_2) // PRINTS: name: Tom_2, age: 6363
   }
}

==========================================================================================

object Demo
{
  // THIS CODE DEMONSTRATES HOW TO USE A SCALA TRAIT
  trait Iterator[A]
  {
    // The following 2 functions (hasNext and next) are abstract because they're
    // NOT defined here, only declared.  Any class/trait that inherits from this
    // trait MUST define (implement) these 2 functions.
    def hasNext: Boolean // NOTE: The hasNext function is implemented in the below class that extends this trait.
    def next: A          // NOTE: The next    function is implemented in the below class that extends this trait.
  }

  /**
   *
   * @param maxIterIndex - This Int value designates the maximum upper limit of the iteration index.
   */
  class IntIterator(maxIterIndex: Int) extends Iterator[Int]
  {
    private var currentIterIndex:Int = 0  // NOTE: currentIterIndex is a var type!
    override def hasNext:Boolean = { currentIterIndex < maxIterIndex }
    override def next:Int =
    {
      if (hasNext)
      {
        val nextIterIndex:Int = currentIterIndex
        currentIterIndex += 1
        nextIterIndex
      }
      else { 0 } // Once the Iterator is "spent" this "else" statement (which returns zero) always executes.
    }
  }

  /**
   * @param args Arguments passed from the command line.
   */
  def main(args: Array[String])
  {
    val iterator:IntIterator = new IntIterator(10) // iterator is initialized to perform 10 iterations.

    // The following print statements collectively print this single line:
    // 0, 1, 2, 3, 4, 5, 6, 7, 8, true, 9, false, 0, 0, 0
    print(iterator.next + ", ") // PRINTS: 0
    print(iterator.next + ", ") // PRINTS: 1
    print(iterator.next + ", ") // PRINTS: 2
    print(iterator.next + ", ") // PRINTS: 3
    print(iterator.next + ", ") // PRINTS: 4
    print(iterator.next + ", ") // PRINTS: 5
    print(iterator.next + ", ") // PRINTS: 6
    print(iterator.next + ", ") // PRINTS: 7
    print(iterator.next + ", ") // PRINTS: 8
    // The following line returns true cuz the iterator is NOT yet spent.
    print(iterator.hasNext + ", ") // PRINTS: true
    print(iterator.next + ", ") // PRINTS: 9
    // The following line returns false cuz the iterator IS spent.
    print(iterator.hasNext + ", ") // PRINTS: false
    // The following 3 lines return 0 cuz the iterator IS spent.
    print(iterator.next + ", ") // PRINTS: 0
    print(iterator.next + ", ") // PRINTS: 0
    println(iterator.next)      // PRINTS: 0
  }
}

===========================================================================
Here's another sample program showing how to use Scala traits...

object Demo
{
  trait Drawable
  {
    def draw() { }
  }

  trait Cowboy extends Drawable
  {
    override def draw() = { println("BANG!  The Cowboy drew a gun.") }
  }

  trait Artist extends Drawable
  {
    override def draw() = { println("PICTURE!  The Artist drew a painting.") }
  }

  class ArtistCowboy extends Artist with Cowboy
  class CowboyArtist extends Cowboy with Artist

  def main(args: Array[String])
  {
    val artCow = new ArtistCowboy()
    val cowArt = new CowboyArtist()

    // For artCow, Scala searches for the draw() function first in the Cowboy trait, then
    // in the Artist trait.  The Cowboy.draw() function is found first, so it gets called.
    artCow.draw() // PRINTS:  BANG!  The Cowboy drew a gun.

    // For cowArt, Scala searches for the draw() function first in the Artist trait, then
    // in the Cowboy trait.  The Artist.draw() function is found first, so it gets called.
    cowArt.draw() // PRINTS:  PICTURE!  The Artist drew a painting.
  }
}

=======================================================================================

Rich Interface - A rich interface has many methods, which makes it convenient to use
                 because the caller is likely to find a method that exactly matches the
                 functionality she needs.

Thin Interface - A thin interface has fewer methods than a rich interface, so it's easier
                 for the programmer to write a thin interface than a rich interface.
                 However, the programmer who uses a thin interface will likely require
                 her to write more code because the thin interface supplies fewer methods
                 than the rich interface.

Traits can be used to enrich a thin interface, transforming it into a rich interface,
as is shown in the following example...

Look at the Point, Rectangle, and Component classes defined here.  Continue reading below.

class Point(val x: Int, val y: Int)
class Rectangle(val topLeft: Point, val bottomRight: Point)
{
  def left = topLeft.x
  def right = bottomRight.x
  def width = right - left
  // Assume more methods belong to this Rectangle class.
}
abstract class Component
{
  def topLeft: Point
  def bottomRight: Point

  def left = topLeft.x
  def right = bottomRight.x
  def width = right - left
  // Assume more methods belong to this abstract class Component.
}

Notice the left, right, and width methods defined above in the Rectangle class
are identical to the ones defined above in the abstract class Component.
These 3 methods will also likely reside in any other classes representing
rectangular objects.

This repetition can be eliminated with an enrichment trait shown immediately
below that's named Rectangular.  This Rectangular trait has two abstract
methods: one that returns the top-left coordinate of the object, and another
that returns the bottom-right coordinate.  It can then supply concrete
implementations of all the other geometric queries.

trait Rectangular
{
  def topLeft: Point
  def bottomRight: Point

  def left = topLeft.x
  def right = bottomRight.x
  def width = right - left
  // Assume more methods belong to this trait named Rectangular.
}

We can now redefine the above class Rectangle, and abstract class Component,
as follows.  This time, both classes are defined by extending the Rectangular
trait.  In other words, both these classes "mix-in" the Rectangular trait...

abstract class Component extends Rectangular
{
  // Assume more methods belong to this abstract class Component.
}
class Rectangle(val topLeft: Point, val bottomRight: Point) extends Rectangular
{
  // Assume more methods belong to this Rectangle class.
}
=======================================================================================
For more info on Scala Traits SEE P.463 of book, or the following web pages:
https://www.artima.com/pins1ed/traits.html
http://docs.scala-lang.org/tour/traits.html
