There are three ways to create a data type in Scala...

1) object
2) class
3) trait

NOTE: In the Scala API documentation...
      1) A circled 'c' represents a class
      2) A circled 'o' represents an object
      3) A circled 'p' represents a package
      4) A circled 't' represents a trait.

A Scala class, case class, or object, can extend no more than one class,
but they all can extend multiple traits.  A trait CAN'T extend a class
or an object, but a trait can extend multiple traits.

If you want to implement multiple inheritance, you must extend
at least one Scala trait.

REPEAT: To implement multiple inheritance requires that you extend
        a class, an object, or a trait with at lease one trait.

Traits look nearly the same as any other type of class.  However, just like
objects, traits CAN'T take parameters.  This is the syntax for defining a trait:

trait <identifier> [extends <identifier>] [{ fields, methods, and classes }]

Below are three (3) declarations that show how to extend traits.

// A CLASS that extends one class and multiple traits...
class Class_1 extends Class_2 with Trait_A with Trait_B { ... }

// A CLASS that extends no class and multiple traits...
class Class_1 extends Trait_A with Trait_B with Trait_C { ... }

// A TRAIT that extends multiple traits...
trait Trait_E extends trait_D with trait_C with trait_B with trait_A { ... }

NOTE: A trait CAN'T extend a class or an object.


QUESTION: When coding an abstract type that will be used with inheritance,
          should a "trait" or an "abstract class" be used?

ANSWER: The rule of thumb is to use a trait because it allows the flexibility
        of multiple inheritance.  While a trait cannot take arguments (as can
        an abstract class), any values that you'd want to provide as arguments
        can be put into a trait and left undefined, so the class that implements
        the trait will have to provide those values.

You might think that traits are like Java interfaces with concrete methods,
but they can actually do much more.  Traits can declare fields and maintain
state.  Scala traits and classes can often accomplish the same behavior.
Here are some differences between a Scala class and trait...

1) A class or object CAN be instantiated.
   A trait CAN'T be instantiated.

2) A trait CAN'T extend a class.
   A class CAN extend only one class, and any number of traits.
   A trait CAN extend no class, and any number of traits.

3) A trait CAN'T contain arguments/parameters like a class can.
   For example, you can define a class like below, which contains
   the arguments/parameters x and y...
   class Point(x: Int, y: Int) // Will compile

   The following attempt to define a trait WON'T compile
   because it contains arguments/parameters...
   trait Point(x: Int, y: Int) // Won't compile

4) A call to super() IN A CLASS is STATICALLY BOUND, which means when
   the super() method is invoked, the same method always gets called,
   regardless of conditions at runtime.

   A call to super() IN A TRAIT is DYNAMICALLY BOUND, which means
   when the super() method is invoked, the method that gets called
   is determined at runtime.


When implementing multiple inheritance, a function having the same name
and signature (args + return type) CAN'T exist in more than one class
or trait from which you inherit--unless the function inherits from
another class/trait having the same function name + signature,
and is defined using the "override" keyword.

Below is an example where the traits DON'T use inheritance.  The following
code will NOT compile because func_A() exists in BOTH trait_A and in trait_D.
To make the below code compile, COMMENT OUT ONE of those two func_A() definitions.
===================================================================
object Demo
{
  trait trait_A
  {
    println("trait_A constructed.")
    def func_A() = { println("trait_A.func_A() is called.") }
  }
  trait trait_B
  {
    println("trait_B constructed.")
    def func_B() = { println("trait_B.func_B() is called.") }
  }
  trait trait_C
  {
    println("trait_C constructed.")
    def func_C() = { println("trait_C.func_C() is called.") }
  }
  trait trait_D
  {
    println("trait_D constructed.")
    // def func_A() = { println("trait_D.func_A() is called.") }
    def func_D() = { println("trait_D.func_D() is called.") }
  }
  class class_1
  {
    println("class_1 constructed.")
  }
  class class_2 extends class_1 with trait_D  with trait_C  with trait_B  with trait_A
  {
    println("class_2 constructed.")
  }

  /**********************
   * main() function.
   *********************/
  def main(args: Array[String]):Unit =
  {
    val class_2:class_2 = new class_2()
    class_2.func_A()
  }
}
===================================================================


TRAIT METHOD RESOLUTION (LINEARIZATION) - Page 466
==================================================
Let's repeat these two (2) rules previously mentioned above,
which apply to Scala linearization...

1) A call to super() IN A CLASS is STATICALLY BOUND, which means when
   the super() method is invoked, the same method always gets called,
   regardless of conditions at runtime.

2) A call to super() IN A TRAIT is DYNAMICALLY BOUND, which means
   when the super() method is invoked, the method that gets called
   is determined at runtime.

Linearization is the process Scala uses to determine which trait
method is called when a trait method calls the super() method.

VERY IMPORTANT: Linearization applies only to trait methods that
                call the super() method.  A trait can call the
                super() method ONLY IF:

                1) The trait extends another trait.
                ...AND...
                2) The trait method calling super() overrides the
                   method (having identical name and signature)
                   in the extended trait.  Here's a code example:
===================================================================
object Demo
{
  class Ball {
    def roll(ball : String): Unit = println("Rolling : " + ball)
  }

  trait Red extends Ball {
    override def roll(ball : String): Unit = super.roll("Red-" + ball)
  }

  trait Green extends Ball {
    override def roll(ball : String): Unit = super.roll("Green-" + ball)
  }

  trait Shiny extends Ball {
    override def roll(ball : String): Unit = super.roll("Shiny-" + ball)
  }

  def main(args: Array[String]):Unit = {
    val ball1 = new Ball with Shiny with Red
    ball1.roll("Ball-1") // Rolling : Shiny-Red-Ball-1

    val ball2 = new Ball with Green with Shiny
    ball2.roll("Ball-2") // Rolling : Green-Shiny-Ball-2
  }
}
===================================================================

Run the sample program shown further below and notice the following.

When this line is executed:  var classA:class_A = new class_A with trait_D with trait_C with trait_B
This text is printed:  class_A construted.
                       trait_D construted.
                       trait_C construted.
                       trait_B construted.

When this line is executed:  classA = new class_A with trait_D2 with trait_C2 with trait_B2
This text is printed:  class_A construted.
                       trait_D2 construted.
                       trait_B2 construted.
                       trait_C2 construted.

The printed text that results from executing those two lines of code
reveals the order in which the classes and traits are constructed.
The order in which the classes/traits are constructed is ALWAYS IDENTICAL
to the order they appear in the declaration, from left to right.

The order in which linearization occurs (to determine which method(s) get called)
is THE REVERSE ORDER that the classes/traits and are constructed, which is
the right-to-left order of the classes/traits as they appear in the declaration.

Because Scala's linearization algorithm is too complicated to easily explain
verbally, its instead explained by the following 5-step process.

====================================================================

In the sample code below, these 2 lines exist in the main() method:
var classA:class_A = new class_A with trait_D with trait_C with trait_B
println(classA.func())

Following the 5 steps below will show us how to determine what
text gets printed by println(classA.func())

1) LOOKING AT THE SAMPLE CODE BELOW, draw a hierarchy diagram of the
   classes and traits referenced in this declaration:
   var classA:class_A = new class_A with trait_D with trait_C with trait_B

       class_A
         |
     -------------------
     |        |        |
  trait_B  trait_C  trait_D

2) Specify the linearization path for each class/trait in the diagram,
   where the letter L designates Linearization.

   L(class_A) = class_A
   L(trait_B) = trait_B -> class_A
   L(trait_C) = trait_C -> class_A
   L(trait_D) = trait_D -> class_A

3) Following the RIGHT-TO-LEFT order of the following declaration,
   specify the order in which Scala will perform linearization.
   var classA:class_A = new class_A with trait_D with trait_C with trait_B

   L(trait_B) -> L(trait_C) -> L(trait_D) -> L(class_A)

4) Rewrite the linearization sequence obtained in step 3) by substituting
   what we obtained in step 2) for L(class_A), L(trait_B), etc.

   (trait_B -> class_A) -> (trait_C -> class_A) -> (trait_D -> class_A) -> (class_A)

5) Copy the linearization sequence obtained in step 4) from RIGHT TO LEFT
   but DON'T COPY DUPLICATES.  For example, class_A is the first element we
   copy (from right to left), so all other references to class_A are NOT copied.

   FINAL LINEARIZATION RESULT:
   class_A -> trait_D -> trait_C -> trait_B

   From this result we can determine that println(classA.func())
   prints this line of text:   trait_B

====================================================================

In the sample code below, these 2 lines exist in the main() method:
classA = new class_A with trait_D2 with trait_C2 with trait_B2
println(classA.func())

Following the 5 steps below will show us how to determine what
text gets printed by println(classA.func())

1) LOOKING AT THE SAMPLE CODE BELOW, draw a hierarchy diagram of the
   classes and traits referenced in this declaration:
   classA = new class_A with trait_D2 with trait_C2 with trait_B2

       class_A
         |
     ---------
     |       |
  trait_B2  trait_D2
     |
  trait_C2

2) Specify the linearization path for each class/trait in the diagram,
   where the letter L designates Linearization.

   L(class_A) = class_A
   L(trait_B2) = trait_B2 -> class_A
   L(trait_C2) = trait_C2 -> trait_B2 -> class_A
   L(trait_D2) = trait_D2 -> class_A

3) Following the RIGHT-TO-LEFT order of the following declaration,
   specify the order in which Scala will perform linearization.
   classA = new class_A with trait_D2 with trait_C2 with trait_B2

   L(trait_B2) -> L(trait_C2) -> L(trait_D2) -> L(class_A)

4) Rewrite the linearization sequence obtained in step 3) by substituting
   what we obtained in step 2) for L(trait_A), L(trait_B2), etc.

   (trait_B2 -> class_A) -> (trait_C2 -> trait_B2 -> class_A) -> (trait_D2 -> class_A) -> (class_A)

5) Copy the linearization sequence obtained in step 4) from RIGHT TO LEFT
   but DON'T COPY DUPLICATES.  For example, class_A is the first element we
   copy (from right to left), so all other references to class_A are NOT copied.

   FINAL LINEARIZATION RESULT:
   trait_C2 -> trait_B2 -> trait_D2 -> class_A

   From this result we can determine that println(classA.func())
   prints this line of text:  trait_C2 trait_B2 trait_D2 class_A

====================================================================











1) Class_1 (the base class) is searched for func_A().
2) The highest-to-lowest superclass of Class_2 is searched for func_A().
3) Class_2 (the extended class) is searched for func_A().
4) The highest-to-lowest superclass of Trait_C is searched for func_A().
5) The highest-to-lowest superclass of Trait_B is searched for func_A().
6) The highest-to-lowest superclass of Trait_A is searched for func_A().
7) Trait_C is searched for func_A().
8) Trait_B is searched for func_A().
9) Trait_A is searched for func_A().

Also see -->  https://stackoverflow.com/questions/34242536/linearization-order-in-scala
====================================================================
object Demo
{
  class class_A {
    println("class_A construted.")
    def func():String = "class_A"
  }

  trait trait_B extends class_A {
    println("trait_B construted.")
    override def func():String = "trait_B"
  }

  trait trait_C extends class_A {
    println("trait_C construted.")
    override def func():String = "trait_C"
  }

  trait trait_D extends class_A {
    println("trait_D construted.")
    override def func():String = "trait_D"
  }

  trait trait_B2 extends class_A {
    println("trait_B2 construted.")
    override def func():String = "trait_B2 " + super.func()
  }

  trait trait_C2 extends trait_B2 {
    println("trait_C2 construted.")
    override def func():String = "trait_C2 " + super.func()
  }

  trait trait_D2 extends class_A {
    println("trait_D2 construted.")
    override def func():String = "trait_D2 " + super.func()
  }

  /**********************
   * main() function.
   *********************/
  def main(args: Array[String]): Unit = {
    var classA:class_A = new class_A with trait_D with trait_C with trait_B
    println(classA.func()) // PRINTS: trait_B
    println("===========================")
    classA = new class_A with trait_D2 with trait_C2 with trait_B2
    println(classA.func()) // PRINTS: trait_C2 trait_B2 trait_D2 class_A
  }
}

===================================================================


It's possible for a function having the same name and signature
to be defined in multiple Scala classes and traits.  Assume a
Scala base class named Class_1 has this definition:

class Class_1 extends Class_2 with Trait_A with Trait_B with Trait_C

Also assume a function named func_A() is defined in many of those classes
and traits, and all those func_A definitions have identical signatures
(args and return type).  When Class_1.func_A() gets called, this is the
order Scala searches to determine which func_A() gets invoked:

1) Class_1 (the base class) is searched for func_A().
2) The highest-to-lowest superclass of Class_2 is searched for func_A().
3) Class_2 (the extended class) is searched for func_A().
4) The highest-to-lowest superclass of Trait_C is searched for func_A().
5) The highest-to-lowest superclass of Trait_B is searched for func_A().
6) The highest-to-lowest superclass of Trait_A is searched for func_A().
7) Trait_C is searched for func_A().
8) Trait_B is searched for func_A().
9) Trait_A is searched for func_A().

THE FIRST INSTANCE OF func_A() FOUND IS THE FUNCTION THAT GETS INVOKED.
This process of resolving which function gets invoked is called LINEARIZATION.

Below is sample code showing which function gets invoked via Scala's LINEARIZATION process.
==================================================================================

object Demo
{
  trait Trait_A
  {
    println("Trait_A constructed.")
    def func_A() = { println("Trait_A.func_A() is called.") }
  }
  trait Trait_B extends Trait_A
  {
    println("Trait_B constructed.")
    def func_B() = { println("Trait_B.func_B() is called.") }
  }
  trait Trait_C extends Trait_B
  {
    println("Trait_C constructed.")
    def func_C() = { println("Trait_C.func_C() is called.") }
    def func_D() = { println("Trait_C.func_D() is called.") }
  }
  trait Trait_D extends Trait_C
  {
    println("Trait_D constructed.")
  }
  class Class_1 extends Trait_D
  {
    println("Class_1 constructed.")
  }
  class Class_2
  {
    println("Class_2 constructed.")
    def func_A() = { println("Class_2.func_A() is called.") }
  }
  class Class_3 extends Class_2
  {
    println("Class_3 constructed.")
  }

  /**********************
   * main() function.
   *********************/
  def main(args: Array[String]):Unit =
  {
    println("=============================")
    val myClass_1:Class_1 = new Class_1()
    myClass_1.func_A()  // PRINTS: Trait_A.func_A() is called.
    myClass_1.func_B()  // PRINTS: Trait_B.func_B() is called.
    myClass_1.func_C()  // PRINTS: Trait_C.func_C() is called.
    myClass_1.func_D()  // PRINTS: Trait_D.func_D() is called.
    println("=============================")
    val myClass_3:Class_3 = new Class_3()
    // NOTE: When myClass_3.func_A() below executes, Class_2.func_A() gets called.
    myClass_3.func_A()  // PRINTS: Class_2.func_A() is called.
  }
}

==================================================================================
The following sample code shows the similarities and
differences of a Scala trait versus a Scala abstract class.

object Demo
{
  abstract class Person_Abstract_Class
  {
    val name:String
    val age:Int
    override def toString = s"name: $name, age: $age"
  }

  trait Person_Trait
  {
    def name:String // Equivalent to:  val name:String
    def age:Int     // Equivalent to:  val age:Int
    override def toString = s"name: $name, age: $age"
  }

  def main(args: Array[String]): Unit =
  {
    val tom_1:Person_Trait =  new Person_Trait {
      val name:String = "Tom"
      val age:Int = 63
    }
    println(tom_1) // PRINTS: name: Tom, age: 63

    val tom_2:Person_Abstract_Class = new Person_Abstract_Class {
      val name = "Tom_2"
      val age = 6363
    }
    println(tom_2) // PRINTS: name: Tom_2, age: 6363
   }
}

==================================================================================
If a trait contains a member function that IS defined, that member method is concrete.
If a trait contains a member value that IS initialized, that member value is concrete.
If a trait contains a member function that is NOT defined, that member method is abstract.
If a trait contains a member value that is NOT initialized, that member value is abstract.

A trait is very similar to an abstract class in many ways.
When a class extends a trait that has an abstract method
(a method that's declared, but not defined), each abstract
method contained in the trait must be defined in the
in the class that extends the trait!!!  Here's an example:

trait Pet
{
   def speak() { println("Bow-Wow") } // speak() is DEFINED, which means it's a CONCRETE method.
   def comeToMaster(): Unit           // comeToMaster() is UNDEFINED, which means it's an ABSTRACT  method.
}
class Dog(name: String) extends Pet
{
   // Because Dog extends the trait Pet, and Pet contains an ABSTRACT method,
   // the ABSTRACT method comeToMaster() MUST be defined in this Dog class...
   def comeToMaster(): Unit = { println("Woo-hoo, I'm coming!") }
}

A class that extends a trait can override a trait's defined method
by redefining the trait's method inside the class, like this:

class Cat extends Pet
{
   // The following speak() method overrides the trait's speak() method
   // defined in the above example...
   override def speak(): Unit = { println("Meow") }
   def comeToMaster(): Unit   = { println("That's not gonna happen.") }
}

==========================================================================================

object Demo
{
  // THIS CODE DEMONSTRATES HOW TO USE A SCALA TRAIT
  trait Iterator[A]
  {
    // The following 2 functions (hasNext and next) are abstract because they're
    // NOT defined here, only declared.  Any class/trait that inherits from this
    // trait MUST define (implement) these 2 functions.
    def hasNext: Boolean // NOTE: The hasNext function is implemented in the below class that extends this trait.
    def next: A          // NOTE: The next    function is implemented in the below class that extends this trait.
  }

  /**
   *
   * @param maxIterIndex - This Int value designates the maximum upper limit of the iteration index.
   */
  class IntIterator(maxIterIndex: Int) extends Iterator[Int]
  {
    private var currentIterIndex:Int = 0  // NOTE: currentIterIndex is a var type!
    override def hasNext:Boolean = { currentIterIndex < maxIterIndex }
    override def next:Int =
    {
      if (hasNext)
      {
        val nextIterIndex:Int = currentIterIndex
        currentIterIndex += 1
        nextIterIndex
      }
      else { 0 } // Once the Iterator is "spent" this "else" statement (which returns zero) always executes.
    }
  }

  /**
   * @param args Arguments passed from the command line.
   */
  def main(args: Array[String])
  {
    val iterator:IntIterator = new IntIterator(10) // iterator is initialized to perform 10 iterations.

    // The following print statements collectively print this single line:
    // 0, 1, 2, 3, 4, 5, 6, 7, 8, true, 9, false, 0, 0, 0
    print(iterator.next + ", ") // PRINTS: 0
    print(iterator.next + ", ") // PRINTS: 1
    print(iterator.next + ", ") // PRINTS: 2
    print(iterator.next + ", ") // PRINTS: 3
    print(iterator.next + ", ") // PRINTS: 4
    print(iterator.next + ", ") // PRINTS: 5
    print(iterator.next + ", ") // PRINTS: 6
    print(iterator.next + ", ") // PRINTS: 7
    print(iterator.next + ", ") // PRINTS: 8
    // The following line returns true cuz the iterator is NOT yet spent.
    print(iterator.hasNext + ", ") // PRINTS: true
    print(iterator.next + ", ") // PRINTS: 9
    // The following line returns false cuz the iterator IS spent.
    print(iterator.hasNext + ", ") // PRINTS: false
    // The following 3 lines return 0 cuz the iterator IS spent.
    print(iterator.next + ", ") // PRINTS: 0
    print(iterator.next + ", ") // PRINTS: 0
    println(iterator.next)      // PRINTS: 0
  }
}

===========================================================================
Here's another sample program showing how to use Scala traits...

object Demo
{
  trait Drawable
  {
    def draw() { }
  }

  trait Cowboy extends Drawable
  {
    override def draw() = { println("BANG!  The Cowboy drew a gun.") }
  }

  trait Artist extends Drawable
  {
    override def draw() = { println("PICTURE!  The Artist drew a painting.") }
  }

  class ArtistCowboy extends Artist with Cowboy
  class CowboyArtist extends Cowboy with Artist

  def main(args: Array[String])
  {
    val artCow = new ArtistCowboy()
    val cowArt = new CowboyArtist()

    // For artCow, Scala searches for the draw() function first in the Cowboy trait, then
    // in the Artist trait.  The Cowboy.draw() function is found first, so it gets called.
    artCow.draw() // PRINTS:  BANG!  The Cowboy drew a gun.

    // For cowArt, Scala searches for the draw() function first in the Artist trait, then
    // in the Cowboy trait.  The Artist.draw() function is found first, so it gets called.
    cowArt.draw() // PRINTS:  PICTURE!  The Artist drew a painting.
  }
}

=======================================================================================
Here's another sample program showing how to use Scala traits...

object Demo
{
  trait Pet
  {
    def speak:Unit = { println("I speak the universal Pet language.") } // concrete implementation of speak() method.
    def comeToMaster:Unit  // abstract implementation of comeToMaster() method.
  }

  class Dog extends Pet
  {
    def comeToMaster:Unit = { println("I'm a Dog, so I come when called.") }
  }

  class Cat extends Pet
  {
    override def speak:Unit = { println("MEOW") } // The override key word is required here.
    def comeToMaster:Unit   = { println("I'm a Cat, so I don't follow orders.") }
  }

  def main(args: Array[String])
  {
    val catPet:Cat = new Cat()
    catPet.speak        // PRINTS: MEOW
    catPet.comeToMaster // PRINTS: I'm a Cat, so I don't follow orders.

    val dogPet:Dog = new Dog()
    dogPet.speak        // PRINTS: I speak the universal Pet language.
    dogPet.comeToMaster // PRINTS: I'm a Dog, so I come when called.
  }
}

=======================================================================================
Rich Interface - A rich interface has many methods, which makes it convenient to use
                 because the caller is likely to find a method that exactly matches the
                 functionality she needs.

Thin Interface - A thin interface has fewer methods than a rich interface, so it's easier
                 for the programmer to write a thin interface than a rich interface.
                 However, the programmer who uses a thin interface will likely require
                 her to write more code because the thin interface supplies fewer methods
                 than the rich interface.

Traits can be used to enrich a thin interface, transforming it into a rich interface,
as is shown in the following example...

Look at the Point, Rectangle, and Component classes defined here.  Continue reading below.

class Point(val x: Int, val y: Int)
class Rectangle(val topLeft: Point, val bottomRight: Point)
{
  def left = topLeft.x
  def right = bottomRight.x
  def width = right - left
  // Assume more methods belong to this Rectangle class.
}
abstract class Component
{
  def topLeft: Point
  def bottomRight: Point

  def left = topLeft.x
  def right = bottomRight.x
  def width = right - left
  // Assume more methods belong to this abstract class Component.
}

Notice the left, right, and width methods defined above in the Rectangle class
are identical to the ones defined above in the abstract class Component.
These 3 methods will also likely reside in any other classes representing
rectangular objects.

This repetition can be eliminated with an enrichment trait shown immediately
below that's named Rectangular.  This Rectangular trait has two abstract
methods: one that returns the top-left coordinate of the object, and another
that returns the bottom-right coordinate.  It can then supply concrete
implementations of all the other geometric queries.

trait Rectangular
{
  def topLeft: Point
  def bottomRight: Point

  def left = topLeft.x
  def right = bottomRight.x
  def width = right - left
  // Assume more methods belong to this trait named Rectangular.
}

We can now redefine the above class Rectangle, and abstract class Component,
as follows.  This time, both classes are defined by extending the Rectangular
trait.  In other words, both these classes "mix-in" the Rectangular trait...

abstract class Component extends Rectangular
{
  // Assume more methods belong to this abstract class Component.
}
class Rectangle(val topLeft: Point, val bottomRight: Point) extends Rectangular
{
  // Assume more methods belong to this Rectangle class.
}
=======================================================================================
For more info on Scala Traits SEE P.463 of book, or the following web pages:
https://www.artima.com/pins1ed/traits.html
http://docs.scala-lang.org/tour/traits.html

