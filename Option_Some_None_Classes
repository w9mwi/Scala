 Instead of returning an object when a function succeeds,
 and null when it fails, your function can instead return
 an instance of the "Option" class, where the "Option"
 object will in reality be a "None" object or a "Some"
 object.
 
 NOTE: Both the "Some" class and the "None" class are
       children of the "Option" class.

Your function signature should declare that you're returning
an "Option" that will be some data type, such as an Int, which
is shown in the example below.  Declaring that the function
returns an "Option" object lets the user of your function know
whatâ€™s going on.  You should use an "Option" type when you are
not certain if you will have a value or not.

The find method on a sequence (i.e., Array, List, etc.) returns
an "Option" type of "None" when a value cannot be found.  EXAMPLE:

val intList:List[Int] = List[Int](7, 4, 6, 3, 9, 1)
var result:Option[Int] = intList.find(_<4)
println(result) // Prints: Some(3)
result = intList.find(_>10)
println(result) // Prints: None

By having your function return a "Some" object (for a valid value),
or a "None" object (for an invalid value), means the user of the
function doesn't need to check for a null value in order to prevent
a NullPointerException.

In the following example, the convertToInt() function is declared
to return an "Option" object.  However, in reality, it will return
either a "None" object (if the String can't be converted to an Int),
or a "Some" object (if the String can be converted to an Int), as
both "None" and "Some" are child classes of the "Option" class.
=============================================================
object Demo
{
  def main(args: Array[String]):Unit =
  {
    // Test the convertToInt() function with a String that DOES convert to a valid Int value...
    val test1:Option[Int] = convertToInt("123");
    println("test1 = " + test1) // Prints: test1 = Some(123)

    // Test the convertToInt() function with a String that does NOT convert to a valid Int value...
    val test2:Option[Int] = convertToInt("9X7");
    println("test2 = " + test2) // Prints: test2 = None

    // Create a List of strings containing valid and invalid Int values...
    val stringList:List[String] = List[String]("1", "2", "junk", "3", "trash")
    println("stringList = " + stringList) // Prints: stringList = List(1, 2, junk, 3, trash)

    // Convert ONLY the Int values in stringList to a List of Int values...
    val intList:List[Int] = stringList.flatMap(convertToInt)
    println("intList = " + intList) // Prints: intList = List(1, 2, 3)

    // Sum all the values in intList...
    val sum:Int = intList.sum
    println("sum = " + sum) // Prints: sum = 6
  }

  /**
    * Convert the String passed to this function to an Int value, and
    * return it as an "Option" object.  If the String CAN'T be converted
    * to a valid Int value, the "catch" block below is entered and a
    * "None" object gets returned.  If the String CAN be converted to
    * a valid Int value, the code below returns a "Some" object.
    * NOTE:  Both "None" and "Some" classes are children
    *        of the Option class
    *
    * @param str - A String that represents an Int value.
    * @return a Some or None object.
    */
  def convertToInt(str: String): Option[Int] =
  {
    try
    {
      Some(Integer.parseInt(str.trim)) // Return a Some object.
    }
    catch
    {
      case e: NumberFormatException => None // Return a None object.
    }
  }
}
================================================================
The following example of using Option/Some/None is virtually the
same as the above example, but uses the get() method called on
the Option class.
================================================================
object Demo
{
  def printNumber(number:Option[Int]):Unit =
  {
    if (number == None)  { println("The number is not valid.")}
    else                 { println("number = " + number.get) }
  }

  def convertStringToInt(str:String):Option[Int] =
  {
    try
    {
      Some(str.trim.toInt)  // EQUIVALENT TO THIS LINE OF CODE:  Some(Integer.parseInt(str.trim))
    }
    catch
    {
      case ex:Exception => None
    }
  }

  def main(args:Array[String]): Unit =
  {
    val validStringNumber   = "123456";
    val invalidStringNumber = "12345X";
    var intNumber:Option[Int] = convertStringToInt(validStringNumber)
    printNumber(intNumber)

    intNumber = convertStringToInt(invalidStringNumber)
    printNumber(intNumber)
  }
}
================================================================
The following example of using Option/Some/None is virtually the
same as the two examples above, but uses thematch keyword.
================================================================
object Demo
{
  def convertStringToInt(str:String):Option[Int] =
  {
    try
    {
      Some(str.trim.toInt)  // EQUIVALENT TO THIS LINE OF CODE:  Some(Integer.parseInt(str.trim))
    }
    catch
    {
      case ex:Exception => None
    }
  }

  def printNumber(strNumber:Option[Int]):Unit =
  {
    strNumber match
    {
      case Some(strNumber) => println ("number = " + strNumber)
      case None            => println ("The number is not valid.")
    }
  }

  def main(args:Array[String]): Unit =
  {
    val validStringNumber:String   = "123456";
    val invalidStringNumber:String = "12345X";
    var intNumber:Option[Int] = convertStringToInt(validStringNumber)
    printNumber(intNumber) // PRINTS: number = 123456

    intNumber = convertStringToInt(invalidStringNumber)
    printNumber(intNumber) // PRINTS: The number is not valid.
  }
}
=============================================================
object Demo
{
  def main(args: Array[String]) =
  {
    val intList:List[Int] = List[Int](7, 4, 6, 3, 9, 1)
    var result:Option[Int] = intList.find(_<6) // Return 1st element in the List that's < 6.
    result.foreach(println) // Prints: 4
    println(result) // Prints: Some(4)
    result = intList.find(_>10) // Return 1st element in the List that's > 10, of which there are none!
    println(result) // Prints: The result var has been assigned the None object, so "None" is printed.
  }
}
============================================================
============================================================
object Demo
{
  /**
    * This ListStack class uses the Scala List type as a FIFO stack.
    */
  class ListStack
  {
    // ONLY when this ListStack class is instantiated does the following
    // private var stack get declared and initialized.  It's effectively
    // all of the "constructor" code that exists in this class.
    private var stack:List[Int] = Nil; // NOTE: Nil is the same as List()--they're both an empty List.

    /**
      * Pops an item off the stack.
      * @return the None Option type if the stack is empty;
      *         otherwise, return the Some Option type which includes the value.
      */
    def pop():Option[Int] =
    {
      if (stack.isEmpty)
      {
        None
      }
      else
      {
        val result = stack.head
        stack = stack.tail
        Some(result)
      }
    }

    /**
      * Pushes an item onto the stack.
      * @param value the value pushed onto the stack.
      */
    def push(value:Int):Unit =
    {
      stack = value :: stack
    }
  }

  /**
    * This main() function demonstrates using the ListStack class defined above,
    * as well as the Option, Some, and None Scala types.
    * @param args
    */
  def main(args: Array[String]) =
  {
    val tom = new ListStack() // Instantiate a ListStack class.

    // Push multiple items onto the ListStack...
    tom.push(1); tom.push(2); tom.push(3); tom.push(4); tom.push(5);
    tom.push(6); tom.push(7); tom.push(8); tom.push(9); tom.push(10);

    // Pop every item off the ListStack, and print it.  If the ListStack
    // is empty (because no item was pushed onto it), the following while()
    // loop will detect that, and nothing will print.
    var result:Option[Int] = tom.pop // Pop the first item off the ListStack.
    while (result != None)
    {
      // If this code executes, result is not of the None type, so it's therefore of the Some type.
      print(result.get + "  ") // The get method obtains the literal value popped off the ListStack.
      result = tom.pop         // Pop the next item off the ListStack.
    }
  }
}
