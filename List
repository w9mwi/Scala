==================================================================================
NOTE: The Scala Vector class is the recommended “go to” class for
      IMMUTABLE, INDEXED SEQUENTIAL collections.

NOTE: The Scala ArrayBuffer class is the recommended “go to” class for
      MUTABLE, INDEXED SEQUENTIAL collections.  ArrayBuffer is an indexed,
      sequential collection.  Use ListBuffer if you prefer a linear,
      sequential collection that is MUTABLE.

Use of List is very common in Scala, but it can sometimes be inefficient
for random access because the time complexity of accessing an element is
O(n). Scala provides an alternative collection, Vector, that is optimized
for random access by storing its elements in a tree structure that has
little memory overhead.  All operations on a Vector happen in effectively
constant time, which means that for large collections it can be significantly
more efficient than List.

Scala Vectors are very similar to Scala Lists.  If you only need to process the head
of a List, then use a List.  But if you need to access elements within the List,
as well as process the List's head, use a Vector because accessing indexed elements
in a Vector is more efficient than accessing indexed elements in a List.

A Scala Vector is immutable, whereas a Scala Array is mutable.
A Scala List can be mutable or immutable.

==================================================================================

In Scala, Lists are SEQUENCES, which means data is stored
in elements that can be accessed via a sequential Integer
index.  The following line of code creates a List of 3
integers that's initialized to the values of 1, 2 and 3.

val myList:List[Int] = List[Int](1, 2, 3)

The square brackets '[]' in the above code indicates that the
List is a paramaterized type.  In the above example, this
paramaterized type is declared to be of type Int.  Like the
above line of code, the following line of code also creates
a List of 3 integers that's initialized to the values of
1, 2 and 3.

var myList = List(1, 2, 3)

Even though the above myList is declared as a var, we can't change the
values contained in each List element.  A List in Scala is IMMUTABLE
by default, which means a List's element values can never be altered,
even if it's a var.  (It is possible to declare a List as mutable
instead of immutable via an import statement.)  The var indicates
that myList can be used to point to a different List.  For example,
you can do the following:

var myList = List(1, 2, 3);
myList = List(9, 8, 7);  // Allowed because myList is a var.

Unlike Arrays, Lists cannot be multi-dimensional.  You can PREPEND
values to an existing var List by using the cons operator (::).
Note that this can be done only with a var List, not a val List.
Prepending a value to a List literally creates a new List as
shown in the example immediately below.

var myList = List(1, 2, 3);
myList = 0::myList
myList.foreach(println)

You can combine two Lists into one List by using the List
append operator, which consists of 3 colon characters (:::),
as shown in the example immediately below.

val list_1:List[Int] = List(1, 22, 333)
val list_2:List[Int] = List(7, 88, 999)
val list_result:List[Int] = list_1 ::: list_2
println(list_result)  // PRINTS: List(1, 22, 333, 7, 88, 999)

Since all Lists (including empty lists) end with a Nil value, you
cannot append values to an existing List, even if it's a var List.
The following example shows us that an empty List contains a single
Nil value.  We can detect that a List is empty by checking to see
if the List == Nil, or by calling the isEmpty method, which is preferable.

val myList = List()
if (myList == Nil)
{
  println("myList == Nil")
}
if (myList.isEmpty)
{
  println("myList is empty.")
}
========================================================================
object Demo
{
  def main(args: Array[String])
  {
    val myList1: List[Int] = List(999)
    println("myList1.head = " + myList1.head) // PRINTS: myList1.head = 999
    println("myList1.tail = " + myList1.tail) // PRINTS: myList1.tail = List()

    // The following commented-out line would not compile if you tried,
    // because every List ends with an empty List (a Nil), and the cons
    // operator (::) requires the first operand to be a value, NOT a List.
    // val myList2:List[Int] = myList1 :: List(333, 666)
    val myList2: List[Int] = myList1 ::: List(333, 666)
    println("myList2.head = " + myList1.head) // PRINTS: myList2.head = 999
    println("myList2.tail = " + myList2.tail) // PRINTS: myList2.tail = List(333, 666)
    println("myList2(1) = " + myList2(1))     // PRINTS: myList2(1) = 333
    println("myList2(2) = " + myList2(2))     // PRINTS: myList2(2) = 666
  }
}
========================================================================
// THE FOLLOWING CODE IS IDENTICAL TO THE CODE IMMEDIATELY ABOVE, EXCEPT
// IT USES VECTORS INSTEAD OF LISTS, AND VECTORS DO NOT WORK WITH THE
// :: AND ::: OPERATORS AS LISTS DO.
object Demo
{
  def main(args: Array[String])
  {
    val myVector1: Vector[Int] = Vector(999)
    println("myVector1.head = " + myVector1.head) // PRINTS: myVector1.head = 999
    println("myVector1.tail = " + myVector1.tail) // PRINTS: myVector1.tail = Vector()

    val myVector2: Vector[Int] = Vector(333, 666, 999)
    println("myVector2.head = " + myVector1.head) // PRINTS: myVector2.head = 999
    println("myVector2.tail = " + myVector2.tail) // PRINTS: myVector2.tail = Vector(333, 666)
    println("myVector2(1) = " + myVector2(1))     // PRINTS: myVector2(1) = 333
    println("myVector2(2) = " + myVector2(2))     // PRINTS: myVector2(2) = 666
  }
}
========================================================================
When using Scala Lists, you will very frequently call the List head()
and tail() methods, as demonstrated by the following code.  The List.head()
method always returns the data type contained in the List's first element.
The List.tail() method always returns the entire List except for the first
element.  It's possible for a single List to contain different data types
(i.e., Int, Float, String, etc.) in each of its elements by declaring
a List with the "Any" parameter type as shown below.

object Demo
{
  def main(args: Array[String])
  {
    val array:Array[Char] = Array('1', '2', '3', '4')
    val list_1:List[Int] = List(12, 34, 56, 78)
    val list_2:List[Any] = List("one two three four", 12, 12.34F, 12.34D, array)

    val listHead_1:Int       = list_1.head
    val listTail_1:List[Int] = list_1.tail
    println("listHead_1 = " + listHead_1) // PRINTS: listHead_1 = 12
    println("listTail_1 = " + listTail_1) // PRINTS: listTail_1 = List(34, 56, 78)

    val listHead_2:Any       = list_2.head
    val listTail_2:List[Any] = list_2.tail
    println("listHead_2 = " + listHead_2) // PRINTS: listHead_2 = one two three four
    println("listTail_2 = " + listTail_2) // PRINTS: listTail_2 = List(12, 12.34, 12.34, [C@48140564)
  }
}
========================================================================
Below is Scala code that performs a mathematical operation
on all elements in a List, using a recursive function.

object Demo
{
  def main(args: Array[String])
  {
    val myList:List[Int] = List[Int](1, 2, 3, 4, 5, 6, 7);

    println("operateOnList() result = "  + operateOnList(myList, _+_))
    println("operateOnList2() result = " + operateOnList2(myList, _+_))
  }

  /**
    * This operateOnList() function is identical in behavior to the
    * below operateOnList2() function.
    */
  def operateOnList(list:List[Int], func:(Int, Int) => Int):Int =
  {
    if (list.tail.isEmpty)
    {
      list.head
    }
    else
    {
      func(list.head, operateOnList(list.tail, func))
    }
  }

  /**
    * This operateOnList2() function is identical in behavior to the
    * above operateOnList() function.
    */
  def operateOnList2(list:List[Int], func:(Int, Int) => Int):Int =
  {
    list match
    {
      case head::Nil  => head  // This line executes when there's only one element in the List.
      case head::tail => func(head, operateOnList2(tail, func))
      // NOTE: In this code example, the following line never executes
      //       because the first two lines of this match statement
      //       match all possible scenarios.
      case _ => 0
    }
  }
}
===================================================================
===================================================================
import scala.io.Source

object Demo
{
  type NameData = (String, Int, String, Int)

  def main(args: Array[String]) =
  {
    // Each line of the WI.TXT file contains comma-delimted String
    // data in this format:  stateAbbreviation, sex, year, name, numberBorn
    // EXAMPLE:  WI,M,1958,Thomas,1445
    val fileName:String = "/home/tbouril/ScalaData/WI.TXT"

    // Initialize an Array[String], where each element of the Array
    // contains a single line of text obtained from the WI.TXT file.
    val nameArray:Array[String]  = Source.fromFile(fileName).getLines().toArray
    val nameData:Array[NameData] = nameArray.map(parseLine)

    // Print the NameData tuple obtained from every element of the nameData Array.
    // nameData.foreach(println)

    println("nameArray contains " + nameArray.length + " lines of text.")

    val sex:String  = "M"
    val year:Int    = 1958
    val name:String = "Thomas"
    val data:Array[NameData] = nameData.filter(nd => nd._1.equalsIgnoreCase(sex)  &&
                                               nd._2 == year  &&
                                               nd._3.equalsIgnoreCase(name))

    // NOTE: Because of the way the WI.TXT file's data is defined, the data
    //       Array should always contain either zero elements, or one element.
    println("data contains " + data.length + " element(s).")
    if (data.length == 1)
    {
      println("Year = " + year + ", Sex = " + sex + ", Name = " + name + ", Number Born = " + data(0)._4)
    }
    else
    {
      println("No data found for Year = " + year + ", Sex = " + sex + ", Name = " + name)
    }

    val female1959:Array[NameData] = nameData.filter(x => x._1 == "F"  &&  x._2 == 1959)
    var maxNames:Int   = female1959.map(_._4).max

    // Print the NameData for the most common female name(s) born in 1959.
    female1959.filter(_._4 == maxNames).foreach(println)

    // Print the NameData for all female names occurring 100 times and born in 1959.
    val rose:Array[NameData] = nameData.filter(x => x._1 == "F"  &&  x._2 == 1959  &&  x._4 == 100)
    rose.foreach(println)
  }

  /**
    * Pass this function a line of text delimited by commas where the line
    * of text has this format: (String, String, Int, String, Int).  Then,
    * return the final 4 values of that String as the type NameData.
    * @param line
    * @return
    */
  def parseLine(line:String): NameData =
  {
    val parts:Array[String] = line.split(",")
    (parts(1), parts(2).toInt, parts(3), parts(4).toInt)
  }
}
===================================================================
===================================================================
The following is a list of methods that can be called on BOTH
Arrays and Lists.  See pages 143-148 in the Scala book for details.

BASIC METHODS:
=============
___ drop - Return all elements except the first n elements, where n is the Int parameter passed.  EXAMPLE:
           val myList:List[String] = List("abc", "def", "ghi", "jkl", "mno", "pqr")
           val newList = myList.drop(1)
           println("newList = " + newList) // Prints:  newList = List(def, ghi, jkl, mno, pqr)
___ init - Returns all elements except the last.  EXAMPLE:
           val myList:List[String]  = List("abc", "def", "ghi", "jkl", "mno", "pqr")
           val newList:List[String] = myList.init
           println("newList = " + newList) // Prints:  newList = List(abc, def, ghi, jkl, mno)
___ last - Returns the last element.  EXAMPLE:
           val myList:List[String]  = List("abc", "def", "ghi", "jkl", "mno", "pqr")
           val newList:String = myList.last
           println("newList = " + newList) // Prints:  newList = List(pqr)
___ patch - Calling the patch() method on a List returns a List where 1 or more elements of the List
            is removed from the List, and replaced by a GenSeq.  EXAMPLE:
            val list:List[Int]  = List(1, 2, 3, 4, 5)
            // Replace 2 elements beginning at index 0 with Nil...
            val list_2 = list.patch(0, Nil, 2) // list_2 = List(3, 4, 5)
            // Replace 1 element beginning at index 2 with Nil...
            val list_3 = list.patch(2, Nil, 1) // list_3 = List(1, 2, 4, 5)
___ slice - The slice() function is available in classes other than List, such as Array, String, etc.
            For String class, you could use the substring() function instead.
            EXAMPLE:
            val letters:List[Char] = List('a','b','c','d','e')
            // Return elements of the letters List from index 1 UNTIL index 3.
            val result:List[Char] = letters.slice(1,3)
            println("result = " + result) // PRINTS: result = List(b, c)
___ split - EXAMPLE:
            object Demo
            {
               def main(args: Array[String]): Unit =
               {
                  val myString:String =
                  "Each word in this String is separated by a blank-space character, which is considered " +
                  "the delimiter char.  This String of words is converted below to an Array[String] data type.  " +
                  "Where each element in this Array will contain a single word in this String.  " +
                  "No blank-space chars (the delimiter char.) will appear in the elements of this Array[String] " +
                  "because the split() method called below removes all space chars.  When this " +
                  "String prints, it will also print the Array index, which begins at zero."

                  println("myString.length = " + myString.length)
                  // The '+' in the following line means split on >= 1 of consecutive space chars.
                  // The '*' char would be used to split on >= 0 consecutive space chars.
                  var arrayString:Array[String] = myString.split(" +")
                  var count:Int = 0
                  for (tempString <- arrayString)
                  {
                     println(count + ") " + tempString)
                     count += 1
                  }

                  // The next line of code shows how to use 's' char as the delimiter, so the printed
                  // Array elements will NOT contain the lowercase 's' char.  The '+' in the following
                  // line means split on >= 1 of consecutive 's' chars.  The '*' char would be used
                  // in place of '+' to split on >= 0 consecutive 's' chars.
                  arrayString = myString.split("s+")
                  arrayString.foreach(println)
               }
            }

___ splitAt - EXAMPLE:
              // Split a single List into two separate Lists at List index 4...
              type StringListTuple        = (List[String], List[String])
              val myList:List[String]     = List("abc", "def", "ghi", "jkl", "mno", "pqr")
              val newList:StringListTuple = myList.splitAt(4) // newList is a tuple type.
              println("newList._1 = " + newList._1) // PRINTS: newList._1 = List(abc, def, ghi, jkl)
              println("newList._2 = " + newList._2) // PRINTS: newList._2 = List(mno, pqr)
              println("newList = " + newList)       // PRINTS: newList = (List(abc, def, ghi, jkl),List(mno, pqr))
___ take - EXAMPLE:
           // Return the first 4 elements of myList...
           val myList:List[String]  = List("abc", "def", "ghi", "jkl", "mno", "pqr")
           val newList:List[String] = myList.take(4)
           println("newList = " + newList) // PRINTS: newList = List(abc, def, ghi, jkl)
___ takeRight - EXAMPLE:
                // Return the last 4 elements of myList...
                val myList:List[String]  = List("abc", "def", "ghi", "jkl", "mno", "pqr")
                val newList:List[String] = myList.takeRight(4)
                println("newList = " + newList) // PRINTS: newList = List(ghi, jkl, mno, pqr)

BOOLEAN TESTS:
==============
___ contains - EXAMPLE:
               val myList:List[String]  = List("abc", "def", "ghi", "jkl", "mno", "pqr")
               val result:Boolean = myList.contains("pqr")
               println("result = " + result) // Prints: result = true
___ endsWith - EXAMPLE:
               val myList:List[String]  = List("abc", "def", "ghi", "jkl", "mno", "pqr")
               val result:Boolean = myList.endsWith(List("pqr"))
               println("result = " + result) // Prints: result = true
___ isEmpty - EXAMPLE:
              val myList1:List[String] = List()
              val myList2:List[String] = List("abc", "def", "ghi", "jkl", "mno", "pqr")
              val result1:Boolean = myList1.isEmpty
              val result2:Boolean = myList2.isEmpty
              println("result1 = " + result1 + ",  result2 = " + result2) // PRINTS: result1 = true,  result2 = false
___ asInstanceOf[] - Used to cast one class/type to another class/type.  See code example for isInstanceOf[]
                     (directly below) to see how asInstanceOf[] is used.
___ isInstanceOf[] - The following code shows how to use isInstanceOf[] to determine the data type of some value.
                     NOTE: To determine a data value's class/type, you can also use Scala's "match" statement,
                           which may be preferable to using isInstanceOf[].
                     val array:Array[Char] = Array('1', '2', '3', '4')
                     val list_2:List[Any]  = List("one two three four", 12, 12.34F, 12.34D, array)
                     val myArray:Any   = list_2(4) // Obtains the 5th element of list_2, which is of type: Array[Char]
                     val isCharArray   = myArray.isInstanceOf[Array[Char]]
                     val isIntArray    = myArray.isInstanceOf[Array[Int]]
                     val isStringArray = myArray.isInstanceOf[Array[String]]
                     // The following line PRINTS:  isCharArray = true, isIntArray = false, isStringArray = false
                     println("isCharArray = " + isCharArray + ", isIntArray = " + isIntArray + ", isStringArray = " + isStringArray)

                     // The following code shows how to cast an Int to a Long using asInstanceOf[]...
                     val intValue:Int = 1234;
                     val castIntToLong:Long = intValue.asInstanceOf[Long]
                     println("castIntToLong = " + castIntToLong) // PRINTS: castIntToLong = 1234
                     // The following line PRINTS: castIntToLong.isInstanceOf[Long] = true
                     println("castIntToLong.isInstanceOf[Long] = " + castIntToLong.isInstanceOf[Long])

___ nonEmpty - The opposite of the isEmpty method.
___ startsWith - EXAMPLE:
                 val myList1:List[String] = List("abc", "def", "ghi", "jkl", "mno", "pqr")
                 val myList2:List[String] = List("abc", "def")
                 val result:Boolean = myList1.startsWith(myList2)
                 println("result = " + result) // PRINTS: result = true


SEARCHING:
==========
___ find - EXAMPLE:
           Finds the FIRST ELEMENT of the sequence satisfying a predicate, if one exists.
           val intList:List[Int] = List[Int](7, 4, 6, 3, 9, 1)
           var result:Option[Int] = intList.find(_<4)
           println(result) // Prints: Some(3)
           result = intList.find(_>10)
           println(result) // PRINTS: None
___ indexOf - EXAMPLE:
              val myList:List[String] = List("abc", "def", "ghi", "jkl", "mno", "mno")
              val result:Int = myList.indexOf("mno")
              println("result = " + result) // PRINTS: result = 4
___ lastIndexOf - EXAMPLE:
                  val myList:List[String] = List("abc", "def", "ghi", "jkl", "mno", "mno") // NOTE: There are 2 "mno" strings.
                  val result:Int = myList.lastIndexOf("mno")
                  println("result = " + result) // PRINTS: result = 5
___ diff - Returns the DIFFERENCE between 2 Lists.  EXAMPLE:
           val myList1:List[String] = List("abc", "def", "ghi", "jkl", "mno", "pqr")
           val myList2:List[String] = List("pqr", "mno", "jkl", "ghi", "def", "abc")
           val myList3:List[String] = List("mno", "abc")
           // result1 = every element in myList1 that does NOT exist in myList2
           val result1:List[String] = myList1.diff(myList2)
           // result2 = every element in myList1 that does NOT exist in myList3
           val result2:List[String] = myList1.diff(myList3)
           println("result1 = " + result1 + ", result2 = " + result2)
           // PRINTS: result1 = List(), result2 = List(def, ghi, jkl, pqr)
___ mkString EXAMPLE:
             val myList:List[String] = List("abc", "def", "ghi", "jkl", "mno", "pqr")
             println("myList                               = " + myList)
             println("myList.mkString                      = " + myList.mkString)
             println("myList.mkString(\" + \")               = " + myList.mkString(" + "))
             println("myList.mkString(\"BEGIN\", \"_\", \"END\") = " + myList.mkString("BEGIN", "_", "END"))
             // PRINTS THE FOLLOWING 4 LINES:
             myList                               = List(abc, def, ghi, jkl, mno, pqr)
             myList.mkString                      = abcdefghijklmnopqr
             myList.mkString(" + ")               = abc + def + ghi + jkl + mno + pqr
             myList.mkString("BEGIN", "_", "END") = BEGINabc_def_ghi_jkl_mno_pqrEND
___ reverse - EXAMPLE:
              val myList:List[String] = List("abc", "def", "ghi", "jkl", "mno", "pqr")
              println("myList.reverse = " + myList.reverse) // Prints:  myList.reverse = List(pqr, mno, jkl, ghi, def, abc)
___ toList  - EXAMPLE:
              val myArray:Array[String] = Array("abc", "def", "ghi", "jkl", "mno", "pqr")
              val myList:List[String]   = myArray.toList
              println(myList) // PRINTS: List(abc, def, ghi, jkl, mno, pqr)
___ toArray - EXAMPLE:
              val myList:List[String]   = List("abc", "def", "ghi", "jkl", "mno", "pqr")
              val myArray:Array[String] = myList.toArray
              myArray.foreach(println)
              // PRINTS THE FOLLOWING 6 LINES:
              abc
              def
              ghi
              jkl
              mno
              pqr
___ zip - EXAMPLE:
          val myList1:List[String] = List("abc", "def", "ghi", "jkl", "mno", "pqr")
          val myList2:List[String] = List("stu", "vwx", "yz")
          println(myList1.zip(myList2)) // Prints:  List((abc,stu), (def,vwx), (ghi,yz))
___ zipWithIndex - When the zipWithIndex() function is called on a List, it returns a List of tuples.
                   Where the first tuple of the returned List contains the first element of the List
                   and the index of that first element, which will be 0 (zero).  Followed by the
                   second element of the List and the index of that second element, which will be
                   1 (one).  Etc.
                   EXAMPLE:
                   val myList:List[String]                = List("abc", "def", "ghi", "jkl", "mno", "pqr")
                   val myListWithIndex:List[(String,Int)] = myList.zipWithIndex
                   println("myListWithIndex = " + myListWithIndex)
                   println("myListWithIndex(2)._1 = " + myListWithIndex(2)._1 + ",  myListWithIndex(2)._2 = " + myListWithIndex(2)._2)
                   PRINTS THE FOLLOWING 2 LINES:
                   myListWithIndex = List((abc,0), (def,1), (ghi,2), (jkl,3), (mno,4), (pqr,5))
                   myListWithIndex(2)._1 = ghi,  myListWithIndex(2)._2 = 2
___ product - EXAMPLE:
              val myList:List[Float] = List(123.4F, 456.7F, 78.9F)
              println("myList.product = " + myList.product) // Prints: myList.product = 4446550.0
___ sum - EXAMPLE:
          val myList:List[Float] = List(123.4F, 456.7F, 789.1F)
          println("myList.sum = " + myList.sum) // Prints: myList.sum = 1369.2


HIGHER-ORDER METHODS, ETC.
==========================
Among this group of higher-order functions, there are specifically
TWO (2) of these functions that are widely used and very popular.
They are the filter() function and the map() function.  You should
make it a point to understand those two functions very well.

___ count - EXAMPLE:
            val myList:List[Float] = List(123.4F, 456.7F, 78.9F)
            println("myList.count = " + myList.count(_ > 100.0F)) // Prints: myList.count = 2
___ dropWhile - Also see the takeWhile method, which is the inverse of this dropWhile method.
                EXAMPLE:
                val strList:List[String] = List[String]("str1_abc_junk", "str2_abc_stuff", "str3_qrs_things", "str4_xyz_trash")
                val result:List[String] = strList.dropWhile(_.contains("abc"))
                result.foreach(println) // prints: str3_qrs_things  str4_xyz_trash
___ combinations - Also see the permutations function.
                   EXAMPLE:
                   val intList:List[Int] = List[Int](7, 4, 6, 3, 9, 1)
                   intList.combinations(3).foreach(println)
                   var count = 0
                   for (x <- intList.combinations(3))
                   {
                     count += 1
                     // Print the same intList.combinations(3) as the above call to foreach.
                     println("count = " + count + ", " + x)
                   }
___ exists - The exists method returns true if at least one element in the collection meets the condition.
             The forall method returns true if ALL elements in the collection meet the condition.
             EXAMPLE 1:
             val strList:List[String] = List[String]("str1_abc_junk", "str2_jkl_stuff", "str3_qrs_things", "str4_xyz_trash");
             val result:Boolean = strList.exists(_.compareTo("str3_qrs_things") == 0)
             println(result) // result = true
             EXAMPLE 2:
             val intList:List[Int] = List[Int](1, 2, 3, 4, 5, 6, 7);
             val result:Boolean = intList.exists(x => x==7)
             println(result) // result = true
___ filter - NOTE: The difference between the filter() and map() functions are as follows:
                   The function passed to filter() returns a Boolean and gets applied to every
                   element in the List.  If the Boolean returned by that function is true,
                   then that element of the List gets returned by filter(), which constructs
                   a new List that IS A SUBSET of the original List--thus the name filter.

                   The map() function gets passed a function which gets applied to every element
                   in the List.  That function then returns a value for every element in the List
                   that is the same type contained in the List.  So List.map() returns a List
                   containing the same number of elements as the List that it's applied to.
                   
             EXAMPLE:
             val intList:List[Int] = List[Int](1, 2, 3, 4, 5, 6, 7)
             val result_1:List[Int] = intList.filter(_ > 6)
             println(result_1) // PRINTS: List(7)

             // The following code shows TWO (2) ways of obtaining identical results by
             // calling the filter() function.  Both println() statements below print:
             // RMN
             // Randy_Reject
             val nameList:List[String] = List("TJB", "RMN", "Randy_Reject")
             var result_2:List[String] = nameList.filter(_.startsWith("R"))
             result_2.foreach(println) // PRINTS: RMN Randy_Reject
             result_2 = nameList.filter(x => x.startsWith("R"))
             result_2.foreach(println) // PRINTS: RMN Randy_Reject
___ filterNot - The opposite of the filter method.
___ flatMap - Also see --> https://github.com/w9mwi/Scala/blob/master/flatMap()_and_flatten()
              The flatMap() method is essentially a combination of the List.map method() run first,
              followed by the List.flatten() method run second.  The flatMap() method returns a List.

              TO UNDERSTAND EXACTLY HOW List.flatMap WORKS, UNDERSTAND THIS CODE...

              object Demo
              {
                def main(args: Array[String]):Unit =
                {
                  val list_1:List[Int] = List(1,2,3,4,5)
                  println("A) " + list_1)               // PRINTS: A) List(1, 2, 3, 4, 5)
                  println("B) " + list_1.map(i=>i*2))   // PRINTS: B) List(2, 4, 6, 8, 10)
                  println("C) " + list_1.flatMap(func)) // PRINTS: C) List(0, 1, 2, 1, 2, 3, 2, 3, 4, 3, 4, 5, 4, 5, 6)

                  // This is what happens when list_1.flatMap(func) is called:
                  // 1) flatMap first calls the map function on every element in list_1.
                  //    So the map function generates this result:
                  //    List(List(0, 1, 2), List(1, 2, 3), List(2, 3, 4), List(3, 4, 5), List(4, 5, 6))
                  //
                  // 2) After flatMap calls the map function, it then calls the flatten function
                  //    on the results of the map function.  So flatten transforms...
                  //    THIS:       List(List(0, 1, 2), List(1, 2, 3), List(2, 3, 4), List(3, 4, 5), List(4, 5, 6))
                  //    INTO THIS:  List(0, 1, 2, 1, 2, 3, 2, 3, 4, 3, 4, 5, 4, 5, 6)
                }

                def func(intNumber:Int):List[Int] = List(intNumber - 1, intNumber, intNumber + 1)
              }


              MORE EXAMPLES of using the flatMap() method...

              val fish:List[String]               = List[String]("alewife", "bass", "perch", "northern", "walleye")
              val waterBirds:List[String]         = List[String]("eagle", "duck", "goose")
              val waterAnimals:List[List[String]] = List[List[String]](fish, waterBirds)
              println("A) fish                             = " + fish)
              println("B) waterBirds                       = " + waterBirds)
              println("C) waterAnimals                     = " + waterAnimals)
              println("D) waterAnimals.map(x => x)         = " + waterAnimals.map(x => x)) // NOTE: map(x => x) changes nothing.
              println("E) waterAnimals.flatten             = " + waterAnimals.flatten)
              println("F) waterAnimals.map(x => x).flatten = " + waterAnimals.map(x => x).flatten)
              println("G) waterAnimals.flatMap(x => x)     = " + waterAnimals.flatMap(x => x))
              //  PRINTS THE FOLLOWING 7 LINES...
              //  A) fish                             = List(alewife, bass, perch, northern, walleye)
              //  B) waterBirds                       = List(eagle, duck, goose)
              //  C) waterAnimals                     = List(List(alewife, bass, perch, northern, walleye), List(eagle, duck, goose))
              //  D) waterAnimals.map(x => x)         = List(List(alewife, bass, perch, northern, walleye), List(eagle, duck, goose))
              //  E) waterAnimals.flatten             = List(alewife, bass, perch, northern, walleye, eagle, duck, goose)
              //  F) waterAnimals.map(x => x).flatten = List(alewife, bass, perch, northern, walleye, eagle, duck, goose)
              //  G) waterAnimals.flatMap(x => x)     = List(alewife, bass, perch, northern, walleye, eagle, duck, goose)

___ flatten - Also see --> https://github.com/w9mwi/Scala/blob/master/flatMap()_and_flatten()
              The following code shows the results of executing the flatten method on 5 different
              Lists.  Whenever the List.flatten method is executed it always returns a List.
              Where the first collection contained in the original List is removed, leaving
              only that collection's contents (elements) in the List.

              When a List can no longer be flattened, the flatten() method won't compile, or will fail to execute.

              val myList_1:List[Set[Int]] = List(Set(1, 2, 3), Set(1, 2, 3))
              println("myList_1 = " + myList_1)                  // PRINTS: myList_1 = List(Set(1, 2, 3), Set(1, 2, 3))
              println("myList_1.flatten = " + myList_1.flatten)  // PRINTS: myList_1.flatten = List(1, 2, 3, 1, 2, 3)

              val myList_2:List[List[Int]] = List(List(1, 2, 3), List(3, 2, 1))
              println("myList_2 = " + myList_2)                  // PRINTS: myList_2 = List(List(1, 2, 3), List(3, 2, 1))
              println("myList_2.flatten = " + myList_2.flatten)  // PRINTS: myList_2.flatten = List(1, 2, 3, 3, 2, 1)

              val myList_3:List[Vector[Set[Int]]] = List(Vector(Set(1, 2, 3), Set(4, 5, 6)), Vector(Set(10, 20, 30), Set(40, 50, 60)))
              println("myList_3 = " + myList_3)
              // PRINTS: myList_3 = List(Vector(Set(1, 2, 3), Set(4, 5, 6)), Vector(Set(10, 20, 30), Set(40, 50, 60)))
              println("myList_3.flatten = " + myList_3.flatten)
              // PRINTS: myList_3.flatten = List(Set(1, 2, 3), Set(4, 5, 6), Set(10, 20, 30), Set(40, 50, 60))
              println("myList_3.flatten = " + myList_3.flatten.flatten)
              // PRINTS: myList_3.flatten = List(1, 2, 3, 4, 5, 6, 10, 20, 30, 40, 50, 60)

              val myList_4:List[String] = List("ABC", "DEF", "GHI")
              println("myList_4 = " + myList_4) // PRINTS: myList_4 = List(ABC, DEF, GHI)

              // NOTE: When you flatten a List[String], the result is a List[Char]
              val myList_5:List[Char] = myList_4.flatten
              println("myList_5 = " + myList_5) // PRINTS: myList_5 = List(A, B, C, D, E, F, G, H, I)

              =============================================================================================

              In the code sample below, notice how flatten() returns a List data type that is
              DIFFERENT than the List data type it's executed on.

              val tom1:List[List[List[String]]] = List(List(List("ABC"), List("DEF"), List("GHI")),
                                                       List(List("RST"), List("UVW"), List("XYZ")))
              tom1.foreach(println)    // PRINTS: List(List(ABC), List(DEF), List(GHI))
                                       //         List(List(RST), List(UVW), List(XYZ))
              val tom2:List[List[String]] = tom1.flatten
              tom2.foreach(println)   // PRINTS: List(ABC)
                                      //         List(DEF)
                                      //         List(GHI)
                                      //         List(RST)
                                      //         List(UVW)
                                      //         List(XYZ)
              val tom3:List[String] = tom2.flatten
              tom3.foreach(println)   // PRINTS: ABC
                                      //         DEF
                                      //         GHI
                                      //         RST
                                      //         UVW
                                      //         XYZ
              val tom4:List[Char] = tom3.flatten
              tom4.foreach(println)   // PRINTS: A
                                      // PRINTS: B
                                      // PRINTS: C
                                      // ...
                                      // PRINTS: X
                                      // PRINTS: Y
                                      // PRINTS: Z
              for (x <- tom4)
              {
                print(x + " ") // PRINTS: A B C D E F G H I R S T U V W X Y Z 
              }
              // The following commented-out line would FAIL TO EXECUTE because
              // a List[Char] data type can NOT be further "flattened".
              // tom4.flatten

___ foldLeft - See the foldRight example below.
___ foldRight - Both foldLeft and foldRight are both curried functions.
                A curried function is a function that returns a function
                having a single parameter list.  Note that a single
                parameter list can contain multiple arguments.  EXAMPLE:

                object Demo
                {
                  def main(args: Array[String]): Unit =
                  {
                    val intList:List[Int] = List(7, 4, 6, 3, 9, 1)
                    // Both the foldLeft and foldRight functions are called with two
                    // parameter lists.  The first parameter list contains the base
                    // value used as the first operand.  The second parameter list
                    // contains the binary operator function to apply.

                    // The following foldLeft example calculates this result:
                    // 0−7−4−6−3−9−1 = ((((((0−7)−4)−6)−3)−9)−1) = -30
                    var result = intList.foldLeft(0)(_ - _)
                    println("result = " + intList.foldLeft(0)(_ - _)) // PRINTS: result = -30

                    // The following foldRight example calculates this result:
                    // 0−(1−(9−(3−(6−(4−7))))) = 14
                    result = intList.foldRight(0)(_ - _)
                    println("result = " + intList.foldRight(0)(_ - _)) // PRINTS: result = 14
                  }
                }

                For more info. regarding foldLeft and foldRight, see "CURRYING EXAMPLE 3" and "CURRYING EXAMPLE 4"
                at this URL: https://github.com/w9mwi/Scala/blob/master/Currying_2

                // ********************************************************************
                val wordList:List[String] = List[String]("How", "many", "characters", "do", "we", "have?")

                // NOTE: The second parameter list for foldRight has its tuple order as (word, count),
                //       which is the reverse order used by the foldLeft function below.
                var wordCount:Int = wordList.foldRight(0)((word:String, count:Int) => count + word.length)
                println("wordCount.foldRight = " + wordCount)

                // NOTE: The second parameter list for foldLeft has its tuple order as (count, word),
                //       which is the reverse order used by the foldRight function above.
                wordCount = wordList.foldLeft(0)((count:Int, word:String) => count + word.length)
                println("wordCount.foldLeft = " + wordCount)

                // The following calls to foldRight and foldLeft perform identically
                // to the foldRight and foldLeft calls immediately above.
                println("wordList.foldRight(0)(_.length + _) = " + wordList.foldRight(0)(_.length + _))
                println("wordList.foldLeft(0)(_+_.length)    = " + wordList.foldLeft(0)(_+_.length))
___ forall - The forall method returns true if ALL elements in the collection meet the condition.
             The exists method returns true if at least one element in the collection meets the condition.
             EXAMPLE:
             val myList:List[Float] = List(123.4F, 456.7F, 78.9F)
             println("myList.forall = " + myList.forall(_ > 100.0F)) // Prints: myList.forall = false
             println("myList.forall = " + myList.forall(_ > 50.0F))  // Prints: myList.forall = true
___ foreach - This method gets passed a function that operates on all elements in the collection,
              and returns nothing.  This method is called only for its side effects.
              EXAMPLE:
              val myList:List[Float] = List(12.1F, 34.2F, 56.3F, 78.4F)
              myList.foreach(x => println(2.0F * x)) // Param passed to foreach is a literal function.
              PRINTS THE FOLLOWING 4 LINES:
              24.2
              68.4
              112.6
              156.8
___ grouped - Runs through the sequence, grouping items into groups of the specified size.
              EXAMPLE:
              val intList:List[Int] = List[Int](7, 4, 6, 3, 9, 1)
              intList.grouped(2).foreach(println) // PRINTS: List(7, 4)
                                                  //         List(6, 3)
              var count = 0                       //         List(9, 1)
              for (x <- intList.grouped(2))
              {
                 count += 1
                 // Print the same intList.grouped(2) as the above call to foreach.
                 println("count = " + count + ", " + x) // PRINTS: count = 1, List(7, 4)
              }                                         //         count = 2, List(6, 3)
                                                        //         count = 3, List(9, 1)

___ indexWhere - Pass this method a function that operates on a single element of the collection.
                 Returns the index of the FIRST element for which the function is true.  Returns
                 -1 if the function is NOT true for any of the elements.
                 EXAMPLE:
                 val myList:List[Float] = List(12.1F, 34.2F, 56.3F, 78.4F)
                 val result:Int = myList.indexWhere(_ > 50.0F)
                 println(result) // Prints: 2
___ inits - Provides an iterator going from the full sequence to an empty one, removing elements from the end.
                                                                 // The below println statement PRINTS:
            val intList:List[Int] = List[Int](7, 4, 6, 3, 9, 1)  // count = 1, List(7, 4, 6, 3, 9, 1)
            var count = 0                                        // count = 2, List(7, 4, 6, 3, 9)
            for (x <- intList.inits)                             // count = 3, List(7, 4, 6, 3)
            {                                                    // count = 4, List(7, 4, 6)
              count += 1                                         // count = 5, List(7, 4)
              println("count = " + count + ", " + x)             // count = 6, List(7)
            }                                                    // count = 7, List()
___ lastIndexWhere - Pass this method a function that operates on a single element of the collection
                     and returns a Boolean.  This method returns the index of the LAST element for
                     which the function is true.  Returns -1 if the function is NOT true for any
                     of the elements.
                     EXAMPLE:
                     val myList:List[Float] = List(12.1F, 34.2F, 56.3F, 78.4F)
                     val result:Int = myList.lastIndexWhere(_ > 50.0F)
                     println(result) // Prints: 3
___ map - NOTE: The difference between the filter() and map() functions are as follows:
                The function passed to filter() returns a Boolean and gets applied to every
                element in the List.  If the Boolean returned by that function is true,
                then that element of the List gets returned by filter(), which constructs
                a new List that IS A SUBSET of the original List--thus the name filter.

                The map() function gets passed a function which gets applied to every element
                in the List.  That function then returns a value for every element in the List
                that is the same type contained in the List.  So List.map() returns a List
                containing the same number of elements as the List it gets applied to.
          EXAMPLE:
          val intList:List[Int] = List[Int](1, 2, 3, 4, 5, 6, 7);
          val result:List[Int] = intList.map(_*2)
          println(result) //  prints: List(2, 4, 6, 8, 10, 12, 14)
___ partition - Pass this method a function that operates on a single element of the collection
                and returns a Boolean.  This method returns a tuple with TWO new collections.
                The first collection in the tuple contains only the elements for which the
                function is true.  The second collection in the tuple contains only the elements
                for which the function is false.
                EXAMPLE:
                val myList:List[Float] = List(43.7F, 567.89F, 144.8F, 77.7F, 17.7F)
                val result:(List[Float], List[Float]) = myList.partition(_ > 77.0F)
                println(result) // Prints: (List(567.89, 144.8, 77.7),List(43.7, 17.7))
___ permutations - Also see the combinations function.
                   EXAMPLE:
                   val intList:List[Int] = List[Int](7, 4, 6, 3, 9, 1)
                   intList.permutations.foreach(println)
                   var count = 0
                   for (x <- intList.permutations)
                   {
                     count += 1
                     // Print the same intList.permutations as the above call to foreach.
                     println("count = " + count + ", " + x)
                   }
___ reduce - Example:
             val myList:List[Int] = List(1, 2, 3, 4)
             println(myList.reduce(_ max _))         // PRINTS: 4
             println(myList.reduce((x, y) => x + y)) // PRINTS: 10
             println(myList.reduce((x, y) => x - y)) // PRINTS: -8
___ reduceLeft - See reduceRight.
___ reduceRight - EXAMPLE of reduceLeft and reduceRight:
    val myList:List[Int] = List(1, 2, 3, 4)
    var result:Int = myList.reduceLeft(_ + _) // result = ((1 + 2) + 3) + 4 = 10
    println("result = " + result) // Prints: 10

    result = myList.reduceRight(_ + _) // result = 1 + (2 + (3 + 4)) = 10
    println("result = " + result) // Prints: 10

    result = myList.reduceLeft(_ - _) // result = ((1 - 2) - 3) - 4 = -8
    println("result = " + result) // Prints: -8

    result = myList.reduceRight(_ - _) // result = 1 - (2 - (3 - 4)) = -2
    println("result = " + result) // Prints: -2

    result = myList.reduceLeft(_ * _) // result = ((1 * 2) * 3) * 4 = 24
    println("result = " + result) // Prints: 24

    result = myList.reduceRight(_ * _) // result = 1 * (2 * (3 * 4)) = 24
    println("result = " + result) // Prints: 24
___ sliding - Provides an iterator that gives the effect of sliding a window of a specified size across the sequence.
              EXAMPLE:
              val intList:List[Int] = List[Int](7, 4, 6, 3, 9, 1)
              intList.sliding(3).foreach(println)
              var count = 0
              for (x <- intList.sliding(3))
              {
                count += 1
                // Print the same intList.sliding(3) as the above call to foreach.
                println("count = " + count + ", " + x)
              }
___ tails - Gives an iterator that runs through sublists, starting with the full list, and ending
            with an empty list--removing one element from the left (removing the head) for each step,
            thus returning the tail.
            EXAMPLE:
            val intList:List[Int] = List[Int](7, 4, 6, 3, 9, 1)
            intList.tails.foreach(println)
            var count = 0
            for (x <- intList.tails)
            {
              count += 1
              // Print the same intList.tails as the above call to foreach.
              println("count = " + count + ", " + x)
            }
___ takeWhile - Also see the dropWhile method, which is the inverse of this takeWhile method.
                Pass this method a function that operates on a single element of the collection
                and returns a Boolean.  This method returns a new collection of all elements
                for which that function is true beginning with the first element.  As soon
                as an element is found for where the function returns false, nothing more
                is returned.  That's why the fourth println below prints the empty List (List()),
                because the function returns false for the first element in myList.

                val myList:List[Float] = List(43.7F, 17.7F, 77.7F, 567.89F, 144.8F)
                println("myList                       = " + myList)
                println("myList.takeWhile(_ == 43.7F) = " + myList.takeWhile(_ == 43.7F))
                println("myList.takeWhile(_ > 43.6F)  = " + myList.takeWhile(_ > 43.6F))
                println("myList.takeWhile(_ > 43.7F)  = " + myList.takeWhile(_ > 43.7F))
                println("myList.takeWhile(_ > 17.6F)  = " + myList.takeWhile(_ > 17.6F))
              // PRINTS THE FOLLOWING:
              // myList                       = List(43.7, 17.7, 77.7, 567.89, 144.8)
              // myList.takeWhile(_ == 43.7F) = List(43.7)
              // myList.takeWhile(_ > 43.6F)  = List(43.7)
              // myList.takeWhile(_ > 43.7F)  = List()
              // myList.takeWhile(_ > 17.6F)  = List(43.7, 17.7, 77.7, 567.89, 144.8)
