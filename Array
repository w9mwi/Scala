
Difference Between Array and ArrayBuffer
========================================
A Scala Array is a fixed-size array.  Once an Array is created, its size cannot be changed.
A Scala ArrayBuffer is variable in size--its size can increase or decrease dynamically.

In Scala, Arrays are SEQUENCES, which means data is stored
in elements that can be accessed via a sequential Integer
index.  Even when an Array is declared as a "val" you can
always change the contents of all its elements.  Unlike most
Scala collections, an Array CAN'T be declared as immutable!

Read in-line comments in the following sample programs
to understand some Array fundamentals.
=======================================================================
object Demo
{
  def main(args: Array[String]):Unit =
  {
    // An UN-initialized Array REQUIRES the "new" keyword in its declaration,
    // as in EXAMPLE 1), EXAMPLE 2) and EXAMPLE 3) below.  When an Array is
    // initialized upon its declaration, the declaration CAN'T use the "new"
    // keyword, as shown in EXAMPLE 4) below.

    // EXAMPLE 1)
    // An UN-initialized Array that contains a number type (i.e., Int, Float, Double)
    // will have default values of ZERO for each element, as in this example...
    val array_1:Array[Int] = new Array[Int](3) // REQUIRES "new" keyword.
    println(s"array_1(0) = ${array_1(0)}, array_1(1) = ${array_1(1)}, array_1(2) = ${array_1(2)}")
    // PRINTS: array_1(0) = 0, array_1(1) = 0, array_1(2) = 0

    // EXAMPLE 2)
    // An UN-initialized Array that contains a Boolean type will have
    // default values of false for each element, as in this example...
    val array_2:Array[Boolean] = new Array[Boolean](3) // REQUIRES "new" keyword.
    println(s"array_2(0) = ${array_2(0)}, array_2(1) = ${array_2(1)}, array_2(2) = ${array_2(2)}")
    // PRINTS: array_2(0) = false, array_2(1) = false, array_2(2) = false

    // EXAMPLE 3)
    // An UN-initialized Array that contains a data type that is NOT a number or a
    // Boolean will have default values of null for each element, as in this example...
    val array_3: Array[String] = new Array[String](3) // REQUIRES "new" keyword.
    println(s"array_3(0) = ${array_3(0)}, array_3(1) = ${array_3(1)}, array_3(2) = ${array_3(2)}")
    // PRINTS: array_3(0) = null, array_3(1) = null, array_3(2) = null

    // EXAMPLE 4)
    // An Array that is initialized upon its declaration CAN'T contain
    // the "new" keyword in its declaration, as in this example.
    val array_4:Array[Int] = Array[Int](111, 222, 333) // The "new" keyword CAN'T be used here.
    println(s"array_4(0) = ${array_4(0)}, array_4(1) = ${array_4(1)}, array_4(2) = ${array_4(2)}")
    // PRINTS: array_4(0) = 111, array_4(1) = 222, array_4(2) = 333

    // EXAMPLE 5)
    // Unlike most Scala collections, an Array CAN'T be declared
    // as immutable.  Even when an Array is declared as a "val"
    // all of its elements are MUTABLE.  As shown here...
    array_4(0) = 777
    array_4(1) = 888
    array_4(2) = 999
    println(s"array_4(0) = ${array_4(0)}, array_4(1) = ${array_4(1)}, array_4(2) = ${array_4(2)}")
    // PRINTS: array_4(0) = 777, array_4(1) = 888, array_4(2) = 999
  }
}

================================================================================
HOW TO INITIALIZE ARRAYS (AND LISTS) UPON THEIR DECLARATION.

Instead of declaring an Array or a List in one line of code,
and then initializing its values in other code later, it's
possible to fill an Array or List with values in one line
of code upon its declaratoion.  Read in-line comments
in the below code sample for details.

object Demo
{
  def main(args: Array[String])
  {
    var intArray:Array[Int] = Array.fill(10)(4)
    println(s"1) intArray.size = ${intArray.size}") // PRINTS: 1) intArray.size = 10
    intArray.foreach(print) // Prints the contents of intArray: 4444444444
    println("\n===================")
    intArray.foreach{print(_)} // Equivalent to the above line: intArray.foreach(print)
    println("\n===================")

    // Initialize a new List having 6 elements, where each element contains the string "XYZ".
    val stringList:List[String] = List.fill(6)("XYZ")
    stringList.foreach(print)  // Prints the contents of stringList: XYZXYZXYZXYZXYZXYZ
    println("\n===================")

    var idx = 1
    // The following line of code initializes a new List with 5 elements.
    // NOTE: idx MUST be declared as a var.  The value of each element in
    //       intList will be the value of idx.  But the idx value first
    //       changes by 2X its previous value before it gets assigned to
    //       each element in intList.
    var intList:List[Int] = List.fill(5){idx*=2; idx} // NOTE: The second argument is a code block
                                                      //       (which returns the value idx) so it
                                                      //        MUST be contained in curly braces.
    intList.foreach(println)  // Prints these 5 elements of intList:  2, 4, 8, 16, 32
    println("===================")
    intList = 1::intList // Prepend a 1 to intList
    intList.foreach(println)  // Prints these 6 elements of intList:  1, 2, 4, 8, 16, 32
    println("===================")
    intList = List.tabulate(10)(i => i*i) // The value of each element will be its index SQUARED.
    intList.foreach(println)  // Prints these 10 elements of intList: 0, 1, 4, 9, 16, 25, 36, 49, 64, 81
    println("===================")

    // Create a 6-element Array, where each element in the Array is initialized with
    // the value: (3*x*x + 5x - 7)   The value x designates the current index of the Array.
    // So for the first element of the array, x = 0.  For the second element, x = 1.  Etc.
    intArray = Array.tabulate(6)(x => 3*x*x + 5*x - 7) // NOTE: Uses (), equivalent to the line below.
    println(s"2) intArray.size = ${intArray.size}") // PRINTS: 2) intArray.size = 6
    intArray.foreach(println) // Prints these 6 elements of intArray: -7, 1, 15, 35, 61, 93
    println("===================")

    // NOTE: The last value printed below will ALWAYS be ONE LESS than the maximum value in
    //       the range.  So in this instance, the last value printed is eleven (11)...
    intArray = Array.range(0, 12)
    println(s"3) intArray.size = ${intArray.size}") // PRINTS: 3) intArray.size = 12
    intArray.foreach(println) // PRINTS: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11
  }
}

=======================================================================
MULTI-DIMENSIONAL ARRAYS - Read in-line comments in the following code
                           sample to understand the fundamentals of
                           multi-dimensional arrays.

object Demo {
  def main(args: Array[String]) {
    val dim1Size: Int = 4
    val dim2Size: Int = 3
    // Declare an UN-initialized 2-dimensional Array.
    val matrix2X2: Array[Array[Int]] = Array.ofDim[Int](dim1Size, dim2Size)

    // The following 2 nested for loops initializes the matrix2X2 Array.
    // The first element of matrix2X2 Array will contain the number 0.  Every
    // element after that will contain the number of the previous element
    // incremented by 1.  So if the Array is 4X3 elements, it will contains
    // the integers 0 through 11.
    for (idx <- matrix2X2.indices) {
      for (jdx <- matrix2X2(idx).indices) {
        matrix2X2(idx)(jdx) = if (idx == 0)      { idx + jdx }
                              else if (jdx == 0) { matrix2X2(idx - 1)(dim2Size - 1) + 1 }
                              else               { matrix2X2(idx)(jdx - 1) + 1 }
      }
    }

    // The following code prints the contents of all matrix2X2 elements like this:
    // elem = 0, elem = 1, elem = 2, elem = 3, elem = 4, elem = 5, elem = 6, elem = 7, elem = 8, elem = 9, elem = 10, elem = 11,
    matrix2X2.foreach {
      for (elem <- _) {
        print(s"elem = $elem, ")
      }
    }
    println("\n=============")

    // The following line of code prints the contents of all matrix2X2 elements like this:
    // 0 1 2
    // 3 4 5
    // 6 7 8
    // 9 10 11
    print2DMatrix(matrix2X2)
    println("\n=============")

    // The following 2 lines of code demonstrate that the contents of an
    // Array can be changed.  Even when that Array is declared as a val.
    change2DArrayContents(matrix2X2)
    print2DMatrix(matrix2X2)
  }

  /**
   * Print the contents of a 2-dimensional Int Array matrix.
   */
  def print2DMatrix(matrix2D:Array[Array[Int]]): Unit =
  {
    for (idx <- matrix2D.indices) {
      for (jdx <- matrix2D(idx).indices) {
        print(" " + matrix2D(idx)(jdx))
      }
      println
    }
  }

  def change2DArrayContents(matrix2D:Array[Array[Int]]): Unit =
  {
     matrix2D(0)(0) = -999
  }
}

================================================================================
MULTI-DIMENSIONAL ARRAYS - Read in-line comments in the following code sample.
                           This code shows how to populate a 100-element
                           2-dimensional Array with Array[Double] arrays that
                           have a RANDOM NUMBER of elements.  And where each
                           number in the Array[Double] is populated with a
                           RANDOM NUMBER.

object Demo
{
  def main(args: Array[String])
  {
    val minNoOfElements = 2
    val maxNoOfElements = 5
    if (minNoOfElements < 2)
    {
      println(s"ERROR: minNoOfElements ($minNoOfElements) can't be less than 2.")
      return;
    }
    if (maxNoOfElements < minNoOfElements)
    {
      println(s"ERROR: maxNoOfElements ($maxNoOfElements) can't be less than minNoOfElements ($minNoOfElements).")
      return;
    }

    // The following line of code declares array2D to be a 100-element Array of
    // type Array[Array[Double]].  (Therefore, array2D is a 2-dimensional Array.)
    // Each element of the 100-element array2D will contain:
    // * An Array having a RANDOM NUMBER of elements, ranging in size from
    //   minNoOfElements to maxNoOfElements.  Those child Array elements
    //   will contain a RANDOM NUMBER from zero to one, of type Double.
    val array2D:Array[Array[Double]] =
        Array.fill(100){Array.fill(util.Random.nextInt(maxNoOfElements)+minNoOfElements)(math.random)}
    var count:Int = 0;

    // Loop through every element in array2D and print its contents...
    for (idx <- array2D.indices) {
      for (jdx <- array2D(idx).indices)  {
        count += 1
        println("array2D(" + idx + ")(" + jdx + ") = " + array2D(idx)(jdx) + " (Element #" + count + ")")
      }
    }

    println("===========================================")
    println("Loop through every element in array2D that contains a 3-element Array.")
    println("Then, calculate and print the average of those 3 numbers for each element.")
    var result:Array[Double] = for (Array(d1, d2, d3) <- array2D) yield (d1 + d2 + d3) / 3
    result.foreach(println)

    println("===========================================")
    println("Loop through every element in array2D that contains a 4-element Array.")
    println("Then, calculate and print the average of those 4 numbers for each element.")
    result = for (Array(d1, d2, d3, d4) <- array2D) yield (d1 + d2 + d3 + d4) / 4
    result.foreach(println)
  }
}

================================================================================
RECURSION - The following code sample demonstrates how to use a recursive
            function to obtain the result of multiplying the contents of
            an Array[Int].

object Demo
{
  def main(args: Array[String])
  {
    val arr:Array[Int] = Array(23, 32, 64)

    // The second element passed to operateOnArray() designates the index
    // of the first Array element to be included in the tabulation.  EXAMPLE:
    // If the index value is 2, the tabulation will begin with the Array(2)
    // element--the Array(0) and Array(1) elements will NOT be included
    // in the tabulation.
    val result:Int = operateOnArray(arr, 0, _*_)
    println("result = " + result) // PRINTS: result = 47104
  }

  /**
   * This RECURSIVE function loops through the elements of the Array passed
   * to it, BEGINNING at the Array index value passed to this function.
   * Each time this function calls itself, it performs an operation on the
   * Array(index) and Array(index+1) elements.  This function terminates
   * when the index passed to it equals the length of the Array passed to it.
   */
  def operateOnArray(arr:Array[Int], index:Int, func:(Int, Int) => Int):Int =
  {
    if (index < arr.length-1)
      func(arr(index), operateOnArray(arr, index+1, func))
    else
      arr(arr.length-1)
  }
}

================================================================================

When using Scala Arrays (or other Scala collections), it's possible for a single
Array to contain different data types (i.e., Int, Float, String, List, etc.)
in each of its elements by declaring an Array with the "Any" parameter type
as shown below.

object Demo
{
  def main(args: Array[String])
  {
    val list:List[Char]    = List('1', '2', '3', '4')
    val array_1:Array[Int] = Array(12, 34, 56, 78)
    val array_2:Array[Any] = Array("one two three four", 12, 12.34F, 12.34D, list)

    // Print the contents of array_1...
    array_1.foreach(println)
    // PRINTS: 12
    //         34
    //         56
    //         78
    println("==================")
    // Print the contents of array_2...
    array_2.foreach(println)
    // PRINTS: one two three four
    //         12
    //         12.34
    //         12.34
    //         List(1, 2, 3, 4)
  }
}

==================================================================
