
Difference Between Array and ArrayBuffer
========================================
A Scala Array is a fixed-size array.  Once an Array is created, its size cannot be changed.
A Scala ArrayBuffer is variable in size--its size can increase or decrease dynamically.

In Scala, Arrays are SEQUENCES, which means data is stored
in elements that can be accessed via a sequential Integer
index.  Even when an Array is declared as a "val" you can
always change the contents of all its elements.  Unlike most
Scala collections, an Array CAN'T be declared as immutable!

Read in-line comments in the following sample programs
to understand some Array fundamentals.
=======================================================================
object Demo
{
  def main(args: Array[String]):Unit =
  {
    // An UN-initialized Array REQUIRES the "new" keyword in its declaration,
    // as in EXAMPLE 1), EXAMPLE 2) and EXAMPLE 3) below.  When an Array is
    // initialized upon its declaration, the declaration CAN'T use the "new"
    // keyword, as shown in EXAMPLE 4) below.

    // EXAMPLE 1)
    // An UN-initialized Array that contains a number type (i.e., Int, Float, Double)
    // will have default values of ZERO for each element, as in this example...
    val array_1:Array[Int] = new Array[Int](3) // REQUIRES "new" keyword.
    println(s"array_1(0) = ${array_1(0)}, array_1(1) = ${array_1(1)}, array_1(2) = ${array_1(2)}")
    // PRINTS: array_1(0) = 0, array_1(1) = 0, array_1(2) = 0

    // EXAMPLE 2)
    // An UN-initialized Array that contains a Boolean type will have
    // default values of false for each element, as in this example...
    val array_2:Array[Boolean] = new Array[Boolean](3) // REQUIRES "new" keyword.
    println(s"array_2(0) = ${array_2(0)}, array_2(1) = ${array_2(1)}, array_2(2) = ${array_2(2)}")
    // PRINTS: array_2(0) = false, array_2(1) = false, array_2(2) = false

    // EXAMPLE 3)
    // An UN-initialized Array that contains a data type that is NOT a number or a
    // Boolean will have default values of null for each element, as in this example...
    val array_3: Array[String] = new Array[String](3) // REQUIRES "new" keyword.
    println(s"array_3(0) = ${array_3(0)}, array_3(1) = ${array_3(1)}, array_3(2) = ${array_3(2)}")
    // PRINTS: array_3(0) = null, array_3(1) = null, array_3(2) = null

    // EXAMPLE 4)
    // An Array that is initialized upon its declaration CAN'T contain
    // the "new" keyword in its declaration, as in this example.
    val array_4:Array[Int] = Array[Int](111, 222, 333) // The "new" keyword CAN'T be used here.
    println(s"array_4(0) = ${array_4(0)}, array_4(1) = ${array_4(1)}, array_4(2) = ${array_4(2)}")
    // PRINTS: array_4(0) = 111, array_4(1) = 222, array_4(2) = 333

    // EXAMPLE 5)
    // Unlike most Scala collections, an Array CAN'T be declared
    // as immutable.  Even when an Array is declared as a "val"
    // all of its elements are MUTABLE.  As shown here...
    array_4(0) = 777
    array_4(1) = 888
    array_4(2) = 999
    println(s"array_4(0) = ${array_4(0)}, array_4(1) = ${array_4(1)}, array_4(2) = ${array_4(2)}")
    // PRINTS: array_4(0) = 777, array_4(1) = 888, array_4(2) = 999
  }
}

================================================================================
HOW TO INITIALIZE ARRAYS (AND LISTS) UPON THEIR DECLARATION.

Instead of declaring an Array or a List in one line of code,
and then initializing its values in other code later, it's
possible to fill an Array or List with values in one line
of code upon its declaratoion.  Read in-line comments
in the below code sample for details.

object Demo
{
  def main(args: Array[String])
  {
    var intArray:Array[Int] = Array.fill(10)(4)
    println(s"1) intArray.size = ${intArray.size}") // PRINTS: 1) intArray.size = 10
    intArray.foreach(print) // Prints the contents of intArray: 4444444444
    println("\n===================")
    intArray.foreach{print(_)} // Equivalent to the above line: intArray.foreach(print)
    println("\n===================")

    // Initialize a new List having 6 elements, where each element contains the string "XYZ".
    val stringList:List[String] = List.fill(6)("XYZ")
    stringList.foreach(print)  // Prints the contents of stringList: XYZXYZXYZXYZXYZXYZ
    println("\n===================")

    var idx = 1
    // The following line of code initializes a new List with 5 elements.
    // NOTE: idx MUST be declared as a var.  The value of each element in
    //       intList will be the value of idx.  But the idx value first
    //       changes by 2X its previous value before it gets assigned to
    //       each element in intList.
    var intList:List[Int] = List.fill(5){idx*=2; idx} // NOTE: The second argument is a code block
                                                      //       (which returns the value idx) so it
                                                      //        MUST be contained in curly braces.
    intList.foreach(println)  // Prints these 5 elements of intList:  2, 4, 8, 16, 32
    println("===================")
    intList = 1::intList // Prepend a 1 to intList
    intList.foreach(println)  // Prints these 6 elements of intList:  1, 2, 4, 8, 16, 32
    println("===================")
    intList = List.tabulate(10)(i => i*i) // The value of each element will be its index SQUARED.
    intList.foreach(println)  // Prints these 10 elements of intList: 0, 1, 4, 9, 16, 25, 36, 49, 64, 81
    println("===================")

    // Create a 6-element Array, where each element in the Array is initialized with
    // the value: (3*x*x + 5x - 7)   The value x designates the current index of the Array.
    // So for the first element of the array, x = 0.  For the second element, x = 1.  Etc.
    intArray = Array.tabulate(6)(x => 3*x*x + 5*x - 7) // NOTE: Uses (), equivalent to the line below.
    println(s"2) intArray.size = ${intArray.size}") // PRINTS: 2) intArray.size = 6
    intArray.foreach(println) // Prints these 6 elements of intArray: -7, 1, 15, 35, 61, 93
    println("===================")

    // NOTE: The last value printed below will ALWAYS be ONE LESS than the maximum value in
    //       the range.  So in this instance, the last value printed is eleven (11)...
    intArray = Array.range(0, 12)
    println(s"3) intArray.size = ${intArray.size}") // PRINTS: 3) intArray.size = 12
    intArray.foreach(println) // PRINTS: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11
  }
}

=======================================================================
MULTI-DIMENSIONAL ARRAYS (PART 1)

Read in-line comments in the following code sample to understand
the fundamentals of multi-dimensional arrays.

object Demo {
  def main(args: Array[String]) {
    val dim1Size: Int = 4
    val dim2Size: Int = 3
    // Declare an UN-initialized 2-dimensional Array.
    val matrix2X2: Array[Array[Int]] = Array.ofDim[Int](dim1Size, dim2Size)

    // The following 2 nested for loops initializes the matrix2X2 Array.
    // The first element of matrix2X2 Array will contain the number 0.  Every
    // element after that will contain the number of the previous element
    // incremented by 1.  So if the Array is 4X3 elements, it will contains
    // the integers 0 through 11.
    for (idx <- matrix2X2.indices) {
      for (jdx <- matrix2X2(idx).indices) {
        matrix2X2(idx)(jdx) = if (idx == 0)      { idx + jdx }
                              else if (jdx == 0) { matrix2X2(idx - 1)(dim2Size - 1) + 1 }
                              else               { matrix2X2(idx)(jdx - 1) + 1 }
      }
    }

    // The following code prints the contents of all matrix2X2 elements like this:
    // elem = 0, elem = 1, elem = 2, elem = 3, elem = 4, elem = 5, elem = 6, elem = 7, elem = 8, elem = 9, elem = 10, elem = 11,
    matrix2X2.foreach {
      for (elem <- _) {
        print(s"elem = $elem, ")
      }
    }
    println("\n=============")

    // The following line of code prints the contents of all matrix2X2 elements like this:
    // 0 1 2
    // 3 4 5
    // 6 7 8
    // 9 10 11
    print2DMatrix(matrix2X2)
    println("\n=============")

    // The following 2 lines of code demonstrate that the contents of an
    // Array can be changed.  Even when that Array is declared as a val.
    change2DArrayContents(matrix2X2)
    print2DMatrix(matrix2X2)
  }

  /**
   * Print the contents of a 2-dimensional Int Array matrix.
   */
  def print2DMatrix(matrix2D:Array[Array[Int]]): Unit =
  {
    for (idx <- matrix2D.indices) {
      for (jdx <- matrix2D(idx).indices) {
        print(" " + matrix2D(idx)(jdx))
      }
      println
    }
  }

  def change2DArrayContents(matrix2D:Array[Array[Int]]): Unit =
  {
     matrix2D(0)(0) = -999
  }
}

================================================================================
MULTI-DIMENSIONAL ARRAYS (PART 2)

Read in-line comments in the following code sample.  This code shows how
to populate a 100-element 2-dimensional Array with Array[Double] arrays
that have a RANDOM NUMBER of elements.  And where each number in the
Array[Double] is populated with a RANDOM NUMBER.

object Demo
{
  def main(args: Array[String])
  {
    // This program creates Arrays having a RANDOM NUMBER of Array elements.
    // To set the minimum and maximum number of elements contained in those
    // Arrays, change the following two values.
    val minNoOfElems:Int = 3
    val maxNoOfElems:Int = 6
    if (minNoOfElems < 2)
    {
      println(s"ERROR: minNoOfElems ($minNoOfElems) can't be less than 2.")
      return;
    }
    if (maxNoOfElems < minNoOfElems)
    {
      println(s"ERROR: maxNoOfElems ($maxNoOfElems) can't be less than minNoOfElems ($minNoOfElems).")
      return;
    }

    // HOW THE FOLLOWING LINE OF CODE WORKS:
    // 1) Array.fill(100) creates a 100-element Array that will hold
    //    an Array of type Array[Double].
    // 2) When EACH of those 100 Array elements is created, the block
    //    of code between the braces {} executes.
    // 3) Read comments below for further details.
    val array2D:Array[Array[Double]] =
        Array.fill(100) {
          // THIS BLOCK OF CODE EXECUTES ONCE FOR EACH OF THE 100 ARRAY ELEMENTS CREATED.
          //
          // randNumOfElems is the number of elements the Array[Double] will contain.
          val randNumOfElems:Int = util.Random.nextInt(maxNoOfElems+1)

          // Create an Array[Double] with the appropriate number of elements,
          // and populate each element with a RANDOM NUMBER (of type Double)
          // from 0.0 to < 1.0.  NOTE: If randNumOfElems < minNoOfElems,
          // minNoOfElems becomes the size of the Array[Double].
          if (randNumOfElems < minNoOfElems)
            Array.fill(minNoOfElems)(math.random)
          else
            Array.fill(randNumOfElems)(math.random)
    }

    var count:Int = 0;

    // Loop through every element in array2D and print its contents...
    for (idx <- array2D.indices) {
      for (jdx <- array2D(idx).indices)  {
        count += 1
        println("array2D(" + idx + ")(" + jdx + ") = " + array2D(idx)(jdx) + " (Element #" + count + ")")
      }
    }

    println("===========================================")
    println("Loop through every element in array2D that contains a 3-element Array.")
    println("Then, calculate and print the average of those 3 numbers for each element.")
    var result:Array[Double] = for (Array(d1, d2, d3) <- array2D) yield (d1 + d2 + d3) / 3
    result.foreach(println)

    println("===========================================")
    println("Loop through every element in array2D that contains a 4-element Array.")
    println("Then, calculate and print the average of those 4 numbers for each element.")
    result = for (Array(d1, d2, d3, d4) <- array2D) yield (d1 + d2 + d3 + d4) / 4
    result.foreach(println)
  }
}

================================================================================
RECURSION - The following code sample demonstrates how to use a recursive
            function to obtain the result of multiplying the contents of
            an Array[Int].

object Demo
{
  def main(args: Array[String])
  {
    val arr:Array[Int] = Array(23, 32, 64)

    // The second element passed to operateOnArray() designates the index
    // of the first Array element to be included in the tabulation.  EXAMPLE:
    // If the index value is 2, the tabulation will begin with the Array(2)
    // element--the Array(0) and Array(1) elements will NOT be included
    // in the tabulation.
    val result:Int = operateOnArray(arr, 0, _*_)
    println("result = " + result) // PRINTS: result = 47104
  }

  /**
   * This RECURSIVE function loops through the elements of the Array passed
   * to it, BEGINNING at the Array index value passed to this function.
   * Each time this function calls itself, it performs an operation on the
   * Array(index) and Array(index+1) elements.  This function terminates
   * when the index passed to it equals the length of the Array passed to it.
   */
  def operateOnArray(arr:Array[Int], index:Int, func:(Int, Int) => Int):Int =
  {
    if (index < arr.length-1)
      func(arr(index), operateOnArray(arr, index+1, func))
    else
      arr(arr.length-1)
  }
}

================================================================================
The sample program BELOW uses an Array to calculate annual growth
at a given interest rate.

object Demo
{
  def main(args: Array[String])
  {
    val yearRange:Range = 1 to 150
    val annualPercentGrowthRate:Float = 2.0F

    println("YEAR  - UNITS CONSUMED - ANNUAL PERCENT GROWTH RATE") // Prints the header.

    // NOTE: Calling zipWithIndex in the following line transforms the data type
    //       of "array" into a tuple value of (Any, Int) = (result, index)
    //       The index value represents the element index of array, which is
    //       the value that gets "zipped" with result.
    val array:Array[(Any, Int)] = (new Array(yearRange.size)).zipWithIndex
    calculate(array, annualPercentGrowthRate*0.01F)
    array.foreach{ x => printResult(x._1, x._2, annualPercentGrowthRate) }
  }

  /**
   *  NOTE: Each element of the array passed to this method holds a tuple of type: (Any, Int)
   *        The Any value stores the result as a Float, and the Int stores the array index.
   */
  def calculate(array:Array[(Any, Int)], percent:Float):Unit = {
    for (x <- array) {
      if (x._2 == 0) // x._2 stores the index of the current array element.
        array(0) = (1.0F, 0) // Set the first element of the array tuple, which ALWAYS = (1.0F, 0)
      else {
        // Calculate the result for the current array element and set it.
        val resultInPreviousArrayElement:Float = array(x._2 - 1)._1.asInstanceOf[Float]
        val currentResult:Float = (resultInPreviousArrayElement * percent) + resultInPreviousArrayElement
        array(x._2) = (currentResult, x._2)
      }
    }
  }

  def printResult(result:Any, index:Int, annualPercentGrowthRate:Float):Unit =
  {
    val floatResult:Float = result.asInstanceOf[Float]

    if (index < 10)
      printf("%d     - %14.2f - %5.2f\n", index, floatResult, annualPercentGrowthRate)
    else if (index < 100)
      printf("%d    - %14.2f - %5.2f\n", index, floatResult, annualPercentGrowthRate)
    else if (index < 1000)
      printf("%d   - %14.2f - %5.2f\n", index, floatResult, annualPercentGrowthRate)
    else
      printf("%d  - %14.2f - %5.2f\n", index, floatResult, annualPercentGrowthRate)
  }
}

