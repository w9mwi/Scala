TABLE OF SCALA REGULAR EXPRESSION FORMATS
=========================================

The below table was copied from:
https://blog.knoldus.com/how-to-use-regular-expression-in-scala

Also see this table for Scala regular expressions:
https://www.geeksforgeeks.org/regular-expressions-in-scala/?ref=gcse


Anchors — ^ and $

^a        matches any string that starts with a 
b$        matches a string that ends with b
^a b$   exact string match (starts and ends with a b)


Quantifiers — * + ? and {}

abc*    matches a string that has ab followed by zero or more c
abc+    matches a string that has ab followed by one or more c
abc?    matches a string that has ab followed by zero or one c
abc{2}  matches a string that has ab followed by 2 c
abc{2,} matches a string that has ab followed by 2 or more c
a(bc)*  matches a string that has a followed by zero or more copies of the sequence bc
a(bc)*  matches a string that has a followed by zero or more copies of the sequence bc
a(bc){2,5} matches a string that has a followed by 2 up to 5 copies of the sequence bc


OR operator — | or [ ]

a(b|c)   matches a string that has a followed by b or c (and captures b or c)
a[bc]    same as previous, but without capturing b or c


Character classes — \d \w \s and .

\d    matches a single character that is a digit
\w    matches a word character (alphanumeric character plus underscore)
\s    matches a whitespace character (includes tabs and line breaks)
.     matches any character

\d, \w and \s also present their negation with \D, \W and \S respectively.


Grouping and capturing — ( )

a(bc)  parentheses create a capturing group with value bc
a(?<foo>bc)  using ?<foo> we put a name to the group


Greedy and Lazy match:

Quantifiers (* + {}) are greedy operators, so they extend the match through the given text.


Boundaries — \b and \B

\babc\b   Performs a "whole words only" search pattern

\b represents an anchor like a caret (it’s the same as $ and ^ )
matching position where one side is a word character (like \w)
and the other side is not a word character (e.g. this string
beginning may contain or a space character)


Look-ahead and Look-behind — (?=) and (?<=)

d(?=r)   matches a d only if is followed by r, but r will not be part of the overall regex match
(?<=r)d  matches a d only if is preceded by an r, but r will not be part of the overall regex match

=========================================================


