TABLE OF SCALA REGULAR EXPRESSION FORMATS
=========================================

The below table was copied from:
https://blog.knoldus.com/how-to-use-regular-expression-in-scala

Also see this table for Scala regular expressions:
https://www.geeksforgeeks.org/regular-expressions-in-scala/?ref=gcse


Anchors — ^ and $

^a        matches any string that starts with a 
b$        matches a string that ends with b
^a b$   exact string match (starts and ends with a b)


Quantifiers — * + ? and {}

abc*    matches a string that has ab followed by zero or more c
abc+    matches a string that has ab followed by one or more c
abc?    matches a string that has ab followed by zero or one c
abc{2}  matches a string that has ab followed by 2 c
abc{2,} matches a string that has ab followed by 2 or more c
a(bc)*  matches a string that has a followed by zero or more copies of the sequence bc
a(bc)*  matches a string that has a followed by zero or more copies of the sequence bc
a(bc){2,5} matches a string that has a followed by 2 up to 5 copies of the sequence bc


OR operator — | or [ ]

a(b|c)   matches a string that has a followed by b or c (and captures b or c)
a[bc]    same as previous, but without capturing b or c


Character classes — \d \w \s and .

\d    matches a single character that is a digit
\w    matches a word character (alphanumeric character plus underscore)
\s    matches a whitespace character (includes tabs and line breaks)
.     matches any character

\d, \w and \s also present their negation with \D, \W and \S respectively.


Grouping and capturing — ( )

a(bc)  parentheses create a capturing group with value bc
a(?<foo>bc)  using ?<foo> we put a name to the group


Greedy and Lazy match:

Quantifiers (* + {}) are greedy operators, so they extend the match through the given text.


Boundaries — \b and \B

\babc\b   Performs a "whole words only" search pattern

\b represents an anchor like a caret (it’s the same as $ and ^ )
matching position where one side is a word character (like \w)
and the other side is not a word character (e.g. this string
beginning may contain a space character)


Look-ahead and Look-behind — (?=) and (?<=)

d(?=r)   matches a d only if is followed by r, but r will not be part of the overall regex match
(?<=r)d  matches a d only if is preceded by an r, but r will not be part of the overall regex match

=========================================================

The following sample program demonstrates how to use Regex in Scala.


import scala.util.matching.Regex

object Demo
{
  def main(args: Array[String]): Unit =
  {
    // ************************************************************************
    // The regexStr below is defined as follows:
    // ([0-9]{2})  -  The string MUST BEGIN with 2 digits and...
    // :           -  MUST be followed by a colon character and...
    // ([0-9]{2})  -  MUST be followed by 2 digits and...
    // :           -  MUST be followed by a colon character and...
    // ([0-9]{2})  -  MUST be followed by 2 digits and...
    // .           -  MUST be followed by a period character and...
    // ([0-9]{3})  -  the string MUST END with 3 digits.
    // The following 2 lines represent an identical Regex value.  A Regex value
    // can generated by calling the ".r" method on a String, or by instantiating
    // a new Regex class.
    var regexStr:String   = "([0-9]{2}):([0-9]{2}):([0-9]{2}).([0-9]{3})"
    val timestamp_1:Regex = regexStr.r
    val timestamp_2:Regex = new Regex(regexStr)
    "11:34:01.411" match
    {
      // The following line prints: Time_1 = 11:34
      case timestamp_1(hour, minutes, _, _) => println(s"Time_1 = $hour:$minutes")
    }
    "11:34:01.411" match
    {
      // The following line prints: Time_2 = 11:34
      case timestamp_2(hour, minutes, _, _) => println(s"Time_2 = $hour:$minutes")
    }

    // ************************************************************************
    // The regexStr below is defined as follows:
    // ([0-9]{2}|[0-9]{4})  -  The string MUST BEGIN with 2 digits OR 4 digits and...
    // [a-z|A-Z]{2}         -  MUST be followed by 2 alpha characters (not case sensitive) and...
    // [0-9]{1,6}           -  MUST be followed by 1 to 6 digits and...
    // [a-z|A-Z]{0,2}       -  the string can end with 0 to 2 alpha characters (not case sensitive).
    regexStr = "([0-9]{2}|[0-9]{4})[a-z|A-Z]{2}[0-9]{1,6}[a-z|A-Z]{0,2}"
    var caseNo:String = "1975Az1234uP"
    var isValid:Boolean = caseNo.matches(regexStr)
    if (isValid) println(s"caseNo $caseNo is valid.") // PRINTS: caseNo 1975Az1234uP is valid.
    else         println(s"caseNo $caseNo is not valid.")

    // Using the regexStr defined above, find all valid caseNos in the following
    // caseNo string, and return them in a comma-delimited string.
    var regex:Regex = regexStr.r
    caseNo = "jsef8wf wfeh 98wef ;']89WL123;+=89CG1$%\n\n\tjsdfj2002SP1ASx987"
    var result:String = regex.findAllIn(caseNo).mkString(", ")
    println(result) // PRINTS: 89WL123, 89CG1, 2002SP1AS
  }
  // ************************************************************************
}



