If you need to read/write data in formats other than individual bytes
(Strings, Chars, Ints, Floats, Doubles, Booleans, Bytes, etc.), use
DataInputStream and DataOutputStream.

Remember, these classes and methods come from the java.io package.
So refer to the Java API for docs regarding these classes and methods:
https://docs.oracle.com/javase/9/docs/api/overview-summary.html

DataInputStream includes the following methods:
___ readBoolean():Boolean
___ readByte():Byte
___ readChar():Char
___ readDouble():Double
___ readFloat():Float
___ readInt():Int
___ readLong():Long
___ readShort():Short
___ readUTF():String

DataOutputStream includes the following methods:
___ writeBoolean(v:Boolean):Unit
___ writeByte(v:Int):Unit
___ writeBytes(s:String):Unit
___ writeChar(v:Int):Unit
___ writeChars(s:String):Unit
___ writeDouble(v:Double):Unit
___ writeFloat(v:Float):Unit
___ writeInt(v:Int):Unit
___ writeLong(v:Long):Unit
___ writeShort(v:Int):Unit
___ writeUTF(str:String):Unit

In almost all casses you'll want to use buffering when doing file I/O for performance
reasons.  So you'll want to wrap DataInputStream and DataInputStream around
BufferedInputStream and BufferedOutputStream like in the following examples:

val dis = new DataInputStream(new BufferedInputStream(new FileInputStream(fileName)))
val dos = new DataOutputStream(new BufferedOutputStream(new FileOutputStream(fileName)))

========================================================================================
object Demo
{
  import java.io._

  def main(args: Array[String])
  {
    val fileName:String = "/home/tbouril/arrayOfDoubles.bin"

    // Write 10 random Doubles to a file named arrayOfDoubles.bin...
    writeArrayOfDoubles(fileName, Array.fill(10)(math.random))
    // Read and print all Double numbers contained in the arrayOfDoubles.bin file...
    var doubleArray:Array[Double] = readArrayOfDoubles(fileName)
    doubleArray.foreach(println) // PRINTS: The entire contents of doubleArray.

    println("=====================")

    // Write 10 random Doubles to a file named arrayOfDoubles.bin...
    // The following code does exactly the same as the above code, except
    // it calls writeDoubleArray() instead of writeArrayOfDoubles(), and
    // readDoubleArray() instead of readArrayOfDoubles().
    writeDoubleArray(fileName, Array.fill(10)(math.random))
    // Read and print all Double numbers contained in the arrayOfDoubles.bin file...
    doubleArray = readDoubleArray(fileName)
    doubleArray.foreach(println) // PRINTS: The entire contents of doubleArray.
  }

  def writeArrayOfDoubles(fileName:String, arrayOfDoubles:Array[Double]) =
  {
    val dos = new DataOutputStream(new BufferedOutputStream(new FileOutputStream(fileName)))
    try
    {
      // NOTE: When the array of Doubles is later read from the file,
      //       Array.fill()() gets called, where its first param list
      //       is the Int size of the Array.  Therefore, before writing
      //       the Array of Doubles to the file, we must first write
      //       the Int size of the Array...
      dos.writeInt(arrayOfDoubles.size)
      arrayOfDoubles.foreach(x => dos.writeDouble(x))
    } finally { dos.close() }
  }

  def readArrayOfDoubles(fileName:String):Array[Double] =
  {
    val dis = new DataInputStream(new BufferedInputStream(new FileInputStream(fileName)))
    try     { Array.fill(dis.readInt)(dis.readDouble) }
    finally { dis.close() }
  }

  def writeDoubleArray(fileName:String, data:Array[Double])
  {
    withDOS(fileName)(dos => {
      // NOTE: When the array of Doubles is later read from the file,
      //       Array.fill()() gets called, where its first param list
      //       is the Int size of the Array.  Therefore, before writing
      //       the Array of Doubles to the file, we must first write
      //       the Int size of the Array...
      dos.writeInt(data.size)
      data.foreach(x => dos.writeDouble(x))
    })
  }

  def readDoubleArray(fileName:String):Array[Double] =
  {
    withDIS(fileName)(dis => Array.fill(dis.readInt)(dis.readDouble))
  }

  /**
    * This function contains TWO parameter lists.
    * The name of this function withDOS() stands for: with DataOutputStream
    */
  def withDOS[A](fileName:String)(func:DataOutputStream => A):A =
  {
    val dos = new DataOutputStream(new BufferedOutputStream(new FileOutputStream(fileName)))
    try     { func(dos) }
    finally { dos.close() }
  }

  /**
    * This function contains TWO parameter lists.
    * The name of this function withDIS() stands for: with DataInputStream
    */
  def withDIS[A](fileName:String)(func:DataInputStream => A):A =
  {
    val dos = new DataInputStream(new BufferedInputStream(new FileInputStream(fileName)))
    try     { func(dos) }
    finally { dos.close() }
  }
}
========================================================================================

object Demo
{
  import java.io._

  // NOTE: The Student class defined here "extends Serializable".  The
  //       reason for extending the Student class to Serializable is so
  //       that we can then use methods defined in ObjectInputStream and
  //       ObjectOutputStream.  Since "case class" Scala types automatically
  //       extends Serializable, if the following Student class was instead
  //       a "case class", we wouldn't have to extends Serializable.
  class Student(val name:String, val grades:Array[Int]) extends Serializable

  /**
    * This Scala program gets run from the command line.  The first time you run this
    * program from the command line, you pass it arguments that tell the program to
    * generates a new file named junk.bin, and WRITE DATA to that file.  The next
    * time you run this program, you pass it arguments that tell the program to
    * READ DATA from that junk.bin file, and print that data to the console window.
    * Follow these instructions:
    *
    * 1) Save this text file to a file named: Demo.scala
    * 2) From the command line window, compile this file and
    *    execute the compiled file by doing the following...
    *    $ scalac Demo.scala
    *    $ scala Demo -w junk.bin John 98 78 88 93 100 83
    *    $ scala Demo -r junk.bin
    *
    * @param args Arguments passed from the command line shown above.
    */
  def main(args: Array[String])
  {
    val fileName:String = args(1)

    args(0) match
    {
      case "-r" => // Read data from fileName...
        val ois = new ObjectInputStream(new BufferedInputStream(new FileInputStream(fileName)))
        ois.readObject() match
        {
          // The below call to mkString(", ") converts the student.grades Array[Int] to a string,
          // and adds a ", " string between each Array element.
          case student:Student => println(student.name + " " + student.grades.mkString(", "))
          case _               => println("Unidentified type.")
        }
        ois.close()

      case "-w" => // Write data to fileName...
        val oos     = new ObjectOutputStream(new BufferedOutputStream(new FileOutputStream(fileName)))
        val student = new Student(args(2), args.drop(3).map(_.toInt))
        oos.writeObject(student)
        oos.close()

      case _ => println("Usage: (-r or -w) + fileName + studentName + grade_1  grade_2, ...")
    }
  }
}
