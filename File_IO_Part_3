If you need to read/write data in formats other than individual bytes
(Strings, Chars, Ints, Floats, Doubles, Booleans, Bytes, etc.), use
DataInputStream and DataOutputStream.

Remember, these classes and methods come from the java.io package.
So refer to the Java API for docs regarding these classes and methods:
https://docs.oracle.com/javase/9/docs/api/overview-summary.html

DataInputStream includes the following methods:
___ readBoolean():Boolean
___ readByte():Byte
___ readChar():Char
___ readDouble():Double
___ readFloat():Float
___ readInt():Int
___ readLong():Long
___ readShort():Short
___ readUTF():String

DataOutputStream includes the following methods:
___ writeBoolean(v:Boolean):Unit
___ writeByte(v:Int):Unit
___ writeBytes(s:String):Unit
___ writeChar(v:Int):Unit
___ writeChars(s:String):Unit
___ writeDouble(v:Double):Unit
___ writeFloat(v:Float):Unit
___ writeInt(v:Int):Unit
___ writeLong(v:Long):Unit
___ writeShort(v:Int):Unit
___ writeUTF(str:String):Unit

In almost all casses you'll want to use buffering when doing file I/O for performance
reasons.  So you'll want to wrap DataInputStream and DataInputStream around
BufferedInputStream and BufferedOutputStream like in the following examples:

val dis = new DataInputStream(new BufferedInputStream(new FileInputStream(fileName)))
val dos = new DataOutputStream(new BufferedOutputStream(new FileOutputStream(fileName)))

========================================================================================

object Demo
{
  import java.io._

  def main(args: Array[String])
  {
    val fileName:String = "/home/tbouril/arrayOfDoubles.bin"
    // Write 10 random Doubles to a file named arrayOfDoubles.bin...
    writeDoubleArray(fileName, Array.fill(10)(math.random))

    // Read and print all Double numbers contained in the arrayOfDoubles.bin file...
    var doubleArray:Array[Double] =readArrayOfDoubles(fileName)
    doubleArray.foreach(println) // PRINTS: The entire contents of doubleArray.
    println("=====================")

    // THE FOLLOWING CODE DOES EXACTLY THE SAME AS THE ABOVE CODE,
    // EXCEPT IT USES THE HARDER-TO-UNDERSTAND  CURRIED FUNCTIONS
    // withDIS() and withDOS().
    // Write 10 random Doubles to a file named arrayOfDoubles.bin...
    writeDoubleArray(fileName, Array.fill(10)(math.random))

    // Read and print all Double numbers contained in the arrayOfDoubles.bin file...
    doubleArray = readDoubleArray(fileName)
    doubleArray.foreach(println) // PRINTS: The entire contents of doubleArray.
  }

  def writeDoubleArray(fileName:String, data:Array[Double])
  {
    withDOS(fileName)(dos => {
                               // NOTE: When the array of Doubles is later read from the file,
                               //       Array.fill()() gets called, where its first param list
                               //       is the Int size of the Array.  Therefore, before writing
                               //       the Array of Doubles to the file, we must first write
                               //       the Int size of the Array...
                               dos.writeInt(data.size)
                               data.foreach(x => dos.writeDouble(x))
                             })
  }

  def readDoubleArray(fileName:String):Array[Double] =
  {
    withDIS(fileName)(dis => {
                               Array.fill(dis.readInt)(dis.readDouble)
                             })
  }

  /**
    * The name of this function withDOS() stands for: with DataOutputStream
    */
  def withDOS[A](fileName:String)(func:DataOutputStream => A):A =
  {
    val dos = new DataOutputStream(new BufferedOutputStream(new FileOutputStream(fileName)))
    try
    { func(dos) }
    finally
    { dos.close() }
  }

  /**
    * The name of this function withDIS() stands for: with DataInputStream
    */
  def withDIS[A](fileName:String)(func:DataInputStream => A):A =
  {
    val dos = new DataInputStream(new BufferedInputStream(new FileInputStream(fileName)))
    try
    { func(dos) }
    finally
    { dos.close() }
  }

  def writeArrayOfDoubles(fileName:String, arrayOfDoubles:Array[Double]) =
  {
    val dos = new DataOutputStream(new BufferedOutputStream(new FileOutputStream(fileName)))
    try
    {
      // NOTE: When the array of Doubles is later read from the file,
      //       Array.fill()() gets called, where its first param list
      //       is the Int size of the Array.  Therefore, before writing
      //       the Array of Doubles to the file, we must first write
      //       the Int size of the Array...
      dos.writeInt(arrayOfDoubles.size)
      arrayOfDoubles.foreach(x => dos.writeDouble(x))
    }
    finally
    { dos.close() }
  }

  def readArrayOfDoubles(fileName:String):Array[Double] =
  {
    val dis = new DataInputStream(new BufferedInputStream(new FileInputStream(fileName)))
    try
    {
      Array.fill(dis.readInt)(dis.readDouble)
    }
    finally
    { dis.close() }
  }
}

========================================================================================

object Demo
{
  import java.io._

  class Student(val name:String, val grades:Array[Int]) extends Serializable

  /**
    * This Scala program gets run from the command line.  The first time you run this
    * program from the command line, you pass it arguments that tell the program to
    * generates a new file named junk.bin, and WRITE DATA to that file.  The next
    * time you run this program, you pass it arguments that tell the program to
    * READ DATA from that junk.bin file, and print that data to the console window.
    * Follow these instructions:
    *
    * 1) Save this text file to a file named: Demo.scala
    * 2) From the command line window, compile this file and
    *    execute the compiled file by doing the following...
    *    $ scalac Demo.scala
    *    $ scala Demo -w junk.bin John 98 78 88 93 100 83
    *    $ scala Demo -r junk.bin
    *
    * @param args Arguments passed from the command line shown above.
    */
  def main(args: Array[String])
  {
    args(0) match
    {
      case "-r" =>
        val ois = new ObjectInputStream(new BufferedInputStream(new FileInputStream(args(1))))
        ois.readObject() match
        {
          case student:Student => println(student.name + " " + student.grades.mkString(", "))
          case _               => println("Unidentified type.")
        }
        ois.close()

      case "-w" =>
        val oos     = new ObjectOutputStream(new BufferedOutputStream(new FileOutputStream(args(1))))
        val student = new Student(args(2), args.drop(3).map(_.toInt))
        oos.writeObject(student)
        oos.close()

      case _ => println("Usage: (-r or -w) + filename + personName + grade_1  grade_2, ...")
    }
  }
}
