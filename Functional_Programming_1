BASIC FUNCTIONAL PROGRAMMING RULES TO FOLLOW
============================================
1) Use no Null values.  In place of using
   Null, use instead the Option/Some/None
   or Try/Success/Failure types.
2) Use only pure functions, which never return
   Null or throw exceptions.
3) Use immutable "val" instead of mutable "var"
4) Whenever you use an if() statement, always
   use an accompanying else statement.

================================================================
Call-By-Value parameter - If you define a Person class such as this...

                          case class Person(var name:String)
                          
                          ...and then pass it into a Scala function it's a Call-By-Value argument,
                          which is a POINTER to the Person object passed to the method/function.
                          This means there is no copy of the Person object, just a pointer to
                          the Person object that exists somewhere in RAM.  If the argument is
                          a "var", it means you can alter the contents (mutate) of that object.
                          Call-By-Value means the parameter is either a primitive type that
                          can't be changed (i.e., Int), or a pointer to an object like the above
                          Person object.
Call-By-Name Parameter - A Call-By-Name parameter is like a parameter that's a "def method";
                         its body is evaluated whenever it's used inside the function.
                         Better names for Call-By-Name might be:
                         * Call-On-Access          * Evaluate-On-Access        * Evaluate-On-Use
                         * Evaluate-When-Accessed  * Evaluate-When-Referenced
                         

================================================================
object Demo
{
  def main(args: Array[String])
  {
    val intList:List[Int] = List(1, 2, 3).map(doubleFunc)
    intList.foreach(print) // PRINTS: 246
    println

    // The following line of commented-out code will NOT compile.  To rectify this
    // problem, the commented-out line can be rewritten like the TWO LINES
    // immediately below it.  To understand the what the underscore character (_)
    // does in the functions2 declaration below, read about Eta Expansions on this
    // github page:  https://github.com/w9mwi/Scala/blob/master/Eta_Expansion
    // val functions_1                        = Map("2X" -> doubleFunc,   "3X" -> tripleFunc)
    val functions_1:Map[String, (Int) => Int] = Map("2X" -> doubleFunc,   "3X" -> tripleFunc)
    val functions_2                           = Map("2X" -> doubleFunc _, "3X" -> tripleFunc _)

    var doubleVar = functions_1("2X") // PRINTS: 246
    var tripleVar = functions_1("3X") // PRINTS: 369
    println(doubleVar(123))
    println(tripleVar(123))

    doubleVar = functions_2("2X") // PRINTS: 246
    tripleVar = functions_2("3X") // PRINTS: 369
    println(doubleVar(123))
    println(tripleVar(123))
  }

  def doubleFunc(i:Int):Int = { i * 2 }
  def tripleFunc(i:Int):Int = { i * 3 }
}
===========================================================
object Demo
{
  def main(args: Array[String])
  {
    val intList:List[Int] = List.range(0, 12)
    var evenInts = intList.filter(isEven)
    evenInts.foreach(print)  // PRINTS: 0246810

    // Here's a second way of obtaining the identical
    // evenInts result shown above...
    evenInts = intList.filter(_ % 2 == 0)
    println
    evenInts.foreach(print)  // PRINTS: 0246810

    // Here's a third way of obtaining the identical
    // evenInts result shown above...
    evenInts = intList.filter(i => (i % 2 == 0))
    println
    evenInts.foreach(print)  // PRINTS: 0246810
  }

  def isEven(number: Int) = number % 2 == 0
}
==========================================================
object Demo
{
  type IntTuple = (Int, Int)

  def main(args: Array[String])
  {
    sayHello(helloJoe)  // PRINTS: Hey, Joe!
    println
    executeNtimes(helloJoe, 5)  // PRINTS: Hey, Joe!  Hey, Joe!  Hey, Joe!  Hey, Joe!  Hey, Joe!
    println
    executeAndPrint(sum, 7, 4)      // PRINTS: 11  (7 + 4 = 11)
    executeAndPrint(multiply, 7, 4) // PRINTS: 28  (7 * 4 = 28)

    val intTuple:IntTuple = executeTwoFunctions(sum, multiply, 7, 4)
    println("intTuple = " + intTuple) // PRINTS: intTuple = (11,28)
    println("sum(7, 4) = " + intTuple._1 +
            ", multiply(7, 4) = " + intTuple._2) // PRINTS: sum(7, 4) = 11,  multiply(7, 4) = 28
  }

  def sayHello(callback: () => Unit): Unit = { callback() }
  def helloJoe(): Unit                     = { print("Hey, Joe!  ") }

  def executeNtimes(func: () => Unit, n: Int): Unit =
  {
    for (x <- 1 to n) { func() }
  }

  def executeAndPrint(func: ((Int, Int) => Int), x:Int, y:Int):Unit =
  {
    val result:Int = func(x, y)
    println(result)
  }

  def executeTwoFunctions(f1:(Int, Int) => Int,
                          f2:(Int, Int) => Int,
                          a:Int, b:Int): IntTuple =
  {
    val result1 = f1(a, b)
    val result2 = f2(a, b)
    (result1, result2)  // EQUIVALENT TO THIS LINE OF CODE : (f1(a, b),  f2(a, b))
  }

  def sum(number1: Int, number2: Int)      = number1 + number2
  def multiply(number1: Int, number2: Int) = number1 * number2
}
==========================================================
object Demo
{
  /**
    * This program demonstrates how to program our own map() method/function,
    * which can be called via any Seq type, such as an Array, List, String,
    * Vector, etc.
    *
    * The map() function written below is a PARAMETRIC function, which means
    * it will work on any type that inherits from the Seq type.
    */
  def main(args: Array[String])
  {
    // Call the map() function below via a List type--which is a subtype of Seq.
    val list:List[Int] = List(1, 2, 3)
    val myMap:Seq[Int] = map(timesTwo, list)
    myMap.foreach(print) // PRINTS: 246  (Which comes from: 1*2=2, 2*2=4, 2*3=6)
    println()

    // Call the map() function below via a String type--which is a subtype of Seq.
    val list2:List[String] = List("Tom", "Jim", "Beam")
    val myMap2:Seq[String] = map(doubleString, list2)
    myMap2.foreach(print) // PRINTS: Tom_TomJim_JimBeam_Beam
  }

  /**
    * This map function is a PARAMETRIC function because it will work on any
    * type that inherits from the Seq type.
    */
  def map[A,B](func: (A) => B, list:Seq[A]):Seq[B] =
  {
    val result:Seq[B] = { for { x <- list } yield func(x) }
    result
  }

  def timesTwo(number:Int):Int        = { number * 2 }
  def doubleString(str:String):String = { str + "_" + str }
}
==========================================================
