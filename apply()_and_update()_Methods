THE APPLY METHOD
----------------
The apply() method is written just like any other method in a class,
and you can call it just like any other method.  However, Scala will
let you call the apply() method without using a period char (.), or
using the name "apply"!!!  When you remove the period char (.) and
the "apply" name, it makes it look like you're treating the object as
a function--this is how all functions work in Scala.  Everything
in Scala is an object, including functions.

When you call an Array or a List with an integer index you are invoking
the Array's or List's apply() method.  EXAMPLE:

val myArray = Array(8, 4, 12, 76, 99)
val myList  = List(66, 31, 8, 93, 13)
Calling myArray(3) is equivalent to calling myArray.apply(3)--both return the Int 76.
Calling myList(4) is equivalent to calling myList.apply(4)--both return the Int 13.

When you declare a new class without calling the "new" keyword, the apply() method
is being called, and the apply() method then calls "new".  If a class has an apply()
method, you can create an instance of it without calling the "new" keyword.
====================================================================================

object Demo
{
  class Student(val name:String, val id:String)
  {
    var tests       = List[Double]()
    var quizzes     = List[Double]()
    var assignments = List[Double]()

    def testAvg       = tests.sum / tests.size
    def quizAvg       = quizzes.sum / quizzes.size
    def assignmentAvg = assignments.sum / assignments.size
  }

  class CourseSection(val subject:String, val number:Int, val title:String)
  {
    private var students:List[Student] = List[Student]()

    def addStudent(stud:Student) { students ::= stud }
    def getStudents():List[Student] = { students }

    /**
      * This apply() method returns an Option type.  If the key String passed to this method
      * matches the name, or the id, of one or more Students, it returns the Some object
      * containing a List of Students; otherwise, the None object is returned.
      */
    def apply(key:String):Option[Student] =
    {
      println("The CourseSection.apply() method has been called.")
      // NOTE: The s.id and s.name references below will generate a compile error
      //       if the Student class doesn't have a val or var preceding its name
      //       and id parameters.
      students.find(s => (s.id == key || s.name == key))
    }
  }

  def main(args: Array[String]):Unit =
  {
    val john:Student         = new Student("John Doe", "0123456")
    val tom:Student          = new Student("Tom B",    "6543210")
    val course:CourseSection = new CourseSection("CSCI", 1321, "Principles of Programming II")
    course.addStudent(john)
    course.addStudent(tom)

    // Here we see that calling course() and course.apply() are equivalent...
    // course("0123456") and course.apply("0123456") both return the type: Option[Student]
    // course("Tom B")   and course.apply("Tom B")   both return the type: Option[Student]
    course("0123456").get.quizzes = List(88.0)     // PRINTS: The CourseSection.apply() method has been called.
    course.apply("Tom B").get.quizzes = List(99.0) // PRINTS: The CourseSection.apply() method has been called.
    println(john.quizzes) // PRINTS: List(88.0)
    println(tom.quizzes)  // PRINTS: List(99.0)
    val studentList:List[Student] = course.getStudents()
    for (pop <- studentList)
    {
      println(pop.name + ", " + pop.id + ", " + pop.quizzes + ", " + pop.tests + ", " + pop.assignments)
    }

    // Search for a student in the course that's non-existent, (name/id = "XYZ")...
    val student:Option[Student] = course.apply("XYZ")
    if (student == None)
    {
      println("There is no student with a name/id = 'XYZ'")
    }
  }
}

====================================================================================
The apply() method is sufficient for many situations like immutable collections where
you only need to access an element of the collection (via the apply() method), but
never assign a value to an element.  To assign/change the value of an element of
a collection, the update() method is used.  For example...

obj(2) = 345.67
...would get converted to this call...
obj.update(2, 345.67)
====================================================================================
object Demo
{
  class Spreadsheet(rows:Int, cols:Int)
  {
    private val data = Array.fill(rows, cols)(0.0)  // data is a 2-dimensional Array.

    def apply(c:Int, r:Int):Double     = { data(r)(c) }
    def update(c:Int, r:Int, v:Double) = { data(r)(c) = v }

    def apply(c:String, r:Int):Double     = { data(r)(calcColumn(c)) }
    def update(c:String, r:Int, v:Double) = { data(r)(calcColumn(c)) = v }

    def apply(cell:String):Double =
    {
      // NOTE: The partition() method gets passed a function that returns a Boolean.
      //       The partition() method then returns two collections that make up a tuple.
      //       The first collection in the returned tuple contains only the elements for
      //       which the function passed to partition() is true.  The second collection
      //       in the returned tuple contains only the elements for which the function
      //       passed to partition() is false.  In this example, the tuple ("d", 8) is returned.
      val (c, r) = cell.partition(_.isLetter)
      data(r.toInt)(calcColumn(c))
    }

    def update(cell:String, v:Double) =
    {
      // NOTE: The partition() method gets passed a function that returns a boolean.
      //       The partition() method then returns two collections that make up a tuple.
      //       The first collection in the returned tuple contains only the elements for
      //       which the function passed to partition() is true.  The second collection
      //       in the returned tuple contains only the elements for which the function
      //       passed to partition() is false.  In this example, the tuple ("c", 5) is returned.
      val (c, r) = cell.partition(_.isLetter)
      data(r.toInt)(calcColumn(c)) = v
    }

    private def calcColumn(column:String):Int =
    {
      // NOTE: foldLeft is a curried function.  In this example, the first parameter passed to
      //       foldLeft is the value zero, which is used as the first operand.  The second
      //       parameter is a function that gets passed a tuple (value,column), and returns an Int.
      column.toLowerCase.foldLeft(0)((value,column) => value*26+(column-'a'))
    }
  }

  def main(args: Array[String]):Unit =
  {
    val ss = new Spreadsheet(10, 10)
    ss("c5") = 14  // This line of code calls the above update() method.
    ss(3,8) = 24
    // The following println() prints this:
    // ss("c5") = 14.0
    // ss(3,8)  = 24.0
    // ss("d8") = 24.0   NOTE: ss("d8") points to the same (row,column) cell as does ss(3,8)
    println("ss(\"c5\") = " + ss("c", 5) + "\nss(3,8)  = " + ss(3,8) + "\nss(\"d8\") = " + ss("d8"))
  }
}
====================================================================================
object Demo
{
  class Vect(val x:Double, val y:Double, val z:Double)
  {
    def +(v:Vect):Vect   = new Vect(x+v.x, y+v.y, z+v.z)
    def -(v:Vect):Vect   = new Vect(x-v.x, y-v.y, z-v.z)
    def *(c:Double):Vect = new Vect(c*x,   c*y,   c*z)
    def /(c:Double):Vect = new Vect(c/x,   c/y,   c/z)
    def dotProduct(v:Vect):Double = x*v.x + y*v.y + y+ z*v.z
    def crossProduct(v:Vect):Vect = new Vect(y*v.z - z*v.y,
                                             z*v.x - x*v.z,
                                             x*v.y - y*v.x)

    // This apply() function gets called in the main() method below
    // when referencing a Vector's x, y, or z member via an index,
    // such as:  v1(0),  v1(1),  v1(2)
    def apply(idx:Int):Double = idx match
    {
      case 0 => x
      case 1 => y
      case 2 => z
    }

    // This apply() method is NOT called by any code.
    def apply(is:Seq[Int]):Seq[Double] =
    {
      is.map(Array(x,y,z))
    }

    override def toString:String = { "<" + x + ", " + y + ", " + z + ">" }
  }

  def main(args: Array[String]):Unit =
  {
    val v1 = new Vect(1, 77.88, 3)
    val v2 = new Vect(2, -4, 7)
    val v3 = v1 + v2
    val v4 = v3 * 8
    println("v1 = " + v1.toString) // PRINTS: v1 = <1.0, 77.88, 3.0>
    println("v2 = " + v2.toString) // PRINTS: v2 = <2.0, -4.0, 7.0>
    println("v3 = v1 + v2 = " + v3.toString) // PRINTS: v3 = v1 + v2 = <3.0, 73.88, 10.0>
    println("v4 = v3 * 8 = " + v4.toString)  // PRINTS: v4 = v3 * 8 = <24.0, 591.04, 80.0>

    // The following println() calls this function 3 times: apply(idx:Int):Double
    // Once for v1(0), once time for v1(1), and once for v1(2)
    println("v1(0) = " + v1(0) + ", v1(1) = " + v1(1) + ", v1(2) = " + v1(2))
     // PRINTS: v1(0) = 1.0, v1(1) = 77.88, v1(2) = 3.0

    // The following println() prints the same values as the above println(), except they are
    // referenced via member vals, instead of via apply() method like the println() above.
    println("v1.x = " + v1.x + ",  v1.y = " + v1.y + ",  v1.z = " + v1.z)
     // PRINTS: v1.x = 1.0,  v1.y = 77.88,  v1.z = 3.0
  }
}
