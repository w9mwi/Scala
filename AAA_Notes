
The following sample program shows how to write the bind() function,
which is used to bind the results of these 3 functions into a single
final result...

1) doubleFunc()
2) tripleFunc()
3) quadFunc()


object Demo
{
  type IntStringTuple = (Int, String)

  def bind(func:(Int=>IntStringTuple), tuple:IntStringTuple):IntStringTuple =
  {
    // println("bind() called.")
    val (intResult, strResult):IntStringTuple = func(tuple._1)
    (intResult, tuple._2 + strResult) // PRINTS:
  }

  def doubleFunc(a:Int):IntStringTuple =
  {
    // println("doubleFunc() called.")
    val intResult:Int = a * 2
    (intResult, s"\ndoubleFunc result = $intResult")  // PRINTS: doubleFunc = 200
  }

  def tripleFunc(a:Int):IntStringTuple =
  {
    // println("tripleFunc() called.")
    val intResult:Int = a * 3
    (intResult, s"\ntripleFunc result = $intResult") // PRINTS: tripleFunc = 600
  }

  def quadFunc(a:Int):IntStringTuple =
  {
    // println("quadFunc() called.")
    val intResult:Int = a * 4
    (intResult, s"\nquadFunc = $intResult") // PRINTS: quadFunc = 2400
  }

  def main(args: Array[String]):Unit =
  {
    val doubleResult:IntStringTuple = doubleFunc(100)
    val tripleResult:IntStringTuple = bind(tripleFunc, doubleResult)
    val quadResult:IntStringTuple   = bind(quadFunc,   tripleResult)
    println(s"quadResult._1 =  ${quadResult._1}, quadResult._2 =  ${quadResult._2}")
    // PRINTS: quadResult._1 =  2400, quadResult._2 =
  }
}

==================================================================================

The following code sample defines and instantiates a class named Wrapper.
The Wrapper class does nothing more than wrap a single data value
(having the parametric type A) inside the Wrapper class.  The Wrapper
class also implements the following two (2) functions, which enables
the Wrapper class to work within a for() expression.

1) wrapper.flatMap()
2) Wrapper.map()

A for expression will work with ANYTHING that returns a data type that implements
both the map() and flatMap() functions--it doesn't have to be a class.

object Demo
{
  /**
   *   The ONLY purpose this Wrapper companion object (and its apply() method)
   *   serves is to allow the Wrapper class to be instantiated without using
   *   the 'new' keyword.
   */
  object Wrapper
  {
    def apply[A](value:A) = new Wrapper(value) // The 'new' keyword is REQUIRED here.
  }

  class Wrapper[A](value:A)
  {
    override def toString = value.toString

    def flatMap[B](func:A=>Wrapper[B]):Wrapper[B] =
    {
      println("flatMap() called.")
      func(value)
    }

    def map[B](func:A=>B):Wrapper[B] =
    {
      println("map() called.")
      val myValue:B = func(value)
      Wrapper(myValue)
    }
  }

  def main(args: Array[String]):Unit =
  {
    val wrap:Wrapper[Int]= Wrapper(123)
    println(wrap) // PRINTS: 123

    // The the following code shows that the for() expression can
    // be written using using parenthesis (), or using braces {}...
    var resultWrapper:Wrapper[Int] = for (x <- Wrapper(1);
                                          y <- Wrapper(2);
                                          z <- Wrapper(3)) yield x+y+z
    println(resultWrapper) // PRINTS: 6

    resultWrapper = for {x <- Wrapper(1)
                         y <- Wrapper(2)
                         z <- Wrapper(3)} yield x+y+z
    println(resultWrapper) // PRINTS: 6
  }
}

==================================================================================

