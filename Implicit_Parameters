A method can have an implicit parameter list, marked by the
'implicit' keyword at the start of the parameter list.  If
the method is called without passing the implicit parameter,
Scala will determine if it can obtain an implicit value of
the correct type, and if it can, pass it automatically.

A method, fuction, or constructor can have ONLY ONE implicit
paramater list, and it must be THE LAST PARAMETER LIST specified.

In the following code sample, if the main() function were to declare more
than one 'implicit String' val, or declare more than one 'implicit Boolean'
val, the code wouldn't compile.  It wouldn't compile because the compiler
can't determine which of the multiple 'implicit String' vals, or which of
the multiple 'implicit Boolean' vals, to pass as the implicit parameter.

In other words, there can be ONLY ONE implicit val/var of a given data type
declared in a function.

==========================================================================

object Demo
{
  def main(args: Array[String]): Unit =
  {
    implicit val str:String = "Fred" // This implicit MIGHT get used by the howdy() function.
    howdy("Jack") // PRINTS: Howdy, Jack
    howdy         // PRINTS: Howdy, Fred


    val number:Int = 54220
    implicit val test:Boolean = true  // This implicit val MIGHT get used by the printIntIfTrue()
                                      // or printIntAndNameIfTrue() functions.
    printIntIfTrue(number)(true)  // PRINTS: a = 54220
    printIntIfTrue(number)(false) // PRINTS NOTHING!
    printIntIfTrue(number)        // PRINTS: a = 54220
  }

  def howdy(implicit s: String) = println("Howdy, " + s)

  def printIntIfTrue(a:Int)(implicit test:Boolean):Unit =
  {
    if (test) { println("a = " + a) }
  }
}

==========================================================================
The following code sample shows another example of using
an implicit parameter.  Here, we make the add() function
a parametric function so it takes a Numeric type implicit
parameter, so it will work properly on all Numeric types,
such as Long, Int, Float, Double, etc.

As is always the case with implicit functions, if it's
called without specifying the implicit parameter, Scala
will determine if it can obtain an implicit value of the
correct type, and if it can, pass it automatically.

In the following example, the implicit parameter is never
designated so Scala passes that parameter for us, making
the add() function work as we want with all Numeric types.

object Demo
{
  // The following add()() function is defined with two (2) parameter lists,
  // which usually means it's a curried function.  However, because its
  // second  parameter list contains an implicit argument, it's NOT a
  // curried function.  The Scala compiler automatically invokes the
  // implicit parameter when the add()() function is called with only
  // one of its two parameter lists.
  //
  // This code shows how to define an add function so it will work with
  // different data types (Byte, Int, Long, Float, Double).  The returned
  // data type will be "upcast" to the highest of the two data types passed
  // to the function.
  def add[A](x:A, y:A)(implicit numeric:Numeric[A]):A = numeric.plus(x, y)

  def main(args:Array[String]): Unit =
  {
    val myByte:Byte     = 123
    val myInt:Int       = 456
    val myLong:Long     = 999999999L
    val myFloat:Float   = 876.543F
    val myDouble:Double = 1234567.890123D

    println("add(myByte, myInt)     = " + add(myByte, myInt))     // PRINTS: add(myByte, myInt)     = 579
    println("add(myInt, myLong)     = " + add(myInt, myLong))     // PRINTS: add(myInt, myLong)     = 1000000455
    println("add(myLong, myFloat)   = " + add(myLong, myFloat))   // PRINTS: add(myLong, myFloat)   = 1.0000009E9
    println("add(myFloat, myDouble) = " + add(myFloat, myDouble)) // PRINTS: add(myFloat, myDouble) = 1235444.433152785
    println("add(myByte, myDouble)  = " + add(myByte, myDouble))  // PRINTS: add(myByte, myDouble)  = 1234690.890123
    println("add(myInt, myFloat)    = " + add(myInt, myFloat))    // PRINTS: add(myInt, myFloat)    = 1332.543
  }
}


==========================================================================

The code below shows another example of using implicit parameters.
Read in-line comments for explanations.

object Demo
{
  def main(args: Array[String]): Unit =
  {
    trait Animal
    class Person(name:String) extends Animal
    {
      override def toString() = "Person"
    }
    class Employee(name:String) extends Person(name)
    {
      override def toString() = "Employee"
    }
    implicit val p:Person   = new Person("Person")
    implicit val e:Employee = new Employee("Employee")

    // NOTICE: You CAN pass an Employee to the printPerson()() function because
    //         an Employee extends Person, which means an Employee is defined
    //         to also be a Person.
    printPerson(true)     // PRINTS: p = Employee
    printPerson(false)    // PRINTS NOTHING!
    printPerson(true)(e)  // PRINTS: p = Employee
    printPerson(true)(p)  // PRINTS: p = Person
    printPerson(false)(e) // PRINTS NOTHING!
    printPerson(false)(p) // PRINTS NOTHING!

    // NOTICE: You CAN'T pass a Person to the printEmployee()() function because a
    //         Person doesn't extend Employee, which means a Person isn't defined
    //         to be an Employee.
    printEmployee(true)     // PRINTS: e = Employee
    printEmployee(false)    // PRINTS NOTHING!
    printEmployee(true)(e)  // PRINTS: e = Employee
    printEmployee(false)(e) // PRINTS NOTHING!
    // The following 2 lines are commented out because they won't compile.
    // As they both require an Employee to be passed as the 2nd parameter.
    // printEmployee(true)(p)  // Won't compile!
    // printEmployee(false)(p) // Won't compile!

    def printPerson(b:Boolean)(implicit p: Person) =
    {
      if (b) { println("p = " + p) }
    }

    def printEmployee(b:Boolean)(implicit e: Employee) =
    {
      if (b) { println("e = " + e) }
    }
  }
}

==========================================================================
An ALTERNATIVE to using implicit parameters is to use default parameters,
as shown in the code example below.  However, when you use default params,
you MUST include empty parenthesis () when calling the function.  Whereas
calling functions that have implicit params don't require empty parenthesis ().

object Demo
{
  def main(args: Array[String]): Unit =
  {
    // Demonstrate calling the add_1()() function...
    var number:Int = add_1()()
    println("number = " + number) // PRINTS: number = 10
    number = add_1(1)()
    println("number = " + number) // PRINTS: number = 8
    number = add_1()(2)
    println("number = " + number) // PRINTS: number = 5
    number = add_1(4)(5)
    println("number = " + number) // PRINTS: number = 9

    // Demonstrate calling the add_2()() function...
    number = add_2()()
    println("number = " + number) // PRINTS: number = 22
    number = add_2(1)()
    println("number = " + number) // PRINTS: number = 2
    number = add_2()(2)
    println("number = " + number) // PRINTS: number = 13
    number = add_2(11)(4)
    println("number = " + number) // PRINTS: number = 15
  }

  /**
   * This function contains 2 default parameters.  So when it's called with
   * one or two empty params, it uses the default values specified below.
   */
  def add_1(a: Int = 3)(b:Int = 7) =
  {
    a + b
  }

  /**
   * This function contains 2 default parameters, similar to the above
   * add_1()() function.  However, this function demonstrates how the
   * 2nd parameter (b) uses the first parameter (a) as a default value.
  **/
  def add_2(a: Int = 11)(b:Int = a) =
  {
    a + b
  }
}

==========================================================================
