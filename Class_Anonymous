
The following code shows an example of using an 'anonymous class'.
In its main() function, there are 2 declarations made of type Person.
However, by looking those 2 Person declarations in main(), you can't
determine if Person is a Scala class or trait.

We know Person can't be a 'case class' because a case class can't
contain the "new" keyword in its declaration.

Note that the timer() function definition contains an arg/param
named 'blockOfCode'.  blockOfcode is literally a block of Scala code.
Obviously a block of code CAN'T take params/args, and its return type
is whatever expression its last line translates to.  That could be
of type Unit, Int, List, etc.

In the timer() function definition below, its argument/parameter
is specified like this:  blockOfCode: =>A

When NOTHING appears after the colon (:) and before the rocket symbol
(=>) it means the function takes no params/args.  The A following
the rocket symbol (=>) means the function returns a generic type
named A.

Read the following code's in-line comments to understand the
above explanations.

==================================================================

object Demo
{
  // *********************************************************
  // THIS PROGRAM WILL RUN WITH EITHER ONE (BUT NOT BOTH)
  // OF THE FOLLOWING 2 DECLARATIONS FOR "Person"
  // 1) trait Person
  // 2) abstract class Person
  // COMMENT OUT THE "Person" DECLARATION YOU DON'T WANT USED.
  //
//  trait Person {
//    def name:String
//    def age:Int
//    override def toString = s"name = $name,  age = $age"
//  }

  abstract class Person {
    val name:String
    val age:Int
    override def toString = s"name = $name,  age = $age"
  }

// *********************************************************

  def main(args: Array[String]): Unit = {
    {
      val tom:Person = new Person {
      val name:String = "tom"
      val age:Int = 63
      }
      println(tom) // PRINTS: name = tom,  age = 63

      val jim:Person = new Person {
        val name:String = "jim"
        val age:Int = 27
      }
      println(jim) // PRINTS: name = jim,  age = 27


      val (result, time) = timer{Thread.sleep(1000);  42}
      println(s"result = $result,  time = $time")
      // PRINTS: result = 42,  time = 1000.15366


      // Following 2 lines are IDENTICAL to the 2 lines above.
      // EXCEPT that timer{...} is called above,
      //        and  timer(...) is called below.
      val (result2, time2) = timer(Thread.sleep(1000),  42)
      println(s"result2 = $result2,  time = $time2")
      // PRINTS: result2 = ((),42),  time = 1001.339614
    }

    def timer[A](blockOfCode: =>A) = {
      val startTime = System.nanoTime()
      val result = blockOfCode
      val stopTime = System.nanoTime()
      val delta = stopTime - startTime
      (result, delta/1000000D)
    }
  }
}

==================================================================

object Demo
{
  // NOTE: The following StringToInt case class definition
  //       contains an argument named "run", which is a function.
  //       Therefore, to invoke the function passed to this
  //       StringToInt case class you must call:  StringToInt.run()
  //       as is shown below.
  case class StringToInt(run: String => Int)

  def main(args: Array[String]): Unit = {
    // The StringToInt case class is defined above to take
    // a function as its argument.  Therefore, the following
    // line of code passes an ANONYMOUS FUNCTION to the
    // StringToInt case class's argument.
    val stringToInt:StringToInt = StringToInt{ str:String => str.toInt }
    println(stringToInt.run("-777")) // PRINTS: -777

    // The following code gives us the same functionality as
    // above, except no predefined class/trait is used.
    // A val is declared that gets assigned an ANONYMOUS FUNCTION.
    val stringToInt2:String=>Int = { str:String => str.toInt }
    println(stringToInt2("1234")) // PRINTS: 1234
  }
}

==================================================================



