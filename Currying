CURRYING
========

A curried function is any function that returns a function,
where the returned function accepts a single parameter list.
NOTE:  The single parameter list of a curried function can
       contain one argument, or multiple arguments.

All Scala functions defined with multiple parameter lists are
curried functions with these two exceptions...

1) When one of its parameter lists includes an implicit argument
   it's NOT a curried function.
   SEE SECTION TITLED:
   FUNCTIONS WITH IMPLICIT PARAMETER LISTS ARE NOT CURRIED FUNCTIONS

2) When it contains two parameter lists, and the second parameter list
   argument contains a block of Scala code (instead of a data type
   like Int, String, etc) it's NOT a curried function.
   SEE SECTION TITLED:
   WHEN MULTIPLE PARAMETER LISTS DON'T DESIGNATE A CURRIED FUNCTION


Each set of parenthesis defined in a function represents a
parameter list.  For example, the following 2 functions
contain multiple parameter lists, which means these 2 functions
are curried functions.

def addXY_Curried(x:Int)(y:Int) = { x + y }
def addXYZ_Curried(x:Int)(y:Int)(z:Int) = { x + y + z }

Currying transforms a function into a chain of functions.  Where each
function in the chain gets passed a single parameter list, and returns
a function that accepts a single parameter list.  When a curried function
is finally called with its last (of multiple) parameter lists, the
curried function becomes fully applied, and returns NOT a function,
but a final value.

Whenever a Scala curried function is called, the function is either
partially applied, or fully applied.  Here are the definitions:

1) PARTIALLY APPLIED FUNCTION - Calling a curried function with fewer
   than all its parameter lists means that function is partially applied,
   because it returns a function which accepts a single parameter list.

   IMPORTANT: When a curried function is called as a partially applied
              function an OPTIONAL underscore character (_) at the end
              of its parameter list(s) designates all parameter list(s)
              that aren't specified.

   It's possible to define a curried function that contains only
   one parameter list in its fuction definition.  To see an example
   of how a curried function containing only one parameter list in
   its definition is defined, read the section further below titled:
   "DEFINING A CURRIED FUNCTION HAVING ONLY ONE PARAMETER LIST"

2) FULLY APPLIED FUNCTION - When a curried function is called with the
   last of its multiple parameter lists, it returns a final value, not
   a function.  This makes the curried function fully applied.

NOTE: Don't confuse a "partially applied function" with a "partial function"
      because THEY'RE NOT THE SAME.  A partial function is defined in the
      Scala API as:  PartialFunction 
      PartialFunction is defined as both a Scala trait and a Scala object.

========================================================================================

The following code sample shows how to call a curried function
as fully applied and partially applied.  It also shows how to
call a partially applied function with the OPTIONAL underscore
character (_) at the end of the parameter list(s).

object Demo
{
  def main(args: Array[String])
  {
    def addXYZ_Curried(x:Int)(y:Int)(z:Int) = { x + y + z }

    // Here we call addXYZ_Curried()()() by passing it all 3 of its
    // parameter lists at once, thus making it a fully-applied function.
    var result = addXYZ_Curried(1)(2)(3) // The function is fully applied.
    println(s"1) result = $result") // PRINTS: 1) result = 6

    // Here we call addXYZ_Curried()()() 3 separate times, passing it
    // one parameter list each time it's called.  The first two times
    // it's called the function is partially applied.  The third time
    // it's called the function becomes fully applied.
    var func1:Int =>(Int => Int) = addXYZ_Curried(1)_  // The underscore char (_) is optional.
    var func2:Int => Int = func1(2) // An underscore char after func1(2) WON'T COMPILE!
    result = func2(3) // The function is fully applied.
    println(s"2) result = $result") // PRINTS: 2) result = 6

    // Here we call addXYZ_Curried()()() 2 separate times.  he first time it's
    // called we pass it two parameter lists, so it's partially applied.
    // The third (and last time) it's called, function becomes fully applied.
    func2 = addXYZ_Curried(1)(2)_ // The underscore char (_) is optional.
    result = func2(3) // The function is now fully applied.
    println(s"3) result = $result") // PRINTS: 3) result = 6
  }
}

========================================================================================
DEFINING A CURRIED FUNCTION HAVING ONLY ONE PARAMETER LIST
==========================================================

Above we stated that all Scala functions defined with multiple parmater lists
are curried functions--EXCEPT when one of the parameter lists includes an
implicit argument, as is explained further below.  However, the following
is also true...

A function that contains only one parameter list can be a curried function
if it's defined like this...

def addXY_Curried_1(x:Int):(Int => Int) = { (y:Int) => x + y }

Even though this addXY_Curried_1() function is defined with only one
parameter list, it's a curried function because it returns a
function that takes a single parameter list.  Therefore, addXY_Curried_1()
is not fully applied until it gets called with two (2) parameter
lists, as is demonstrated in the sample code below.

The sample code below defines the following two functions.

1) def addXY_Curried_1(x:Int):(Int => Int) = { (y:Int) => x + y }
2) def addXY_Curried_2(x:Int)(y:Int)       = { x + y }

Both these functions have IDENTICAL BEHAVIOR, with this one exception:

This line of code WON'T compile:  addXY_Curried_1(5)_
This line of code WILL compile:   addXY_Curried_2(5)_

addXY_Curried_1(5)_ won't compile because the definition
of addXY_Curried_1() contains only one parameter list.

addXY_Curried_2(5)_ will compile because the definition
of addXY_Curried_2()() contains two parameter lists.

object Demo
{
  def main(args: Array[String])
  {
    // The following function is curried because its
    // definition contains multiple parameter lists.
    def addXY_Curried_1(x:Int):(Int => Int) = { (y:Int) => x + y }

    // ********************************************************************
    // The following COMMENTED-OUT line won't compile because addXY_Curried_1
    // is defined above with ONLY ONE parameter list.  Therefore, it CAN'T
    // be called with an underscore char (_) replacing the remaining parameter
    // list(s), as the definition contains only one parameter list.
    //
    // WON'T compile:  addXY_Curried_1(5)_

    // *******************************************************************
    // The below code samples show several ways of calling addXY_Curried_1
    // function, and the equivalent addXY_Curried_2 function.
    // *******************************************************************
    var result:Int = addXY_Curried_1(5)(2) // 5 + 2 = 7
    println("1) result = " + result) // PRINTS: 1) result = 7

    // Here we obtain the result identical to above, in a different way.
    var func:(Int => Int) = addXY_Curried_1(5)
    result = func(2) // 5 + 2 = 7
    println("2) result = " + result) // PRINTS: 2) result = 7

    // The addXY_Curried_2 function defined below is an alternative way of
    // writing the above addXY_Curried_1 function to obtain identical behavior.
    def addXY_Curried_2(x:Int)(y:Int) = { x + y }

    func = addXY_Curried_2(5)_ // The underscore char (_) here is optional.
    result = func(2) // 5 + 2 = 7
    println("3) result = " + result) // PRINTS: 3) result = 7
  }
}

========================================================================================
FUNCTIONS WITH IMPLICIT PARAMETER LISTS ARE NOT CURRIED FUNCTIONS
=================================================================

When a function definition contains multiple parameter lists, that function
is generally a curried function, but not always!  Here is an exception...

When a function definition contains multiple parameter lists, and one
of those parameter lists contains an implicit argument, that function
is NOT a curried function.

Read the section titled "Implicit_Parameters" for more info on this.
SEE --> https://github.com/w9mwi/Scala/blob/master/Implicit_Parameters

========================================================================================
WHEN MULTIPLE PARAMETER LISTS DON'T DESIGNATE A CURRIED FUNCTION
================================================================

Although the myWhileLoop()() is defined in the code sample below with
two (2) parameter lists, it's NOT a curried function because it doesn't
return a function that accepts a single parameter list.

The myWhileLoop()() method has this definition:
def myWhileLoop(testCondition: => Boolean)(codeBlock: => Unit):Unit = { ... }

Its 1st parameter list:  (testCondition: => Boolean)
Its 2nd parameter list:  (codeBlock: => Unit)

Obviously, the "=> Boolean" designates a function that returns a Boolean,
and the "=> Unit" designates a function that returns nothing.  But the
following question arises...

QUESTION: Why is there no data type specified between the colon (:) and
          the rocket (=>) in these two parameter lists as you may expect?

          (testCondition: => Boolean)
          (codeBlock: => Unit)

ANSWER:  Because both those arguments do NOT get passed a value (i.e., Int,
         String, Boolean, List[Float], etc.).  Those arguments get passed
         lines of Scala code.  Lines of Scala code never represent a data type.
         Therefore, no data type is specified for the testCondition and
         codeBlock arguments.

         The testCondition argument literally accepts this expression: (idx < 5),
         which has no data type but evaluates to a Boolean.  So testCondition
         returns Boolean.

         The codeBlock argument literally accepts a block (several lines) of
         Scala code.  Lines of Scala code never represent a data type.  Also,
         the last line of code executed in codeBlock doesn't evaluate to
         anything, so codeBlock returns Unit.

NOTE: It's possible for a block of code to evaluate to a value, and thus have a
      return data type.  For example, if the last line executed in codeBlock
      evaluated to a String, then codeBlock would return a String.  If that were
      the case, the function defined in the sample code below would...
      look like this:   def myWhileLoop(testCondition: => Boolean)(codeBlock: => String):Unit
      instead of this:  def myWhileLoop(testCondition: => Boolean)(codeBlock: => Unit):Unit

object Demo
{
  def main(args: Array[String])
  {
    var idx:Int = 0
    myWhileLoop(idx < 5)
    {
      // IMPORTANT: It appears the myWhileLoop() method called above is being called
      //            with only one of its two parameter lists, but that's wrong!
      //            All code between the above and below braces pair {} gets passed
      //            to the second parameter list of the myWhileLoop()() method
      //            defined below.
      print("idx = " + idx + ", ") // PRINTS: idx = 0, idx = 1, idx = 2, idx = 3, idx = 4,
      idx += 1
    }
  }

  // The following myWhileLoop()() method is RECURSIVE!  The Scala code passed to
  // this method in the codeBlock argument keeps executing (which is a recursive
  // call) until the testCondition parameter becomes false.
  def myWhileLoop(testCondition: => Boolean)(codeBlock: => Unit):Unit =
  {
    // NOTE: The following line of code can be written using any of these 3 variations:
    //       1) while(testCondition)(codeBlock)
    //       2) while(testCondition){codeBlock}
    //       3) while(testCondition) codeBlock
    while(testCondition)(codeBlock)
  }
}

========================================================================================

Here's an example where we have two functions that both return a function
that takes an Int as a parameter.  This means that both these functions
must get called with one more parameter than appears in their definition
to become fully applied.

object Demo
{
  def main(args: Array[String])
  {
    // NOTE: Both of the following 2 functions return a function
    //       that takes an Int as a parameter.  Therefore...
    //       1) The sum1() function must get called with TWO (2)
    //          parameter lists until it's fully applied.
    //       2) The sum2()() function must get called with THREE (3)
    //          parameter lists until it's fully applied.
    def sum1(a: Int):(Int => Int)       = { b => a + b }
    def sum2(a:Int)(b:Int):(Int => Int) = { c => a + b + c }

    var func:(Int => Int) = sum1(123) // sum1() is partially applied.
    var result:Int = func(321)        // sum1() is fully applied.
    println(s"1) result = $result") // PRINTS: 1) result = 444

    func = sum2(5)(10) // sum2()() is partially applied.
    result = func(20)  // sum2()() is fully applied.
    println(s"2) result = $result") // PRINTS: 2) result = 35
  }
}

========================================================================================

Since the add() function defined above uses ONLY ONE parametric type, you need
only ONE letter (A, B, C, X, Y, Z, etc.) to designate the parametric type.

However, the following curried function funcXYZ requires multiple parametric types
in its definition.  In the funcXYZ function definition below, you can still choose
any letters you want to designate the types, but you must choose the correct parametric
type in each of the many locations where one is used.  Keep reading below for an
explanation of how this is determined.

========================================================================================

object Demo
{
  def funcX(x:Int):Int = { x + 10 }
  def funcY(y:Int):Int = { y - 3 }
  def funcZ(z:Int):Int = { z * 4 }

  // funcXYZ is identical to the below funcXYZ_2 function,
  // except funcXYZ_2 has 3 PARAMETER LISTS.
  def funcXYZ[A,B,C,D](funcX:(C=>D), funcY:(B=>C), funcZ:(A=>B)):(A=>D) =
  {
    x => funcX(funcY(funcZ(x)))
  }

  // funcXYZ_2 is identical to the above funcXYZ function,
  // except funcXYZ has 1 PARAMETER LIST containing 3 arguments.
  def funcXYZ_2[A,B,C,D](funcX:(C=>D))(funcY:(B=>C))(funcZ:(A=>B)):(A=>D) =
  {
    x => funcX(funcY(funcZ(x)))
  }

  def main(args:Array[String]): Unit =
  {
    var result:Int = funcXYZ(funcX, funcY, funcZ)(5)
    println("result = " + result) // PRINTS: result = 27

    result = funcXYZ_2(funcX)(funcY)(funcZ)(5)
    println("result = " + result) // PRINTS: result = 27
  }
}

========================================================================================

NOTICE: The funcXYZ and funcXYZ_2 functions in the above example will generate
        identical results after both those functions become FULLY APPLIED.  The
        ONLY way they differ is that funcXYZ is defined to take 3 parameters in
        1 PARAMETER LIST, while funcXYZ_2 is defined to take 3 PARAMETER LISTS.

FROM THIS POINT ON, ONLY THE funcXYZ FUNCTION IS DISCUSSED, NOT THE funcXYZ_2 FUNCTION.

In the above funcXYZ definition, the letters in the [A,B,C,D] section can
appear in ANY ORDER you want.  For example:
funcXYZ[A,B,C,D]...
funcXYZ[B,A,D,C]...
funcXYZ[D,C,A,B]...
The order won't affect the behavior of the code, but it's best to always
keep them in alphabetical order.  Following that text in the function
definition, the correct parametric type must be used wherever one is referenced.

The funcXYZ definition uses parametric types to designate several return types.
You can choose any letters for the parametric types, but YOU SHOULD ALWAYS
begin using letter A, followed by B, C, D, etc. so it's easy to follow the order.
This part explains how the parametric return types are determined.

We begin by observing what funcXYZ returns.  We see that funcXYZ returns this...

x => funcX(funcY(funcZ(x)))

That's a function, which takes a single parameter (x), and returns this line of code:

funcX(funcY(funcZ(x)))  // Where x is the param passed to funcZ

When that line of code is executed, the first thing that executes is funcZ.
Let's begin by saying funcZ takes parameter A (representing the x parameter
value passed to funcZ), and it returns the value B, like this:

A=>B   (funcZ return type)

The next thing that executes is funcY.  The parameter fed to funcY comes
from the value returned by funcZ.  So the funcY return type is:

B=>C   (funcY return type)

The next thing that executes is funcX.  The parameter fed to funcX comes
from the value returned by funcY.  So the funcX return type is:

C=>D   (funcX return type)

Finally, we need to designate what funcXYZ returns.  funcXYZ RETURNS A FUNCTION that
takes the parameter x.  Notice that this x parmameter is literally the same value
that gets passed to funcZ.  Since funcZ defined that x value as type A, funcXYZ
must also use that same A value in its return type.  Therefore, the funcXYZ
return type is:

A=>D   (funcXYZ return type)

Now we can write the funcXYZ definition (shown below) using these return types...

funcXYZ returns: A=>D
funcZ   returns: A=>B
funcY   returns: B=>C
funcX   returns: C=>D

Those are the return types that get plugged into the funcXYZ definition, like this:

def funcXYZ[A,B,C,D](funcX:(C=>D), funcY:(B=>C), funcZ:(A=>B)):(A=>D) =
{
  x => funcX(funcY(funcZ(x)))
}

TAKE NOTE: The A value in the funcXYZ return type is literally the same value
           as the A value in the funcZ return type.  When funcXYZ is executed
           (either as a partially-applied or fully-applied function) funcZ
           is ALWAYS the FIRST parameter list executed.

           The D value in the funcXYZ return type is literally the same value
           as the D value in the funcX return type.  When funcXYZ becomes
           fully applied, funcX is ALWAYS the LAST parameter list executed.
========================================================================================
Here is another example of currying.  Read in-line comments below for explanations.

object Demo
{
  // NOTE: This wrap function is a curried function that takes
  //       3 parameter lists (all 3 are Strings), and returns a String.
  def wrap(prefix:String)(html:String)(suffix:String) =
  {
    prefix + html + suffix
  }

  // NOTE: This wrapWithDiv function RETURNS the above wrap function, where
  //       the wrap function's middle parameter list isn't specified, which
  //       is designated by the the (_) parameter list.  Therefore, this
  //       wrapWithDiv function is defined as a PARTIALLY APPLIED function
  //       call to the wrap function.
  def wrapWithDiv:(String => String) = wrap("<div>")(_)("</div>")

  def main(args: Array[String])
  {
    // NOTE: When main() calls wrapWithDiv by passing it a String, the wrap
    //       function gets called as a FULLY APPLIED function call because it's
    //       now supplied with its previously-unspecified parameter list (_).
    println(wrapWithDiv("My_Text")) // PRINTS: <div>My_Text</div>
  }
}

========================================================================================
The following code is an example of calling a recursive curried function.  The curried
forloop()() function is called as a fully-applied function (with 2 parameter lists)
every time it executes a loop.

When 'count > 0' evaluates to false in the main() function, the forloop()()
function is called as a partially-applied function (with only 1 parameter list),
and then terminates.
========================================================================================

object Demo
{
  def main(args: Array[String])
  {
    var count = 5
    forloop(count > 0) // 'count > 0' is passed to the 1st param. list of the forloop()() function.
    {
      // The code contained within these curly braces {} is passed as
      // the 2nd param. list to the curried forloop()() function.
      print("count = " + count + ",  ") // PRINTS: count = 5,  count = 4,  count = 3,  count = 2,  count = 1,
      count -= 1
    }
    println("\nProgram Terminated.") // PRINTS: Program Terminated.
  }

  /**
   * This forloop()() function is a RECURSIVE CURRIED FUNCTION with 2 argument lists.
   * BOTH its arguments are Pass-By-Value functions (aka, Nullary functions), which
   * means they get passed A BLOCK OF SCALA CODE.
   */
  def forloop(rule: => Boolean)(body: => Unit):Unit =
  {
    if (rule)
    {
      body // Executes the Scala code passed to the 2nd parameter list.
      forloop(rule)(body) // This is a RECURSIVE function call.
    }
  }
}

========================================================================================
The following sample code includes this parametric curried function:

def funcOfGunc[A,B,C](func:(B=>C), gunc:(A=>B)):(A=>C) = { x=>func(gunc(x)) }

This part explains how funcOfGunc was defined.

1)
We will pass 2 functions to funcOfGunc in a single parameter list.  Both those
functions will get passed a Double, and return a Double.

NOTICE: Recall that a curried function always has at least TWO (2) parameter
        lists.  The second parameter list that funcOfGunc accepts is NOT included
        in the funcOfGunc definition because funcOfGunc returns a function that
        accepts a single parameter.  Therefore, the return value of funcOfGunc
        is where the second parameter list gets defined.

2)
Since the gunc function gets called FIRST, we will begin by saying gunc(x) gets
passed a parameter of type A, and returns type B.  So gunc has this return type:
A=>B

2)
The func function gets called AFTER gunc is called, and gets passed the
value returned by gunc, which is type B.  So func has this return type:
B=>C

4)
After both the func and gunc functions passed to funcOfGunc are called
(i.e., func(gunc(x))), funcOfGunc returns its value, which is a function
that gets passed a parameter.

Therefore, funcOfGunc gets passed the same value passed to gunc (parameter
type A), and it returns the same value returned by func (parameter type C).
So funcOfGunc has this return type:
A=>C

========================================================================================

object Demo
{
  def main(args:Array[String]): Unit =
  {
    val plus5:(Double=>Double)  = { x:Double => x+5.0D }
    val square:(Double=>Double) = { x:Double => x*x }

    // NOTE: 54.0 = 5.0+(7.0*7.0)
    var result:Double = funcOfGunc(plus5, square)(7.0D)
    println("result = " + result) // PRINTS: result = 54.0

    // NOTE: 144.0 = (5.0+7.0)*(5.0+7.0)
    result = funcOfGunc(square, plus5)(7.0D)
    println("result = " + result) // PRINTS: result = 144.0
  }

  def funcOfGunc[A,B,C](func:(B=>C), gunc:(A=>B)):(A=>C) = { x=>func(gunc(x)) }
}

========================================================================================

The following code sample shows an example of transforming a regular function into
a curried function by first performing an eta expansion on it by adding the underscore
(_) character, and then calling Scala's .curried() method.

object Demo
{
  def main(args: Array[String])
  {
    // The following line of code converts the add() function defined below
    // (which contains one parameter list) into a curried function (which
    // contains two parameter lists) via an "Eta Expansion".  The "Eta
    // Expansion" occurs when adding the underscore character (_) after
    // the "add" method name.
    val addFunction:((Int, Int)=>Int)        = add _  // The underscore char (_) on this line is REQUIRED.
    val addFunctionCurried:(Int=>(Int=>Int)) = addFunction.curried // Converts the addFunction into a curried function.

    println(add(123, 456))                // PRINTS: 579
    println(addFunction(123, 456))        // PRINTS: 579
    println(addFunctionCurried(123)(456)) // PRINTS: 579

    // The following TWO (2) calls to addFunctionCurried show
    // how to call addFunctionCurried in 2 separate steps.
    // Firstly, as a partially-applied function call.  Secondly,
    // as a fully-applied function call.
    val func1:(Int => Int) = addFunctionCurried(123)(_) // Partially applied function call.
    println(func1(456)) // Fully applied function call.  PRINTS: 579

    val func2:(Int => Int) = addFunctionCurried(123) // Partially applied function call.
    println(func2(456)) // Fully applied function call.  PRINTS: 579
  }

  /**
   * This add() function is a regular Scala function.  In the code
   * above, this add() function is used to create a curried function
   * by calling:  addFunction.curried
   */
  def add(x:Int, y:Int):Int = { x + y }
}

========================================================================================

The following code sample shows another example of transforming a regular
function into a curried function by first performing an eta expansion on
it by adding the underscore (_) character, and then calling Scala's .curried()
method.

object Demo
{
  def main(args: Array[String])
  {
    // The add_1() function is a just a standard, normal function.
    // The first time the add_1() is called here, it's called in
    // the usual way....
    println("add_1(7, 3) = " + add_1(7, 3)) // PRINTS: add_1(7, 3) = 10

    // Perform an "Eta Expansion" on add_1() by using the underscore (_) character...
    val addFunc:((Int, Int) => Int) = add_1 _

    val addFuncCurried:(Int => (Int => Int)) = addFunc.curried // Make the add_1() function a curried function.
    println("addFuncCurried(7)(3) = " + addFuncCurried(7)(3)) // PRINTS: addFuncCurried(7)(3) = 10

    // addFuncCurried called with one param returns a PARTIALLY APPLIED function...
    val partiallyAppliedCurried:(Int => Int) = addFuncCurried(7)
    // Call partiallyAppliedCurried to make addFuncCurried FULLY APPLIED...
    println("partiallyAppliedCurried(3) = " + partiallyAppliedCurried(3)) // PRINTS: partiallyAppliedCurried(3) = 10

    // *****************************************************************************************
    // The add_2()() function called below is a curried function,
    // and can be called in the following two (2) ways...
    //
    // 1) Call sum_2()() once by passing to it both Int params, so it
    //    returns an Int result...
    println("add_2(7)(3) = " + add_2(7)(3)) // PRINTS: add_2(7)(3) = 10

    // 2) Call sum_2()() twice...  sum_2()() is called the first time by
    //    initializing its x Int parameter, and it returns a function.
    //    (At this point, the sum_2()() function is PARTIALLY APPLIED)
    //    Then, sum_2()() is called the second time by initializing
    //    its y Int parameter so it will now return an Int value.
    //    (At this point, the sum_2()() function is FULLY APPLIED.)
    val func:(Int => Int) = add_2(7)(_) // The func function is PARTIALLY APPLIED here.
    println("func(3) = " + func(3)) // PRINTS: func(3) = 10  (func is now FULLY APPLIED.)
  }

  /**
   * This add_1() function is a normal function, NOT a curried function.
   */
  def add_1(x:Int, y:Int):Int = { x + y }

  /**
   * This add_2() function is a CURRIED FUNCTION because
   * it takes multiple arguments, and returns a function
   * that takes a single argument.
   */
  def add_2(x:Int) = { (y:Int) => x + y }
}

========================================================================================

The foldLeft and foldRight functions implemented by the Scala List class are recursive
AND curried functions.  Below is sample code showing the use of the List.foldLeft and
List.foldRight functions.

The first argument list of foldLeft and foldRight represents the STARTING VALUE used on
the first function call of these recursive functions.  The second argument list of
foldLeft and foldRight represents the the function that gets applied.

object Demo
{
  def main(args:Array[String]): Unit =
  {
    // NOTE: foldLeft and foldRight are both RECURSIVE, CURRIED FUNCTIONS.
    //       When foldLeft and foldRight are called below, they get called
    //       with TWO PARAMETER LISTS.

    // ******************************************************************************
    // In this section we show how to use the List.foldLeft and List.foldRight
    // functions on the following intList, implementing the subtraction operation.
    // Notice we demonstrate TWO (2) different ways of implementing the subtraction
    // operation for foldLeft and foldRight that return the same result.
    // The math operation that occurs for foldLeft is:  0−7−4−6−3−9−1 = -30
    val intList:List[Int] = List[Int](7, 4, 6, 3, 9, 1)
    var intResult:Int = intList.foldLeft(0)(_ - _)
    println("foldLeft A = " + intResult) // PRINTS: foldLeft A = -30
    intResult = intList.foldLeft(0)((x, y) => x-y)
    println("foldLeft B = " + intResult) // PRINTS: foldLeft B = -30

    // The math operation that occurs for foldRight is:  0−(1−(9−(3−(6−(4−7))))) = 14
    intResult = intList.foldRight(0)(_ - _)
    println("foldRight A = " + intResult) // PRINTS: foldRight A = 14
    intResult = intList.foldRight(0)((x, y) => x-y)
    println("foldRight B = " + intResult) // PRINTS: foldRight B = 14

    // ******************************************************************************
    // In this section we show how to count the number of characters in the following
    // wordList, using the List.foldLeft and List.foldRight functions.  Notice we
    // demonstrate TWO (2) different ways of obtaining this character count for
    // foldLeft and foldRight that return the same result.
    val wordList:List[String] = List[String]("How", "many", "characters", "are", "in", "this", "wordList?")
    intResult = wordList.foldLeft(0)((count:Int, word:String) => count + word.length)
    println("foldLeft #1 = " + intResult) // PRINTS: foldLeft #1 = 35
    intResult = wordList.foldLeft(0)(_ + _.length)
    println("foldLeft #2 = " + intResult) // PRINTS: foldLeft #2 = 35

    intResult = wordList.foldRight(0)((word:String, count:Int) => count + word.length)
    println("foldRight #1 = " + intResult) // PRINTS: foldRight #1 = 35
    intResult = wordList.foldRight(0)(_.length + _)
    println("foldRight #2 = " + intResult) // PRINTS: foldRight #2 = 35

    // ******************************************************************************
    // In this section we call the foldLeft and FoldRight functions on the
    // following strList.
    val strList:List[String] = List[String]("ABC", "DEF", "GHI", "JKL", "MNO")
    var strResult:String = strList.foldLeft("START")(myFunc)
    println(strResult) // PRINTS: START-ABC-DEF-GHI-JKL-MNO

    strResult = strList.foldRight("BEGIN")(myFunc)
    println(strResult) // PRINTS: ABC-DEF-GHI-JKL-MNO-BEGIN
  }


  /**
   * NOTE: Scala defines List.foldLeft as this:   def foldLeft[B](z: B)(op: (B, A) => B): B
   *       Scala defines List.foldRight as this:  def foldRight[B](z: B)(op: (A, B) => B): B
   *
   * Therefore, this myFunc function satisfies the 2nd parameter list of foldLeft and foldRight,
   * because myFunc gets passed 2 values as a single parameter list, and returns a value.
   */
  def myFunc(str1:String, str2:String):String =
  {
    str1.concat("-").concat(str2)
  }
}

========================================================================================

In the code sample immediately ABOVE, the Scala API functions List.foldRight
and List.foldLight are demonstrated.  In the sample code BELOW, we write our
own functions named myFoldRightFunc and myFoldLeftFunc (both curried, recursive
functions), which emulate Scala's List.foldRight and List.foldLeft functions.

object Demo
{
  def main(args:Array[String]): Unit =
  {
    val floatList:List[Float] = List[Float](7.7F, 4.9F, 6.6F, 3.5F, 9.2F, 1.4F)

    // ********************************************************************************
    // In this section we demonstrate calling the myFoldRightFunc and myFoldLeftFunc
    // functions (defined below) on floatList.
    // The math operation performed by myFoldRightFunc is:  0.0-(1.4−(9.2−(3.5−(6.6−(4.9−7.7))))) = 13.7
    var floatResult:Float = myFoldRightFunc(floatList, 0.0F)(_ - _)
    println("floatResult = " + floatResult) // PRINTS: floatResult = 13.7

    // The math operation performed by myFoldLeftFunc is:  0.0 − 7.7 − 4.9 − 6.6 − 3.5 − 9.2 − 1.4 = -33.3
    floatResult = myFoldLeftFunc(floatList, 0.0F)(_ - _)
    println("floatResult = " + floatResult) // PRINTS: floatResult = -33.3

    // ********************************************************************************
    // In this section we demonstrate calling the myFoldLeftFunc and myFoldRightFunc
    // functions (defined below) on strList.
    val strList:List[String] = List[String]("ABC", "DEF", "GHI", "JKL", "MNO")
    var strResult:String = myFoldLeftFunc(strList, "START")(concat2Strings)
    println(strResult) // PRINTS: START-ABC-DEF-GHI-JKL-MNO

    strResult = myFoldRightFunc(strList, "BEGIN")(concat2Strings)
    println(strResult) // PRINTS: ABC-DEF-GHI-JKL-MNO-BEGIN
  }

  /**
   * THIS IS A CURRIED, RECURSIVE FUNCTION.
   */
  def myFoldLeftFunc[A,B](list:List[A], base:B)(funcOperation:(B,A)=>B):B =
  {
    if (list.isEmpty)
    {
      base // Terminate recursion when list is empty.
    }
    else
    {
      // Concat the result returned by the recursive myFoldLeftFunc call with list.head.
      funcOperation(myFoldLeftFunc(list.tail, base)(funcOperation),   list.head)
    }
  }

  /**
   * THIS IS A CURRIED, RECURSIVE FUNCTION.
   */
  def myFoldRightFunc[A,B](list:List[A], base:B)(funcOperation:(A,B)=>B):B =
  {
    if (list.isEmpty)
    {
      base // Terminate recursion when list is empty.
    }
    else
    {
      // Concat list.head with the result returned by the recursive myFoldRightFunc call.
      funcOperation(list.head,   myFoldRightFunc(list.tail, base)(funcOperation))
    }
  }

  /**
   * NOTE: myFoldRightFunc is defined above as this:
   *       def myFoldRightFunc[A,B](list:List[A], base:B)(func:(A,B)=>B):B
   *
   *       myFoldLeftFunc is defined above as this:
   *       def myFoldLeftFunc[A,B](list:List[A], base:B)(func:(B,A)=>B):B
   *
   * Therefore, this concat2Strings function satisfies the 2nd parameter list of myFoldLeftFunc
   * and myFoldRightFunc because concat2Strings gets passed 2 values as a single parameter list,
   * and returns a value.
   */
  def concat2Strings(str1:String, str2:String):String =
  {
    str1.concat("-").concat(str2)
  }
}

========================================================================================

Once you understand all the code and all the explanations above,
let's take another look at the curried function we used above...

def addXYZ_Curried(x:Int)(y:Int)(z:Int):Int = { x + y + z }

Assume you have code that calls this function in the following
manner, let's examine its behavior.

addXYZ_Curried(1)  // This returns this FUNCTION: (1 + (y + z))
addXYZ_Curried(2)  // This returns this FUNCTION: (1 + 2 + z) = (3 + z)
addXYZ_Curried(3)  // This returns this VALUE:    1 + 2 + 3 = 6


========================================================================================
========================================================================================
