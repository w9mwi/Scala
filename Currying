

CURRYING
========
Currying transforms a function that has MULTIPLE PARAMETER LISTS
into a chain of functions, where each function in the chain takes
take a parameter list, and returns either a value, or a function.
ALL curried functions have AT LEAST 2 (two) parameter lists.

Each set of parenthesis represents a PARAMETER LIST.  Multiple parameter
lists shouldn't be confused with multiple parameters.  (Multiple parameters
are contained within a SINGLE set of parenthesis.)

A Scala function that has MULTIPLE PARAMETER LISTS is a CURRIED FUNCTION,
and looks like this:  addXYZ_Curried(x)(y)(z)

A curried function has this behavior:

1) It gets passed a value and returns a function.
   AND
2) The returned function takes a parameter and returns
   either a value, or another function.

A curried function can go further than this.  If step 2) above
returns a function (instead of a value), that function will
take a parameter, and return a either another function,
or a value.  This could go on, and on, dependent on the number
of parameter lists the curried function accepts.


FULLY APPLIED FUNCTION
======================
When a curried function is called by passing ALL its parameter lists,
it's a FULLY APPLIED FUNCTION, like this...

addXYZ_Curried(1)(2)(3)


PARTIALLY APPLIED FUNCTION
==========================
When a curried function is called without all its parameter
lists, it's called as a PARTIALLY APPLIED FUNCTION.

When a curried function is called as a partially applied function,
it returns another function that takes the next parameter list.
So that returned function can then be called with a parameter list.

When a curried function is called with its last parameter list,
the curried function becomes FULLY APPLIED and returns a value.

When a curried function is called as a partially applied function,
a single underscore character (_) designates all parameter list(s)
that aren't specified.  For example, the following 2 lines are
partially applied function calls:

addXYZ_Curried(1)_    // A partially applied function call.
addXYZ_Curried(1)(2)_ // A partially applied function call.

Even though all curried functions can be called with multiple
parameter lists, it's possible to define a curried function
having a single parameter list in its definition, like this:

def addXY_Curried(x:Int):(Int => Int) = { (y:Int) => x + y }

Notice how this addXY_Curried function returns a function that
takes a parameter.  So even though addXY_Curried is defined
with only one parameter list, it can still be called with two
parameter lists!  (Shown further below.)

addXY_Curried is a curried function because it returns a function
that takes a parameter list.  Since addXY_Curried is defined with
only one parameter list, it WON'T COMPILE when it's called with
the underscore character (_) as a partially applied function...

addXY_Curried(5)_ // WON'T COMPILE!

To call addXY_Curried as a partially applied function,
it must be called it like this:

addXY_Curried(5) // WILL COMPILE!

As addXY_Curried(5) returns a function, which takes a parameter list.

Even though addXY_Curried is defined with one parameter list,
you can call it with 2 parameter lists as a fully applied
function, like this...

addXY_Curried(5)(2) // WILL COMPILE!

The addXY_Curried function was defined above as this:
def addXY_Curried(x:Int):(Int => Int) = { (y:Int) => x + y }

The addXY_Curried function can be redefined as follows.
def addCurried_2(x:Int)(y:Int) = { x+y }

addCurried_2 also returns the Int result of x + y.  The only
difference is that addCurried_2 can be called using the
underscore charater (_) as shown below, while the
addXY_Curried function cannot.

addCurried_2()_

The following code sample demonstrates all of the above examples
in detail.  Read the in-line comments for explanations.

========================================================================================

object Demo
{
  def funcX(x:Int):Int = { x + 10 }
  def funcY(y:Int):Int = { y - 3 }
  def funcZ(z:Int):Int = { z * 4 }
  def addXY_Curried(x:Int):(Int => Int)       = { (y:Int) => x + y }
  def addXYZ_Curried(x:Int)(y:Int)(z:Int):Int = { x + y + z }

  def main(args: Array[String])
  {
    // This section demonstrates the standard way of calling functions.
    // This is NOT an example of currying!
    // NOTE: funcZ(funcY(funcX(7))) = (((7 + 10) - 3) * 4) = 56
    var result: Int = funcZ(funcY(funcX(7)))
    println("funcZ(funcY(funcX(7))) = " + result) // PRINTS: funcZ(funcY(funcX(7))) = 56

    // ======================================================
    // This section demonstrates how to call the addXYZ_Curried()()()
    // function in one line of code, to add 3 Int values...
    result = addXYZ_Curried(1)(2)(3) // Adds 1 + 2 + 3
    println("result = " + result) // PRINTS: result = 6

    // ======================================================
    // This section demonstrates how to call addXYZ_Curried()()()
    // in 3 separate lines of code to obtain the result of adding
    // 3 Ints (1 + 2 + 3).
    // NOTE: The underscore char (_) is used below to designate that we're
    //       calling addXYZ_Curried()()() with only ONE (1) parameter list.
    //       The 2nd and 3rd parameter lists are ignored.
    var func1:(Int => (Int => Int)) = addXYZ_Curried(1)_ // Returns a function that returns a function.
    var func2:(Int => Int)          = func1(2)           // Returns a function that returns an Int.
    result = func2(3) // Returns an Int value.
    println("result = " + result) // PRINTS: result = 6

    // Instead of calling addXYZ_Curried()()() in 3 separate lines of code
    // as in the above example, this section calls that curried function
    // in only 2 lines of code.  Just to demonstrate that it can be called
    // in different ways.  Again, the underscore char (_) is used below
    // to designate that we're ignoring the 3rd parameter list.
    func2 = addXYZ_Curried(1)(2)_ // Returns a function that returns an Int.
    result = func2(3) // Returns an Int value.
    println("result = " + result) // PRINTS: result = 6

    // ======================================================
    // This section demonstrates how to call the addXY_Curried() function.
    // NOTE: The following commented-out line WON'T COMPILE because the
    //       underscore char (_) MUST follow a function/method call.
    //       The call to addXY_Curried(5) returns NOT a function that
    //       returns a function, but returns a function that returns an Int.
    // addXY_Curried(5)_ // THIS LINE WON'T COMPILE!

    // Add the two numbers: 5 + 15
    func2 = addXY_Curried(5) // Returns a function that returns an Int.
    result = func2(15)       // Returns an Int.
    println("result = " + result) // PRINTS: result = 20

    // NOTE: Even though the addXY_Curried() function is defined above with only
    //       ONE parameter list, it can be called with TWO parameter lists because
    //       it's a curried function.  That is, addXY_Curried(5) returns
    //       a function that takes an Int parameter, and returns an Int.
    result = addXY_Curried(5)(20)
    println("result = " + result) // PRINTS: result = 25

    // The addXY_Curried() function can also be called in the
    // following two (2) ways to generate the same result.
    func2 = addXY_Curried(5) // Call as a partially applied function.
    println("func2.apply(20)      = " + func2.apply(20)) // Complete the partially applied function.
    println("addXY_Curried(5)(20) = " + addXY_Curried(5)(20)) // Call as a fully applied function.
  }
}

========================================================================================
This simple demonstration of currying shows how to use the apply() method as an
alternative way of calling a curried function.,  Read in-line comments below
for details.

object Demo
{
  def main(args: Array[String])
  {
    // Immediately after sum1(2) gets called, the func1() function is partially applied.
    // After func1(5) gets called, the func1() function is fully applied.
    val func1:(Int => Int) = sum1(2)
    println(func1(5))       // PRINTS: 7  (NOTE: 7 = 2 + 5)
    println(func1.apply(5)) // Equivalent to the previous line of code.

    // Immediately after sum2(2)(42) gets called, the func2() function is partially applied.
    // After func2(13) gets called, the func2() function is fully applied.
    val func2:(Int => Int) = sum2(2)(42)
    println(func2(13))       // PRINTS: 57 (NOTE: 57 = 2 + 42 + 13)
    println(func2.apply(13)) // Equivalent to the previous line of code.
  }

  // NOTE: When the following 2 functions ( sum1() and sum2()() ) are called, they
  //       are only PARTIALLY APPLIED.  sum1() is not fully applied until the
  //       func1() function gets called.  And sum2()() is not fully applied until
  //       the func2() function gets called.
  def sum1(a: Int):(Int => Int)       = { b => a + b }     // b is the value  5 passed from func1(5)
  def sum2(a:Int)(b:Int):(Int => Int) = { c => a + b + c } // c is the value 13 passed from func2(13)
}


========================================================================================

Recall that a PARAMETRIC FUNCTION is defined to accept any valid data type that
can work with the function.  For example, instead of defining 3 different add()
functions to work with the Int, Float, and Double data types, you can write a
single add() function as a parametric function, so it'll work with all 3 of
those data types.  See the below code sample.

Notice this text in the code below:  (implicit numeric:Numeric[A])
This implicit function call was added as another parameter list to
make add() a curried function that works with Scala's Numeric class.

object Demo
{
  // The following add() function is written as a parametric function,
  // where the parametric type A represents any numeric data type.
  def add[A](x:A, y:A)(implicit numeric:Numeric[A]):A = numeric.plus(x, y)

  def main(args:Array[String]): Unit =
  {
    println("add(1.23F, 4.56F) = " + add(1.23F, 4.56F)) // PRINTS: add(1.23F, 4.56F) = 5.79
    println("add(1.23D, 4.56D) = " + add(1.23D, 4.56D)) // PRINTS: add(1.23D, 4.56S) = 5.789999999999999
    println("add(123, 456)     = " + add(123, 456))     // PRINTS: add(123, 456)     = 579
    println("add(123, 4.56F)   = " + add(123, 4.56F))   // PRINTS: add(123, 456)     = 127.56
  }
}

========================================================================================

Since the add() function defined above uses ONLY ONE parametric type, you need
only ONE letter (A, B, C, X, Y, Z, etc.) to designate the parametric type.

However, the following curried function funcXYZ requires multiple parametric types
in its definition.  In the funcXYZ function definition below, you can still choose
any letters you want to designate the types, but you must choose the correct parametric
type in each of the many locations where one is used.  Keep reading below for an
explanation of how this is determined.

========================================================================================

object Demo
{
  def funcX(x:Int):Int = { x + 10 }
  def funcY(y:Int):Int = { y - 3 }
  def funcZ(z:Int):Int = { z * 4 }

  // funcXYZ is identical to the below funcXYZ_2 function,
  // except funcXYZ_2 has 3 PARAMETER LISTS.
  def funcXYZ[A,B,C,D](funcX:(C=>D), funcY:(B=>C), funcZ:(A=>B)):(A=>D) =
  {
    x => funcX(funcY(funcZ(x)))
  }

  // funcXYZ_2 is identical to the above funcXYZ function,
  // except funcXYZ has 1 PARAMETER LIST containing 3 parameters.
  def funcXYZ_2[A,B,C,D](funcX:(C=>D))(funcY:(B=>C))(funcZ:(A=>B)):(A=>D) =
  {
    x => funcX(funcY(funcZ(x)))
  }

  def main(args:Array[String]): Unit =
  {
    var result:Int = funcXYZ(funcX, funcY, funcZ)(5)
    println("result = " + result) // PRINTS: result = 27

    result = funcXYZ_2(funcX)(funcY)(funcZ)(5)
    println("result = " + result) // PRINTS: result = 27
  }
}

========================================================================================

NOTICE: The above funcXYZ and funcXYZ_2 functions will generate identical results
        after both those functions become FULLY APPLIED.  The ONLY way they differ
        is that funcXYZ is defined to take 3 parameters in 1 PARAMETER LIST,
        while funcXYZ_2 is defined to take 3 PARAMETER LISTS.

FROM THIS POINT ON, ONLY THE funcXYZ FUNCTION IS DISCUSSED, NOT THE funcXYZ_2 FUNCTION.

In the above funcXYZ definition, the letters in the [A,B,C,D] section can
appear in ANY ORDER you want.  For example:
funcXYZ[A,B,C,D]...
funcXYZ[B,A,D,C]...
funcXYZ[D,C,A,B]...
The order won't affect the behavior of the code, but it's best to always
keep them in alphabetical order.  Following that text in the function
definition, the correct parametric type must be used wherever one is referenced.

The funcXYZ definition uses parametric types to designate several return types.
You can choose any letters for the parametric types, but YOU SHOULD ALWAYS
begin using letter A, followed by B, C, D, etc. so it's easy to follow the order.
This part explains how the parametric return types are determined.

We begin by observing what funcXYZ returns.  We see that funcXYZ returns this...

x => funcX(funcY(funcZ(x)))

That's a function, which takes a single parameter (x), and returns this line of code:

funcX(funcY(funcZ(x)))  // Where x is the param passed to funcZ

When that line of code is executed, the first thing that executes is funcZ.
Let's begin by saying funcZ takes parameter A (representing the x parameter
value passed to funcZ), and it returns the value B, like this:

A=>B   (funcZ return type)

The next thing that executes is funcY.  The parameter fed to funcY comes
from the value returned by funcZ.  So the funcY return type is:

B=>C   (funcY return type)

The next thing that executes is funcX.  The parameter fed to funcX comes
from the value returned by funcY.  So the funcX return type is:

C=>D   (funcX return type)

Finally, we need to designate what funcXYZ returns.  funcXYZ RETURNS A FUNCTION that
takes the parameter x.  Notice that this x parmameter is literally the same value
that gets passed to funcZ.  Since funcZ defined that x value as type A, funcXYZ
must also use that same A value in its return type.  Therefore, the funcXYZ
return type is:

A=>D   (funcXYZ return type)

Now we can write the funcXYZ definition (shown below) using these return types...

funcXYZ returns: A=>D
funcZ   returns: A=>B
funcY   returns: B=>C
funcX   returns: C=>D

Those are the return types that get plugged into the funcXYZ definition, like this:

def funcXYZ[A,B,C,D](funcX:(C=>D), funcY:(B=>C), funcZ:(A=>B)):(A=>D) =
{
  x => funcX(funcY(funcZ(x)))
}

TAKE NOTE: The A value in the funcXYZ return type is literally the same value
           as the A value in the funcZ return type.  When funcXYZ is executed
           (either as a partially-applied or fully-applied function) funcZ
           is ALWAYS the FIRST parameter list executed.

           The D value in the funcXYZ return type is literally the same value
           as the D value in the funcX return type.  When funcXYZ becomes
           fully applied, funcX is ALWAYS the LAST parameter list executed.

========================================================================================

Here is another example of currying.  Read in-line comments below for explanations.

object Demo
{
  // NOTE: This wrap function is a curried function that takes
  //       3 parameter lists (all 3 are Strings), and returns a String.
  def wrap(prefix:String)(html:String)(suffix:String) =
  {
    prefix + html + suffix
  }

  // NOTE: This wrapWithDiv function RETURNS the above wrap function, where
  //       the wrap function's middle parameter list isn't specified, which
  //       is designated by the the (_) parameter list.  Therefore, this
  //       wrapWithDiv function is defined as a PARTIALLY APPLIED function
  //       call to the wrap function.
  def wrapWithDiv:(String => String) = wrap("<div>")(_)("</div>")

  def main(args: Array[String])
  {
    // NOTE: When main() calls wrapWithDiv by passing it a String, the wrap
    //       function gets called as a FULLY APPLIED function call because it's
    //       now supplied with its previously-unspecified parameter list (_).
    println(wrapWithDiv("My_Text")) // PRINTS: <div>My_Text</div>
  }
}

========================================================================================
The following code is an example of calling a recursive curried function.  The curried
forloop()() function is called as a fully-applied function (with 2 parameter lists)
every time it executes a loop.

When 'count > 0' evaluates to false in the main() function, the forloop()()
function is called as a partially-applied function (with only 1 parameter list),
and then terminates.
========================================================================================

object Demo
{
  def main(args: Array[String])
  {
    var count = 5
    forloop(count > 0) // 'count > 0' is passed to the 1st param. list of the forloop()() function.
    {
      // The code contained within these curly braces {} is passed as
      // the 2nd param. list to the curried forloop()() function.
      print("count = " + count + ",  ") // PRINTS: count = 5,  count = 4,  count = 3,  count = 2,  count = 1,
      count -= 1
    }
    println("\nProgram Terminated.") // PRINTS: Program Terminated.
  }

  /**
   * This forloop()() function is a RECURSIVE CURRIED FUNCTION with 2 argument lists.
   * BOTH its arguments are Pass-By-Value functions (aka, Nullary functions), which
   * means they get passed A BLOCK OF SCALA CODE.
   */
  def forloop(rule: => Boolean)(body: => Unit):Unit =
  {
    if (rule)
    {
      body // Executes the Scala code passed to the 2nd parameter list.
      forloop(rule)(body) // This is a RECURSIVE function call.
    }
  }
}

========================================================================================
The following sample code includes this parametric curried function:

def funcOfGunc[A,B,C](func:(B=>C), gunc:(A=>B)):(A=>C) = { x=>func(gunc(x)) }

This part explains how funcOfGunc was defined.

1)
We will pass 2 functions to funcOfGunc in a single parameter list.  Both those
functions will get passed a Double, and return a Double.

NOTICE: Recall that a curried function always has at least TWO (2) parameter
        lists.  The second parameter list that funcOfGunc accepts is NOT included
        in the funcOfGunc definition because funcOfGunc returns a function that
        accepts a single parameter.  Therefore, the return value of funcOfGunc
        is where the second parameter list gets defined.

2)
Since the gunc function gets called FIRST, we will begin by saying gunc(x) gets
passed a parameter of type A, and returns type B.  So gunc has this return type:
A=>B

2)
The func function gets called AFTER gunc is called, and gets passed the
value returned by gunc, which is type B.  So func has this return type:
B=>C

4)
After both the func and gunc functions passed to funcOfGunc are called
(i.e., func(gunc(x))), funcOfGunc returns its value, which is a function
that gets passed a parameter.

Therefore, funcOfGunc gets passed the same value passed to gunc (parameter
type A), and it returns the same value returned by func (parameter type C).
So funcOfGunc has this return type:
A=>C

========================================================================================

object Demo
{
  def main(args:Array[String]): Unit =
  {
    val plus5:(Double=>Double)  = { x:Double => x+5.0D }
    val square:(Double=>Double) = { x:Double => x*x }

    // NOTE: 54.0 = 5.0+(7.0*7.0)
    var result:Double = funcOfGunc(plus5, square)(7.0D)
    println("result = " + result) // PRINTS: result = 54.0

    // NOTE: 144.0 = (5.0+7.0)*(5.0+7.0)
    result = funcOfGunc(square, plus5)(7.0D)
    println("result = " + result) // PRINTS: result = 144.0
  }

  def funcOfGunc[A,B,C](func:(B=>C), gunc:(A=>B)):(A=>C) = { x=>func(gunc(x)) }
}

========================================================================================

The following code sample shows an example of transforming a regular function into
a curried function by first performing an eta expansion on it by adding the underscore
(_) character, and then calling Scala's .curried() method.

object Demo
{
  def main(args: Array[String])
  {
    // The following line of code converts the add() function defined below
    // (which contains one parameter list) into a curried function (which
    // contains two parameter lists) via an "Eta Expansion".  The "Eta
    // Expansion" occurs when adding the underscore character (_) after
    // the "add" method name.
    val addFunction:((Int, Int)=>Int)        = add _  // The underscore char (_) on this line is REQUIRED.
    val addFunctionCurried:(Int=>(Int=>Int)) = addFunction.curried // Converts the addFunction into a curried function.

    println(add(123, 456))                // PRINTS: 579
    println(addFunction(123, 456))        // PRINTS: 579
    println(addFunctionCurried(123)(456)) // PRINTS: 579

    // The following TWO (2) calls to addFunctionCurried show
    // how to call addFunctionCurried in 2 separate steps.
    // Firstly, as a partially-applied function call.  Secondly,
    // as a fully-applied function call.
    val func1:(Int => Int) = addFunctionCurried(123)(_) // Partially applied function call.
    println(func1(456)) // Fully applied function call.  PRINTS: 579

    val func2:(Int => Int) = addFunctionCurried(123) // Partially applied function call.
    println(func2(456)) // Fully applied function call.  PRINTS: 579
  }

  /**
   * This add() function is a regular Scala function.  In the code
   * above, this add() function is used to create a curried function
   * by calling:  addFunction.curried
   */
  def add(x:Int, y:Int):Int = { x + y }
}

========================================================================================

The following code sample shows another example of transforming a regular
function into a curried function by first performing an eta expansion on
it by adding the underscore (_) character, and then calling Scala's .curried()
method.

object Demo
{
  def main(args: Array[String])
  {
    // The add_1() function is a just a standard, normal function.
    // The first time the add_1() is called here, it's called in
    // the usual way....
    println("add_1(7, 3) = " + add_1(7, 3)) // PRINTS: add_1(7, 3) = 10

    // Perform an "Eta Expansion" on add_1() by using the underscore (_) character...
    val addFunc:((Int, Int) => Int) = add_1 _

    val addFuncCurried:(Int => (Int => Int)) = addFunc.curried // Make the add_1() function a curried function.
    println("addFuncCurried(7)(3) = " + addFuncCurried(7)(3)) // PRINTS: addFuncCurried(7)(3) = 10

    // addFuncCurried called with one param returns a PARTIALLY APPLIED function...
    val partiallyAppliedCurried:(Int => Int) = addFuncCurried(7)
    // Call partiallyAppliedCurried to make addFuncCurried FULLY APPLIED...
    println("partiallyAppliedCurried(3) = " + partiallyAppliedCurried(3)) // PRINTS: partiallyAppliedCurried(3) = 10

    // *****************************************************************************************
    // The add_2()() function called below is a curried function,
    // and can be called in the following two (2) ways...
    //
    // 1) Call sum_2()() once by passing to it both Int params, so it
    //    returns an Int result...
    println("add_2(7)(3) = " + add_2(7)(3)) // PRINTS: add_2(7)(3) = 10

    // 2) Call sum_2()() twice...  sum_2()() is called the first time by
    //    initializing its x Int parameter, and it returns a function.
    //    (At this point, the sum_2()() function is PARTIALLY APPLIED)
    //    Then, sum_2()() is called the second time by initializing
    //    its y Int parameter so it will now return an Int value.
    //    (At this point, the sum_2()() function is FULLY APPLIED.)
    val func:(Int => Int) = add_2(7)(_) // The func function is PARTIALLY APPLIED here.
    println("func(3) = " + func(3)) // PRINTS: func(3) = 10  (func is now FULLY APPLIED.)
  }

  /**
   * This add_1() function is a normal function, NOT a curried function.
   */
  def add_1(x:Int, y:Int):Int = { x + y }

  /**
   * This add_2() function is a CURRIED FUNCTION because
   * it takes multiple arguments, and returns a function
   * that takes a single argument.
   */
  def add_2(x:Int) = { (y:Int) => x + y }
}

========================================================================================

The foldLeft and foldRight functions implemented by the Scala List class are recursive
AND curried functions.  Below is sample code showing the use of the List.foldLeft and
List.foldRight functions.

The first argument list of foldLeft and foldRight represents the STARTING VALUE used on
the first function call of these recursive functions.  The second argument list of
foldLeft and foldRight represents the the function that gets applied.

object Demo
{
  def main(args:Array[String]): Unit =
  {
    // NOTE: foldLeft and foldRight are both RECURSIVE, CURRIED FUNCTIONS.
    //       When foldLeft and foldRight are called below, they get called
    //       with TWO PARAMETER LISTS.

    // ******************************************************************************
    // In this section we show how to use the List.foldLeft and List.foldRight
    // functions on the following intList, implementing the subtraction operation.
    // Notice we demonstrate TWO (2) different ways of implementing the subtraction
    // operation for foldLeft and foldRight that return the same result.
    // The math operation that occurs for foldLeft is:  0−7−4−6−3−9−1 = -30
    val intList:List[Int] = List[Int](7, 4, 6, 3, 9, 1)
    var intResult:Int = intList.foldLeft(0)(_ - _)
    println("foldLeft A = " + intResult) // PRINTS: foldLeft A = -30
    intResult = intList.foldLeft(0)((x, y) => x-y)
    println("foldLeft B = " + intResult) // PRINTS: foldLeft B = -30

    // The math operation that occurs for foldRight is:  0−(1−(9−(3−(6−(4−7))))) = 14
    intResult = intList.foldRight(0)(_ - _)
    println("foldRight A = " + intResult) // PRINTS: foldRight A = 14
    intResult = intList.foldRight(0)((x, y) => x-y)
    println("foldRight B = " + intResult) // PRINTS: foldRight B = 14

    // ******************************************************************************
    // In this section we show how to count the number of characters in the following
    // wordList, using the List.foldLeft and List.foldRight functions.  Notice we
    // demonstrate TWO (2) different ways of obtaining this character count for
    // foldLeft and foldRight that return the same result.
    val wordList:List[String] = List[String]("How", "many", "characters", "are", "in", "this", "wordList?")
    intResult = wordList.foldLeft(0)((count:Int, word:String) => count + word.length)
    println("foldLeft #1 = " + intResult) // PRINTS: foldLeft #1 = 35
    intResult = wordList.foldLeft(0)(_ + _.length)
    println("foldLeft #2 = " + intResult) // PRINTS: foldLeft #2 = 35

    intResult = wordList.foldRight(0)((word:String, count:Int) => count + word.length)
    println("foldRight #1 = " + intResult) // PRINTS: foldRight #1 = 35
    intResult = wordList.foldRight(0)(_.length + _)
    println("foldRight #2 = " + intResult) // PRINTS: foldRight #2 = 35

    // ******************************************************************************
    // In this section we call the foldLeft and FoldRight functions on the
    // following strList.
    val strList:List[String] = List[String]("ABC", "DEF", "GHI", "JKL", "MNO")
    var strResult:String = strList.foldLeft("START")(myFunc)
    println(strResult) // PRINTS: START-ABC-DEF-GHI-JKL-MNO

    strResult = strList.foldRight("BEGIN")(myFunc)
    println(strResult) // PRINTS: ABC-DEF-GHI-JKL-MNO-BEGIN
  }


  /**
   * NOTE: Scala defines List.foldLeft as this:   def foldLeft[B](z: B)(op: (B, A) => B): B
   *       Scala defines List.foldRight as this:  def foldRight[B](z: B)(op: (A, B) => B): B
   *
   * Therefore, this myFunc function satisfies the 2nd parameter list of foldLeft and foldRight,
   * because myFunc gets passed 2 values as a single parameter list, and returns a value.
   */
  def myFunc(str1:String, str2:String):String =
  {
    str1.concat("-").concat(str2)
  }
}

========================================================================================

In the code sample immediately ABOVE, the Scala API functions List.foldRight
and List.foldLight are demonstrated.  In the sample code BELOW, we write our
own functions named myFoldRightFunc and myFoldLeftFunc (both curried, recursive
functions), which emulate Scala's List.foldRight and List.foldLeft functions.

object Demo
{
  def main(args:Array[String]): Unit =
  {
    val floatList:List[Float] = List[Float](7.7F, 4.9F, 6.6F, 3.5F, 9.2F, 1.4F)

    // ********************************************************************************
    // In this section we demonstrate calling the myFoldRightFunc and myFoldLeftFunc
    // functions (defined below) on floatList.
    // The math operation performed by myFoldRightFunc is:  0.0-(1.4−(9.2−(3.5−(6.6−(4.9−7.7))))) = 13.7
    var floatResult:Float = myFoldRightFunc(floatList, 0.0F)(_ - _)
    println("floatResult = " + floatResult) // PRINTS: floatResult = 13.7

    // The math operation performed by myFoldLeftFunc is:  0.0 − 7.7 − 4.9 − 6.6 − 3.5 − 9.2 − 1.4 = -33.3
    floatResult = myFoldLeftFunc(floatList, 0.0F)(_ - _)
    println("floatResult = " + floatResult) // PRINTS: floatResult = -33.3

    // ********************************************************************************
    // In this section we demonstrate calling the myFoldLeftFunc and myFoldRightFunc
    // functions (defined below) on strList.
    val strList:List[String] = List[String]("ABC", "DEF", "GHI", "JKL", "MNO")
    var strResult:String = myFoldLeftFunc(strList, "START")(concat2Strings)
    println(strResult) // PRINTS: START-ABC-DEF-GHI-JKL-MNO

    strResult = myFoldRightFunc(strList, "BEGIN")(concat2Strings)
    println(strResult) // PRINTS: ABC-DEF-GHI-JKL-MNO-BEGIN
  }

  /**
   * THIS IS A CURRIED, RECURSIVE FUNCTION.
   */
  def myFoldLeftFunc[A,B](list:List[A], base:B)(funcOperation:(B,A)=>B):B =
  {
    if (list.isEmpty)
    {
      base // Terminate recursion when list is empty.
    }
    else
    {
      // Concat the result returned by the recursive myFoldLeftFunc call with list.head.
      funcOperation(myFoldLeftFunc(list.tail, base)(funcOperation),   list.head)
    }
  }

  /**
   * THIS IS A CURRIED, RECURSIVE FUNCTION.
   */
  def myFoldRightFunc[A,B](list:List[A], base:B)(funcOperation:(A,B)=>B):B =
  {
    if (list.isEmpty)
    {
      base // Terminate recursion when list is empty.
    }
    else
    {
      // Concat list.head with the result returned by the recursive myFoldRightFunc call.
      funcOperation(list.head,   myFoldRightFunc(list.tail, base)(funcOperation))
    }
  }

  /**
   * NOTE: myFoldRightFunc is defined above as this:
   *       def myFoldRightFunc[A,B](list:List[A], base:B)(func:(A,B)=>B):B
   *
   *       myFoldLeftFunc is defined above as this:
   *       def myFoldLeftFunc[A,B](list:List[A], base:B)(func:(B,A)=>B):B
   *
   * Therefore, this concat2Strings function satisfies the 2nd parameter list of myFoldLeftFunc
   * and myFoldRightFunc because concat2Strings gets passed 2 values as a single parameter list,
   * and returns a value.
   */
  def concat2Strings(str1:String, str2:String):String =
  {
    str1.concat("-").concat(str2)
  }
}

========================================================================================
========================================================================================
========================================================================================
