HOW TO IDENTIFY A CURRIED FUNCTION
----------------------------------
To determine if a function is a curried function, check the function's
parameter list.

CRITERIA NO. 1:
If a function definition contains MULTIPLE PARAMETER LISTS (not multiple
parameters, but multiple parameter lists), then the function is a curried
function.  EXAMPLE:
def add3Curried(x:Int)(y:Int) = { x+y }

CRITERIA  NO. 2:
If a function gets called with MULTIPLE PARAMETER LISTS (not multiple
parameters, but with multiple parameter lists), then the function is
also a curried function.  EXAMPLE:
add2Curried(123)(321)  OR  add2Curried(123)_  (NOTE the underscore char. is the second parameter.)

CRITERIA  NO. 3:
It's possible that a function is a curried function without meeting the
above two criteria.  The following function is a also a curried function.
It's definition, followed by how the function is called, is shown here.

def add2Curried(x:Int) = { (y:Int) => x+y }

val func1 = add2Curried(5)
println("func1 result = " + func1(20)) // Prints: func1 result = 25

We can see the above (Criteria No. 3) add2Curried function is a curried
function because...

1) The function definition takes one parameter, and returns a function
   that returns a value.
2) The val func1 function gets called TWICE--the first time  with
   a (5) parameter, the second time with a (20) parameter.


DEFINITION OF CURRYING
----------------------
Currying transforms a function that takes multiple parameters into
a chain of functions, where each function in the chain takes a
single parameter.

Assume you have a function that gets passed multiple parameters,
and returns a single value, such as the following add1 function...

def add1(x:Int, y:Int):Int = { x+y }

This add1 function gets passed an integer value x, an integer value y,
and it returns the integer value x+y.

Now let's rewrite the above add1 function in the following manner,
so it becomes a curried function, and name it add2Curried...

def add2Curried(x:Int) = { (y:Int) => x+y }

This add2Curried function gets passed an integer value x, and it returns a function.
Where the function returned takes an integer value y, and returns the integer
value x+y.  Thus, by calling the add2Curried function TWICE, we obtain the same
result as calling the add1 function ONCE.  (See the sample code below.)

Now let's rewrite the above add2Curried function in the following manner,
and name it add3Curried...

def add3Curried(x:Int)(y:Int) = { x+y }

This add3Curried function is identical to the add2Curried function,
except that it's syntax contains MULTIPLE PARAMETER LISTS, instead
of the standard single parameter list used by regular functions.
====================================================================
CURRYING EXAMPLE 1
====================================================================
object Demo
{
  def main(args: Array[String]):Unit =
  {
    println("add1(123, 321)        = " + add1(123, 321))
    println("add2Curried(123)(321) = " + add2Curried(123)(321))
    println("add3Curried(123)(321) = " + add3Curried(123)(321))

    // NOTE: It's NOT possible to call the add2Curried function with an underscore
    //       char (_) to designate the second param isn't being used, as is done
    //       below when calling the add3Curried function.
    val func1 = add2Curried(5)
    println("func1 result = " + func1(20)) // Prints: func1 result = 25

    // NOTE: When passing add3Curried only one parameter, the below underscore
    //       char (_) is required to designate the second param isn't being used.
    val func2 = add3Curried(5)_
    println("func2 result = " + func2(20)) // Prints: func2 result = 25
  }

  def add1(x:Int, y:Int):Int = { x+y }

  def add2Curried(x:Int) = { (y:Int) => x+y }

  def add3Curried(x:Int)(y:Int) = { x+y }
}
====================================================================
CURRYING EXAMPLE 2
====================================================================
object Demo
{
  def main(args: Array[String]):Unit =
  {
    val str1:String = "Hello, "
    val str2:String = "Scala!"

    println("strCatCurried_1(str1)(str2) = " +  strCatCurried_1(str1)(str2))
    println("strCatCurried_2(str1)(str2) = " +  strCatCurried_2(str1)(str2))
  }

  def strCatCurried_1(s1: String) = (s2: String) => s1 + s2
  def strCatCurried_2(s1: String)(s2: String) = s1 + s2
}
====================================================================
CURRYING EXAMPLE 3
====================================================================
object Demo
{
  def main(args:Array[String]): Unit =
  {
    val intList:List[Int] = List[Int](7, 4, 6, 3, 9, 1)

    // NOTE: foldLeft and foldRight are both CURRIED FUNCTIONS,
    //       as they get passed a value, and return a function
    //       that gets passed a value and returns a value.
    //       When foldLeft and foldRight are called below, they
    //       get called with TWO PARAMETER LISTS.

    // The following foldLeft function works on intList as follows:
    // The first argument list (0) takes the base value that's used
    // as the first operand.  The second argument list (_ - _) is the
    // function to apply.
    // 0−7−4−6−3−9−1 = ((((((0−7)−4)−6)−3)−9)−1) = -30
    println("intList.foldLeft(0)(_ - _) = " + intList.foldLeft(0)(_ - _))

    // The following foldRight function works on intList as follows:
    // The first argument list (0) takes the base value that's used
    // as the first operand.  The second argument list (_ - _) is the
    // function to apply.
    // 0−(1−(9−(3−(6−(4−7))))) = 14
    println("intList.foldRight(0)(_ - _) = " + intList.foldRight(0)(_ - _))


    val wordList:List[String] = List[String]("How", "many", "characters", "do", "we", "have?")
    // NOTE: The second parameter list for foldRight has its tuple order as (word, count),
    //       which is the reverse order used by the foldLeft function below.
    var wordCount:Int = wordList.foldRight(0)((word:String, count:Int) => count + word.length)
    println("wordCount.foldRight = " + wordCount)

    // NOTE: The second parameter list for foldLeft has its tuple order as (count, word),
    //       which is the reverse order used by the foldRight function above.
    wordCount = wordList.foldLeft(0)((count:Int, word:String) => count + word.length)
    println("wordCount.foldLeft = " + wordCount)

    println("wordList.foldLeft(0)(_+_.length)    = " + wordList.foldLeft(0)(_+_.length))
    println("wordList.foldRight(0)(_.length + _) = " + wordList.foldRight(0)(_.length + _))
  }
}
====================================================================
CURRYING EXAMPLE 4
====================================================================
object Demo
{
  def main(args:Array[String]): Unit =
  {
    val intList:List[Int] = List[Int](7, 4, 6, 3, 9, 1)
    val result = myFoldRightFunc(intList, 0)(_ - _)
    println("myFoldRightFunc result = " + result) // Prints: myFoldRightFunc result = 14
  }

  def myFoldRightFunc[A,B](list:List[A], base:B)(func:(A,B)=>B):B =
  {
    if (list.isEmpty)
    {
      base
    }
    else
    {
      func(list.head, myFoldRightFunc(list.tail, base)(func))
    }
  }
}
