CURRYING
========
All Scala functions that have multiple parameter lists are
curried functions.  Each set of parenthesis defined in a
function represents a parameter list.  For example...

// This standard function contains only one parameter list, with
// 3 arguments x, y, and z.  So this is NOT a curried function.
def addXYZ(x:Int, y:Int, z:Int):Int =  x + y + z

// The following 2 functions contain multiple parameter lists,
// which means these 2 functions are curried functions.
def addXY_Curried(x)(y)     = { x + y }
def addXYZ_Curried(x)(y)(z) = { x + y + z }

Currying transforms a function that has MULTIPLE PARAMETER LISTS
into a chain of functions, where each function in the chain gets
passed a single parameter list, and returns either a function
(that gets passed a parameter list) or the final value.

A Scala curried function has these three (3) criteria:

1) It contains two (2) or more parameter lists.

2) Calling it with fewer than all its parameter lists
   returns a function that takes a parameter, which
   means the function is partially applied.

3) When a curried function is called with the last of its
   multiple parameter lists, it returns a final value, not
   a function.  This makes the curried function fully applied.
   A curried function could have 2, 3, 4, 5, or even more
   parameter lists.


FULLY-APPLIED FUNCTION
======================
When a curried function is called by passing ALL its parameter lists,
it becomes a FULLY-APPLIED function, like this...

addXYZ_Curried(1)(2)(3) // Fully-applied function.

A function can also become fully-applied by calling it as a
PARTIALLY-APPLIED function, until all its parameter lists
are supplied, and its final value gets returned.

PARTIALLY-APPLIED FUNCTION
==========================
When a curried function gets called with fewer than all its parameter
lists, it's a PARTIALLY-APPLIED function.  This means the PARTIALLY-
APPLIED function returns a function that takes a parameter list.
When a PARTIALLY-APPLIED FUNCTION is called with its final parameter
list, it becomes FULLY-APPLIED, and returns a final value.

When a curried function is called as a partially applied function,
a single underscore character (_) designates all parameter list(s)
that aren't specified.  For example, the following 2 lines are
partially applied function calls because the function calls don't
include all 3 parameter lists:

addXYZ_Curried(1)_    // A partially applied function call.
addXYZ_Curried(1)(2)_ // A partially applied function call.

Curried functions can also be called as partially-applied functions
exactly as above, but without the underscore (_) char.  So the
underscore (_) char is OPTIONAL (not required), like this...

addXYZ_Curried(1)    // A partially applied function call.
addXYZ_Curried(1)(2) // A partially applied function call.

The following sample code shows multiple examples of curried functions
that get called as PARTIALLY-APPLIED and FULLY-APPLIED functions.
========================================================================================
object Demo
{
  def main(args: Array[String])
  {
    // The following function is curried because its definition contains multiple parameter lists.
    def addXYZ_Curried(x:Int)(y:Int)(z:Int):Int = { x + y + z }

    // *******************************************************************
    // addXYZ_Curried is called here as a FULLY-APPLIED FUNCTION because
    // all its parameter lists are supplied in a single function call.
    var result:Int = addXYZ_Curried(1)(2)(3) // Adds 1 + 2 + 3
    println("1) result = " + result) // PRINTS: 1) result = 6

    // *******************************************************************
    // addXYZ_Curried is called here as a PARTIALLY-APPLIED FUNCTION because
    // it first gets called with FEWER than all its parameter lists.
    // NOTE: When a curried function gets called with an underscore (_) char,
    //       it gets called as a PARTIALLY-APPLIED FUNCTION.  The underscore
    //       (_) char designates all parameter lists NOT SUPPLIED when the
    //       curried function gets called.
    var func1:(Int => (Int => Int)) = addXYZ_Curried(1)_ // PARTIALLY-APPLIED function call returns a function.
    var func2:(Int => Int) = func1(2) // func1() returns a function.
    result = func2(3) // func2() returns an Int.
    // Finally, we obtained the same result as calling: addXYZ_Curried(1)(2)(3)
    println("2) result = " + result) // PRINTS: 2) result = 6

    // *******************************************************************
    // addXYZ_Curried is called here as a PARTIALLY-APPLIED FUNCTION because
    // it first gets called with FEWER than all its parameter lists.
    func2 = addXYZ_Curried(1)(2)_ // PARTIALLY-APPLIED function call returns a function.
    result = func2(3) // func2() returns an Int.
    // Finally, we obtained the same result as calling: addXYZ_Curried(1)(2)(3)
    println("3) result = " + result) // PRINTS: 3) result = 6

    // *******************************************************************
    // NOTE: The underscore (_) char is NOT REQUIRED to call a curried
    //       function as a PARTIALLY-APPLIED function--it is OPTIONAL.
    //       ABOVE we called these 2 functions using the underscore (_):
    //       addXYZ_Curried(1)_
    //       addXYZ_Curried(1)(2)_
    //       BELOW we call those same 2 functions WITHOUT the underscore (_).
    func1 = addXYZ_Curried(1) // PARTIALLY-APPLIED function call returns a function.
    func2 = func1(2) // Returns a function.
    result = func2(3) // Returns an Int.
    // Finally, we obtained the same result as calling: addXYZ_Curried(1)(2)(3)
    println("4) result = " + result) // PRINTS: 4) result = 6

    func2 = addXYZ_Curried(1)(2) // PARTIALLY-APPLIED function call.
    result = func2(3) // Returns an Int.
    // Finally, we obtained the same result as calling: addXYZ_Curried(1)(2)(3)
    println("5) result = " + result) // PRINTS: 5) result = 6

    // *******************************************************************
    // Here's a final example of going from partially applied to fully applied.
    func1 = addXYZ_Curried(1)_ // The underscore (_) char is optional.
    func2 = func1.apply(2)     // func1.apply(2) = func1(2)
    result = func2.apply(3)    // func2.apply(3) = func2(3)
    println("6) result = " + result) // PRINTS: 6) result = 6
  }
}
========================================================================================

DEFINING CURRIED FUNCTIONS THAT CONTAIN ONLY ONE PARAMTER LIST
==============================================================

Above we said that all Scala functions defined with multiple parmater lists
are curried functions, which is correct.  But the following is also true...

A curried function that contains only one parameter list can be
defined as a curried function, like this...

def addXY_Curried(x:Int):(Int => Int) = { (y:Int) => x + y }

Notice how this addXY_Curried function returns a function that
takes a parameter.  Even though addXY_Curried is defined with
only one parameter list, it can still be called with two (2)
parameter lists.  See the following code sample to understand
the behavior of these 2 equivalent curried functions...

1) def addXY_Curried(x:Int):(Int => Int) = { (y:Int) => x + y }
2) def addCurried_2(x:Int)(y:Int) = { x+y }

object Demo
{
  def main(args: Array[String])
  {
    // The following function is curried because its definition contains multiple parameter lists.
    def addXY_Curried(x:Int):(Int => Int) = { (y:Int) => x + y }

    // *******************************************************************
    // The following COMMENTED-OUT line won't compile because
    // addXY_Curried is defined above with ONLY ONE parameter list.
    // Therefore, it CAN'T be called with an underscore (_) char
    // replacing a second parameter list that doesn't exist.

    // WON'T compile -->   addXY_Curried(5)_

    // *******************************************************************
    // The below code samples show several ways of calling addXY_Curried
    // function, and the equivalent addCurried_2 function.
    // *******************************************************************
    var result:Int = addXY_Curried(5)(2) // 5 + 2 = 7
    println("1) result = " + result) // PRINTS: 1) result = 7

    // Here we obtain the result identical to above, in a different way.
    var func1:(Int => Int) = addXY_Curried(5)
    result = func1(2) // 5 + 2 = 7
    println("2) result = " + result) // PRINTS: 2) result = 7

    // The addCurried_2 function defined below is an alternative way of
    // writing the above addXY_Curried function to obtain identical behavior.
    def addCurried_2(x:Int)(y:Int) = { x+y }

    func1 = addCurried_2(5)_ // Underscore (_) char here is optional.
    result = func1(2) // 5 + 2 = 7
    println("3) result = " + result) // PRINTS: 3) result = 7
  }
}

========================================================================================







This simple demonstration of currying shows how to use the apply() method as an
alternative way of calling a curried function.,  Read in-line comments below
for details.

object Demo
{
  def main(args: Array[String])
  {
    // Immediately after sum1(2) gets called, sum1() is partially applied.
    // After func1(5) gets called, the sum1() function is fully applied.
    var func1:(Int => Int) = sum1(2)
    println(func1(5))       // PRINTS: 7  (NOTE: 7 = 2 + 5)
    println(func1.apply(5)) // Equivalent to the previous line of code.

    // Immediately after sum2(2)(42) gets called, sum2() is partially applied.
    // After func(13) gets called, sum2() is fully applied.
    func1 = sum2(2)(42)
    println(func1(13))       // PRINTS: 57 (NOTE: 57 = 2 + 42 + 13)
    println(func1.apply(13)) // Equivalent to the previous line of code.
  }

  def sum1(a: Int):(Int => Int)       = { b => a + b }     // b is the value  5 passed from func1(5)
  def sum2(a:Int)(b:Int):(Int => Int) = { c => a + b + c } // c is the value 13 passed from func1(13)
}

========================================================================================

Recall that a PARAMETRIC FUNCTION is defined to accept any valid data type that
can work with the function.  For example, instead of defining 3 different add()
functions to work with the Int, Float, and Double data types, you can write a
single add() function as a parametric function, so it'll work with all 3 of
those data types.  See the below code sample.

Notice this text in the code below:  (implicit numeric:Numeric[A])
This implicit function call was added as another parameter list to
make add() a curried function that works with Scala's Numeric class.

object Demo
{
  // The following add() function is written as a parametric function,
  // where the parametric type A represents any numeric data type.
  def add[A](x:A, y:A)(implicit numeric:Numeric[A]):A = numeric.plus(x, y)

  def main(args:Array[String]): Unit =
  {
    println("add(1.23F, 4.56F) = " + add(1.23F, 4.56F)) // PRINTS: add(1.23F, 4.56F) = 5.79
    println("add(1.23D, 4.56D) = " + add(1.23D, 4.56D)) // PRINTS: add(1.23D, 4.56S) = 5.789999999999999
    println("add(123, 456)     = " + add(123, 456))     // PRINTS: add(123, 456)     = 579
    println("add(123, 4.56F)   = " + add(123, 4.56F))   // PRINTS: add(123, 456)     = 127.56
  }
}

========================================================================================

Since the add() function defined above uses ONLY ONE parametric type, you need
only ONE letter (A, B, C, X, Y, Z, etc.) to designate the parametric type.

However, the following curried function funcXYZ requires multiple parametric types
in its definition.  In the funcXYZ function definition below, you can still choose
any letters you want to designate the types, but you must choose the correct parametric
type in each of the many locations where one is used.  Keep reading below for an
explanation of how this is determined.

========================================================================================

object Demo
{
  def funcX(x:Int):Int = { x + 10 }
  def funcY(y:Int):Int = { y - 3 }
  def funcZ(z:Int):Int = { z * 4 }

  // funcXYZ is identical to the below funcXYZ_2 function,
  // except funcXYZ_2 has 3 PARAMETER LISTS.
  def funcXYZ[A,B,C,D](funcX:(C=>D), funcY:(B=>C), funcZ:(A=>B)):(A=>D) =
  {
    x => funcX(funcY(funcZ(x)))
  }

  // funcXYZ_2 is identical to the above funcXYZ function,
  // except funcXYZ has 1 PARAMETER LIST containing 3 parameters.
  def funcXYZ_2[A,B,C,D](funcX:(C=>D))(funcY:(B=>C))(funcZ:(A=>B)):(A=>D) =
  {
    x => funcX(funcY(funcZ(x)))
  }

  def main(args:Array[String]): Unit =
  {
    var result:Int = funcXYZ(funcX, funcY, funcZ)(5)
    println("result = " + result) // PRINTS: result = 27

    result = funcXYZ_2(funcX)(funcY)(funcZ)(5)
    println("result = " + result) // PRINTS: result = 27
  }
}

========================================================================================

NOTICE: The above funcXYZ and funcXYZ_2 functions will generate identical results
        after both those functions become FULLY APPLIED.  The ONLY way they differ
        is that funcXYZ is defined to take 3 parameters in 1 PARAMETER LIST,
        while funcXYZ_2 is defined to take 3 PARAMETER LISTS.

FROM THIS POINT ON, ONLY THE funcXYZ FUNCTION IS DISCUSSED, NOT THE funcXYZ_2 FUNCTION.

In the above funcXYZ definition, the letters in the [A,B,C,D] section can
appear in ANY ORDER you want.  For example:
funcXYZ[A,B,C,D]...
funcXYZ[B,A,D,C]...
funcXYZ[D,C,A,B]...
The order won't affect the behavior of the code, but it's best to always
keep them in alphabetical order.  Following that text in the function
definition, the correct parametric type must be used wherever one is referenced.

The funcXYZ definition uses parametric types to designate several return types.
You can choose any letters for the parametric types, but YOU SHOULD ALWAYS
begin using letter A, followed by B, C, D, etc. so it's easy to follow the order.
This part explains how the parametric return types are determined.

We begin by observing what funcXYZ returns.  We see that funcXYZ returns this...

x => funcX(funcY(funcZ(x)))

That's a function, which takes a single parameter (x), and returns this line of code:

funcX(funcY(funcZ(x)))  // Where x is the param passed to funcZ

When that line of code is executed, the first thing that executes is funcZ.
Let's begin by saying funcZ takes parameter A (representing the x parameter
value passed to funcZ), and it returns the value B, like this:

A=>B   (funcZ return type)

The next thing that executes is funcY.  The parameter fed to funcY comes
from the value returned by funcZ.  So the funcY return type is:

B=>C   (funcY return type)

The next thing that executes is funcX.  The parameter fed to funcX comes
from the value returned by funcY.  So the funcX return type is:

C=>D   (funcX return type)

Finally, we need to designate what funcXYZ returns.  funcXYZ RETURNS A FUNCTION that
takes the parameter x.  Notice that this x parmameter is literally the same value
that gets passed to funcZ.  Since funcZ defined that x value as type A, funcXYZ
must also use that same A value in its return type.  Therefore, the funcXYZ
return type is:

A=>D   (funcXYZ return type)

Now we can write the funcXYZ definition (shown below) using these return types...

funcXYZ returns: A=>D
funcZ   returns: A=>B
funcY   returns: B=>C
funcX   returns: C=>D

Those are the return types that get plugged into the funcXYZ definition, like this:

def funcXYZ[A,B,C,D](funcX:(C=>D), funcY:(B=>C), funcZ:(A=>B)):(A=>D) =
{
  x => funcX(funcY(funcZ(x)))
}

TAKE NOTE: The A value in the funcXYZ return type is literally the same value
           as the A value in the funcZ return type.  When funcXYZ is executed
           (either as a partially-applied or fully-applied function) funcZ
           is ALWAYS the FIRST parameter list executed.

           The D value in the funcXYZ return type is literally the same value
           as the D value in the funcX return type.  When funcXYZ becomes
           fully applied, funcX is ALWAYS the LAST parameter list executed.

========================================================================================

Here is another example of currying.  Read in-line comments below for explanations.

object Demo
{
  // NOTE: This wrap function is a curried function that takes
  //       3 parameter lists (all 3 are Strings), and returns a String.
  def wrap(prefix:String)(html:String)(suffix:String) =
  {
    prefix + html + suffix
  }

  // NOTE: This wrapWithDiv function RETURNS the above wrap function, where
  //       the wrap function's middle parameter list isn't specified, which
  //       is designated by the the (_) parameter list.  Therefore, this
  //       wrapWithDiv function is defined as a PARTIALLY APPLIED function
  //       call to the wrap function.
  def wrapWithDiv:(String => String) = wrap("<div>")(_)("</div>")

  def main(args: Array[String])
  {
    // NOTE: When main() calls wrapWithDiv by passing it a String, the wrap
    //       function gets called as a FULLY APPLIED function call because it's
    //       now supplied with its previously-unspecified parameter list (_).
    println(wrapWithDiv("My_Text")) // PRINTS: <div>My_Text</div>
  }
}

========================================================================================
The following code is an example of calling a recursive curried function.  The curried
forloop()() function is called as a fully-applied function (with 2 parameter lists)
every time it executes a loop.

When 'count > 0' evaluates to false in the main() function, the forloop()()
function is called as a partially-applied function (with only 1 parameter list),
and then terminates.
========================================================================================

object Demo
{
  def main(args: Array[String])
  {
    var count = 5
    forloop(count > 0) // 'count > 0' is passed to the 1st param. list of the forloop()() function.
    {
      // The code contained within these curly braces {} is passed as
      // the 2nd param. list to the curried forloop()() function.
      print("count = " + count + ",  ") // PRINTS: count = 5,  count = 4,  count = 3,  count = 2,  count = 1,
      count -= 1
    }
    println("\nProgram Terminated.") // PRINTS: Program Terminated.
  }

  /**
   * This forloop()() function is a RECURSIVE CURRIED FUNCTION with 2 argument lists.
   * BOTH its arguments are Pass-By-Value functions (aka, Nullary functions), which
   * means they get passed A BLOCK OF SCALA CODE.
   */
  def forloop(rule: => Boolean)(body: => Unit):Unit =
  {
    if (rule)
    {
      body // Executes the Scala code passed to the 2nd parameter list.
      forloop(rule)(body) // This is a RECURSIVE function call.
    }
  }
}

========================================================================================
The following sample code includes this parametric curried function:

def funcOfGunc[A,B,C](func:(B=>C), gunc:(A=>B)):(A=>C) = { x=>func(gunc(x)) }

This part explains how funcOfGunc was defined.

1)
We will pass 2 functions to funcOfGunc in a single parameter list.  Both those
functions will get passed a Double, and return a Double.

NOTICE: Recall that a curried function always has at least TWO (2) parameter
        lists.  The second parameter list that funcOfGunc accepts is NOT included
        in the funcOfGunc definition because funcOfGunc returns a function that
        accepts a single parameter.  Therefore, the return value of funcOfGunc
        is where the second parameter list gets defined.

2)
Since the gunc function gets called FIRST, we will begin by saying gunc(x) gets
passed a parameter of type A, and returns type B.  So gunc has this return type:
A=>B

2)
The func function gets called AFTER gunc is called, and gets passed the
value returned by gunc, which is type B.  So func has this return type:
B=>C

4)
After both the func and gunc functions passed to funcOfGunc are called
(i.e., func(gunc(x))), funcOfGunc returns its value, which is a function
that gets passed a parameter.

Therefore, funcOfGunc gets passed the same value passed to gunc (parameter
type A), and it returns the same value returned by func (parameter type C).
So funcOfGunc has this return type:
A=>C

========================================================================================

object Demo
{
  def main(args:Array[String]): Unit =
  {
    val plus5:(Double=>Double)  = { x:Double => x+5.0D }
    val square:(Double=>Double) = { x:Double => x*x }

    // NOTE: 54.0 = 5.0+(7.0*7.0)
    var result:Double = funcOfGunc(plus5, square)(7.0D)
    println("result = " + result) // PRINTS: result = 54.0

    // NOTE: 144.0 = (5.0+7.0)*(5.0+7.0)
    result = funcOfGunc(square, plus5)(7.0D)
    println("result = " + result) // PRINTS: result = 144.0
  }

  def funcOfGunc[A,B,C](func:(B=>C), gunc:(A=>B)):(A=>C) = { x=>func(gunc(x)) }
}

========================================================================================

The following code sample shows an example of transforming a regular function into
a curried function by first performing an eta expansion on it by adding the underscore
(_) character, and then calling Scala's .curried() method.

object Demo
{
  def main(args: Array[String])
  {
    // The following line of code converts the add() function defined below
    // (which contains one parameter list) into a curried function (which
    // contains two parameter lists) via an "Eta Expansion".  The "Eta
    // Expansion" occurs when adding the underscore character (_) after
    // the "add" method name.
    val addFunction:((Int, Int)=>Int)        = add _  // The underscore char (_) on this line is REQUIRED.
    val addFunctionCurried:(Int=>(Int=>Int)) = addFunction.curried // Converts the addFunction into a curried function.

    println(add(123, 456))                // PRINTS: 579
    println(addFunction(123, 456))        // PRINTS: 579
    println(addFunctionCurried(123)(456)) // PRINTS: 579

    // The following TWO (2) calls to addFunctionCurried show
    // how to call addFunctionCurried in 2 separate steps.
    // Firstly, as a partially-applied function call.  Secondly,
    // as a fully-applied function call.
    val func1:(Int => Int) = addFunctionCurried(123)(_) // Partially applied function call.
    println(func1(456)) // Fully applied function call.  PRINTS: 579

    val func2:(Int => Int) = addFunctionCurried(123) // Partially applied function call.
    println(func2(456)) // Fully applied function call.  PRINTS: 579
  }

  /**
   * This add() function is a regular Scala function.  In the code
   * above, this add() function is used to create a curried function
   * by calling:  addFunction.curried
   */
  def add(x:Int, y:Int):Int = { x + y }
}

========================================================================================

The following code sample shows another example of transforming a regular
function into a curried function by first performing an eta expansion on
it by adding the underscore (_) character, and then calling Scala's .curried()
method.

object Demo
{
  def main(args: Array[String])
  {
    // The add_1() function is a just a standard, normal function.
    // The first time the add_1() is called here, it's called in
    // the usual way....
    println("add_1(7, 3) = " + add_1(7, 3)) // PRINTS: add_1(7, 3) = 10

    // Perform an "Eta Expansion" on add_1() by using the underscore (_) character...
    val addFunc:((Int, Int) => Int) = add_1 _

    val addFuncCurried:(Int => (Int => Int)) = addFunc.curried // Make the add_1() function a curried function.
    println("addFuncCurried(7)(3) = " + addFuncCurried(7)(3)) // PRINTS: addFuncCurried(7)(3) = 10

    // addFuncCurried called with one param returns a PARTIALLY APPLIED function...
    val partiallyAppliedCurried:(Int => Int) = addFuncCurried(7)
    // Call partiallyAppliedCurried to make addFuncCurried FULLY APPLIED...
    println("partiallyAppliedCurried(3) = " + partiallyAppliedCurried(3)) // PRINTS: partiallyAppliedCurried(3) = 10

    // *****************************************************************************************
    // The add_2()() function called below is a curried function,
    // and can be called in the following two (2) ways...
    //
    // 1) Call sum_2()() once by passing to it both Int params, so it
    //    returns an Int result...
    println("add_2(7)(3) = " + add_2(7)(3)) // PRINTS: add_2(7)(3) = 10

    // 2) Call sum_2()() twice...  sum_2()() is called the first time by
    //    initializing its x Int parameter, and it returns a function.
    //    (At this point, the sum_2()() function is PARTIALLY APPLIED)
    //    Then, sum_2()() is called the second time by initializing
    //    its y Int parameter so it will now return an Int value.
    //    (At this point, the sum_2()() function is FULLY APPLIED.)
    val func:(Int => Int) = add_2(7)(_) // The func function is PARTIALLY APPLIED here.
    println("func(3) = " + func(3)) // PRINTS: func(3) = 10  (func is now FULLY APPLIED.)
  }

  /**
   * This add_1() function is a normal function, NOT a curried function.
   */
  def add_1(x:Int, y:Int):Int = { x + y }

  /**
   * This add_2() function is a CURRIED FUNCTION because
   * it takes multiple arguments, and returns a function
   * that takes a single argument.
   */
  def add_2(x:Int) = { (y:Int) => x + y }
}

========================================================================================

The foldLeft and foldRight functions implemented by the Scala List class are recursive
AND curried functions.  Below is sample code showing the use of the List.foldLeft and
List.foldRight functions.

The first argument list of foldLeft and foldRight represents the STARTING VALUE used on
the first function call of these recursive functions.  The second argument list of
foldLeft and foldRight represents the the function that gets applied.

object Demo
{
  def main(args:Array[String]): Unit =
  {
    // NOTE: foldLeft and foldRight are both RECURSIVE, CURRIED FUNCTIONS.
    //       When foldLeft and foldRight are called below, they get called
    //       with TWO PARAMETER LISTS.

    // ******************************************************************************
    // In this section we show how to use the List.foldLeft and List.foldRight
    // functions on the following intList, implementing the subtraction operation.
    // Notice we demonstrate TWO (2) different ways of implementing the subtraction
    // operation for foldLeft and foldRight that return the same result.
    // The math operation that occurs for foldLeft is:  0−7−4−6−3−9−1 = -30
    val intList:List[Int] = List[Int](7, 4, 6, 3, 9, 1)
    var intResult:Int = intList.foldLeft(0)(_ - _)
    println("foldLeft A = " + intResult) // PRINTS: foldLeft A = -30
    intResult = intList.foldLeft(0)((x, y) => x-y)
    println("foldLeft B = " + intResult) // PRINTS: foldLeft B = -30

    // The math operation that occurs for foldRight is:  0−(1−(9−(3−(6−(4−7))))) = 14
    intResult = intList.foldRight(0)(_ - _)
    println("foldRight A = " + intResult) // PRINTS: foldRight A = 14
    intResult = intList.foldRight(0)((x, y) => x-y)
    println("foldRight B = " + intResult) // PRINTS: foldRight B = 14

    // ******************************************************************************
    // In this section we show how to count the number of characters in the following
    // wordList, using the List.foldLeft and List.foldRight functions.  Notice we
    // demonstrate TWO (2) different ways of obtaining this character count for
    // foldLeft and foldRight that return the same result.
    val wordList:List[String] = List[String]("How", "many", "characters", "are", "in", "this", "wordList?")
    intResult = wordList.foldLeft(0)((count:Int, word:String) => count + word.length)
    println("foldLeft #1 = " + intResult) // PRINTS: foldLeft #1 = 35
    intResult = wordList.foldLeft(0)(_ + _.length)
    println("foldLeft #2 = " + intResult) // PRINTS: foldLeft #2 = 35

    intResult = wordList.foldRight(0)((word:String, count:Int) => count + word.length)
    println("foldRight #1 = " + intResult) // PRINTS: foldRight #1 = 35
    intResult = wordList.foldRight(0)(_.length + _)
    println("foldRight #2 = " + intResult) // PRINTS: foldRight #2 = 35

    // ******************************************************************************
    // In this section we call the foldLeft and FoldRight functions on the
    // following strList.
    val strList:List[String] = List[String]("ABC", "DEF", "GHI", "JKL", "MNO")
    var strResult:String = strList.foldLeft("START")(myFunc)
    println(strResult) // PRINTS: START-ABC-DEF-GHI-JKL-MNO

    strResult = strList.foldRight("BEGIN")(myFunc)
    println(strResult) // PRINTS: ABC-DEF-GHI-JKL-MNO-BEGIN
  }


  /**
   * NOTE: Scala defines List.foldLeft as this:   def foldLeft[B](z: B)(op: (B, A) => B): B
   *       Scala defines List.foldRight as this:  def foldRight[B](z: B)(op: (A, B) => B): B
   *
   * Therefore, this myFunc function satisfies the 2nd parameter list of foldLeft and foldRight,
   * because myFunc gets passed 2 values as a single parameter list, and returns a value.
   */
  def myFunc(str1:String, str2:String):String =
  {
    str1.concat("-").concat(str2)
  }
}

========================================================================================

In the code sample immediately ABOVE, the Scala API functions List.foldRight
and List.foldLight are demonstrated.  In the sample code BELOW, we write our
own functions named myFoldRightFunc and myFoldLeftFunc (both curried, recursive
functions), which emulate Scala's List.foldRight and List.foldLeft functions.

object Demo
{
  def main(args:Array[String]): Unit =
  {
    val floatList:List[Float] = List[Float](7.7F, 4.9F, 6.6F, 3.5F, 9.2F, 1.4F)

    // ********************************************************************************
    // In this section we demonstrate calling the myFoldRightFunc and myFoldLeftFunc
    // functions (defined below) on floatList.
    // The math operation performed by myFoldRightFunc is:  0.0-(1.4−(9.2−(3.5−(6.6−(4.9−7.7))))) = 13.7
    var floatResult:Float = myFoldRightFunc(floatList, 0.0F)(_ - _)
    println("floatResult = " + floatResult) // PRINTS: floatResult = 13.7

    // The math operation performed by myFoldLeftFunc is:  0.0 − 7.7 − 4.9 − 6.6 − 3.5 − 9.2 − 1.4 = -33.3
    floatResult = myFoldLeftFunc(floatList, 0.0F)(_ - _)
    println("floatResult = " + floatResult) // PRINTS: floatResult = -33.3

    // ********************************************************************************
    // In this section we demonstrate calling the myFoldLeftFunc and myFoldRightFunc
    // functions (defined below) on strList.
    val strList:List[String] = List[String]("ABC", "DEF", "GHI", "JKL", "MNO")
    var strResult:String = myFoldLeftFunc(strList, "START")(concat2Strings)
    println(strResult) // PRINTS: START-ABC-DEF-GHI-JKL-MNO

    strResult = myFoldRightFunc(strList, "BEGIN")(concat2Strings)
    println(strResult) // PRINTS: ABC-DEF-GHI-JKL-MNO-BEGIN
  }

  /**
   * THIS IS A CURRIED, RECURSIVE FUNCTION.
   */
  def myFoldLeftFunc[A,B](list:List[A], base:B)(funcOperation:(B,A)=>B):B =
  {
    if (list.isEmpty)
    {
      base // Terminate recursion when list is empty.
    }
    else
    {
      // Concat the result returned by the recursive myFoldLeftFunc call with list.head.
      funcOperation(myFoldLeftFunc(list.tail, base)(funcOperation),   list.head)
    }
  }

  /**
   * THIS IS A CURRIED, RECURSIVE FUNCTION.
   */
  def myFoldRightFunc[A,B](list:List[A], base:B)(funcOperation:(A,B)=>B):B =
  {
    if (list.isEmpty)
    {
      base // Terminate recursion when list is empty.
    }
    else
    {
      // Concat list.head with the result returned by the recursive myFoldRightFunc call.
      funcOperation(list.head,   myFoldRightFunc(list.tail, base)(funcOperation))
    }
  }

  /**
   * NOTE: myFoldRightFunc is defined above as this:
   *       def myFoldRightFunc[A,B](list:List[A], base:B)(func:(A,B)=>B):B
   *
   *       myFoldLeftFunc is defined above as this:
   *       def myFoldLeftFunc[A,B](list:List[A], base:B)(func:(B,A)=>B):B
   *
   * Therefore, this concat2Strings function satisfies the 2nd parameter list of myFoldLeftFunc
   * and myFoldRightFunc because concat2Strings gets passed 2 values as a single parameter list,
   * and returns a value.
   */
  def concat2Strings(str1:String, str2:String):String =
  {
    str1.concat("-").concat(str2)
  }
}

========================================================================================

Once you understand all the code and all the explanations above,
let's take another look at the curried function we used above...

def addXYZ_Curried(x:Int)(y:Int)(z:Int):Int = { x + y + z }

Assume you have code that calls this function in the following
manner, let's examine its behavior.

addXYZ_Curried(1)  // This returns this FUNCTION: (1 + (y + z))
addXYZ_Curried(2)  // This returns this FUNCTION: (1 + 2 + z) = (3 + z)
addXYZ_Curried(3)  // This returns this VALUE:    1 + 2 + 3 = 6


========================================================================================
========================================================================================
