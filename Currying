
Read the following link, and use info. from the link
to add infor to this page.
--> https://conorfennell.github.io/scala-zen/articles/functional-jargon.html#higher-order-functions-hof-

CURRYING
========

A curried function is any function that returns a function,
where the returned function accepts a single parameter list.
NOTE:  The single parameter list of a curried function can
       contain one argument, or multiple arguments.

All Scala functions defined with multiple parameter lists are
curried functions with the exception of implicit arguments...

When a method/function includes an implicit argument in one of
its parameter lists, it's NOT a curried function.  SEE SECTION TITLED:
FUNCTIONS WITH IMPLICIT PARAMETER LISTS ARE NOT CURRIED FUNCTIONS

Sometimes multiple parameter lists are used in while() loops or
for() loops.  Under those circumstances the first parameter list
evaluates to a true/false expression, and the second parameter
list contains a "block of code" that gets executed for each
iteration of the loop.  SEE SECTION TITLED:
WHEN MULTIPLE PARAMETER LISTS ARE USED FOR LOOPING

Each set of parenthesis defined in a function represents a
parameter list.  For example, the following 2 functions
contain multiple parameter lists, which means these 2 functions
are curried functions.

def addXY_Curried(x:Int)(y:Int) = { x + y }
def addXYZ_Curried(x:Int)(y:Int)(z:Int) = { x + y + z }

Currying transforms a function into a chain of functions.  Where each
function in the chain gets passed a single parameter list, and returns
a function that accepts a single parameter list.  When a curried function
is finally called with its last (of multiple) parameter lists, the
curried function becomes fully applied, and returns NOT a function,
but a final value.

Whenever a Scala curried function is called, the function is either
partially applied, or fully applied.  Here are the definitions:

2) FULLY APPLIED FUNCTION - When a curried function is called with the
   last of its multiple parameter lists, it returns a final value, not
   a function.  This makes the curried function fully applied.

2) PARTIALLY APPLIED FUNCTION - Calling a curried function with fewer
   than all its parameter lists means that function is partially applied,
   because it returns a function which accepts a single parameter list.

   IMPORTANT: When a curried function is called as a partially applied
              function an OPTIONAL underscore character (_) at the end
              of its parameter list(s) designates all parameter list(s)
              that aren't specified.

   It's possible to define a curried function that contains only
   one parameter list in its fuction definition.  To see an example
   of how a curried function containing only one parameter list in
   its definition is defined, read the section further below titled:
   DEFINING A CURRIED FUNCTION HAVING ONLY ONE PARAMETER LIST

NOTE: Don't confuse a "partially applied function" with a "partial function"
      because THEY'RE NOT THE SAME.  A partial function is defined in the
      Scala API as:  PartialFunction 
      PartialFunction is defined as both a Scala trait and a Scala object.

========================================================================================

The following code sample shows how to call a curried function
as fully applied and partially applied.  It also shows how to
call a partially applied function with the OPTIONAL underscore
character (_) at the end of the parameter list(s).

object Demo
{
  def main(args: Array[String])
  {
    def addXYZ_Curried(x:Int)(y:Int)(z:Int) = { x + y + z }

    // Here we call addXYZ_Curried()()() by passing it all 3 of its
    // parameter lists at once, thus making it a fully-applied function.
    var result = addXYZ_Curried(1)(2)(3) // The function is fully applied.
    println(s"1) result = $result") // PRINTS: 1) result = 6

    // Here we call addXYZ_Curried()()() 3 separate times, passing it
    // one parameter list each time it's called.  The first two times
    // it's called the function is partially applied.  The third time
    // it's called the function becomes fully applied.
    var func1:Int =>(Int => Int) = addXYZ_Curried(1)_  // The underscore char (_) is optional.
    var func2:Int => Int = func1(2) // An underscore char after func1(2) WON'T COMPILE!
    result = func2(3) // The function is fully applied.
    println(s"2) result = $result") // PRINTS: 2) result = 6

    // Here we call addXYZ_Curried()()() 2 separate times.  he first time it's
    // called we pass it two parameter lists, so it's partially applied.
    // The third (and last time) it's called, function becomes fully applied.
    func2 = addXYZ_Curried(1)(2)_ // The underscore char (_) is optional.
    result = func2(3) // The function is now fully applied.
    println(s"3) result = $result") // PRINTS: 3) result = 6
  }
}

========================================================================================
DEFINING A CURRIED FUNCTION HAVING ONLY ONE PARAMETER LIST
==========================================================

Above we stated that all Scala functions defined with multiple parmater lists
are curried functions--EXCEPT when one of the parameter lists includes an
implicit argument, as is explained further below.  However, the following
is also true...

A function that contains only one parameter list can be a curried function
if it's defined like this...

def addXY_Curried_1(x:Int):(Int => Int) = { (y:Int) => x + y }

Even though this addXY_Curried_1() function is defined with only one
parameter list, it's a curried function because it returns a
function that takes a single parameter list.  Therefore, addXY_Curried_1()
is not fully applied until it gets called with two (2) parameter
lists, as is demonstrated in the sample code below.

The sample code below defines the following two functions.

1) def addXY_Curried_1(x:Int):(Int => Int) = { (y:Int) => x + y }
2) def addXY_Curried_2(x:Int)(y:Int)       = { x + y }

Both these functions have IDENTICAL BEHAVIOR, with this one exception:

This line of code WON'T compile:  addXY_Curried_1(5)_
This line of code WILL compile:   addXY_Curried_2(5)_

addXY_Curried_1(5)_ won't compile because the definition
of addXY_Curried_1() contains only one parameter list.

addXY_Curried_2(5)_ will compile because the definition
of addXY_Curried_2()() contains two parameter lists.

object Demo
{
  def main(args: Array[String])
  {
    // The following function is curried because its
    // definition contains multiple parameter lists.
    def addXY_Curried_1(x:Int):(Int => Int) = { (y:Int) => x + y }

    // ********************************************************************
    // The following COMMENTED-OUT line won't compile because addXY_Curried_1
    // is defined above with ONLY ONE parameter list.  Therefore, it CAN'T
    // be called with an underscore char (_) replacing the remaining parameter
    // list(s), as the definition contains only one parameter list.
    //
    // WON'T compile:  addXY_Curried_1(5)_

    // *******************************************************************
    // The below code samples show several ways of calling addXY_Curried_1
    // function, and the equivalent addXY_Curried_2 function.
    // *******************************************************************
    var result:Int = addXY_Curried_1(5)(2) // 5 + 2 = 7
    println("1) result = " + result) // PRINTS: 1) result = 7

    // Here we obtain the result identical to above, in a different way.
    var func:(Int => Int) = addXY_Curried_1(5)
    result = func(2) // 5 + 2 = 7
    println("2) result = " + result) // PRINTS: 2) result = 7

    // The addXY_Curried_2 function defined below is an alternative way of
    // writing the above addXY_Curried_1 function to obtain identical behavior.
    def addXY_Curried_2(x:Int)(y:Int) = { x + y }

    func = addXY_Curried_2(5)_ // The underscore char (_) here is optional.
    result = func(2) // 5 + 2 = 7
    println("3) result = " + result) // PRINTS: 3) result = 7
  }
}

========================================================================================
Below is an example of two curried functions that can get called with one more
parameter list than is contained in their definitions.

Although the sum1() function is defined with only one parameter list, it
doesn't become fully-applied until it's called with two parameter lists.

Although the sum2() function is defined with two parameter lists, it
doesn't become fully-applied until it's called with three parameter lists.

object Demo
{
  def main(args: Array[String])
  {
    // NOTE: Both of the following 2 functions return a function
    //       that takes an Int as a parameter.  Therefore...
    //       1) The sum1() function must get called with TWO (2)
    //          parameter lists until it's fully applied.
    //       2) The sum2()() function must get called with THREE (3)
    //          parameter lists until it's fully applied.
    def sum1(a: Int):(Int => Int)       = { b => a + b }
    def sum2(a:Int)(b:Int):(Int => Int) = { c => a + b + c }

    var func:(Int => Int) = sum1(123) // sum1() is partially applied.
    var result:Int = func(321)        // sum1() is fully applied.
    println(s"1) result = $result") // PRINTS: 1) result = 444

    func = sum2(5)(10) // sum2()() is partially applied.
    result = func(20)  // sum2()() is fully applied.
    println(s"2) result = $result") // PRINTS: 2) result = 35
  }
}

========================================================================================
FUNCTIONS WITH IMPLICIT PARAMETER LISTS ARE NOT CURRIED FUNCTIONS
=================================================================

When a function definition contains multiple parameter lists, that function
is generally a curried function, but not always!  Here is an exception...

When a function definition contains multiple parameter lists, and one
of those parameter lists contains an implicit argument, that function
is NOT a curried function.

Read the section titled "Implicit_Parameters" for more info on this.
SEE --> https://github.com/w9mwi/Scala/blob/master/Implicit_Parameters

========================================================================================
WHEN MULTIPLE PARAMETER LISTS ARE USED FOR LOOPING
==================================================

The myWhileLoop()() method in the sample code below has this definition:

def myWhileLoop(testCondition: => Boolean)(codeBlock: => Unit):Unit = { ... }

Its 1st parameter list is:  (testCondition: => Boolean)
Its 2nd parameter list is:  (codeBlock: => Unit)

Obviously, the "=> Boolean" designates a function that returns a Boolean,
and the "=> Unit" designates a function that returns nothing.  But the
following question arises...

QUESTION: Why is there no data type specified between the colon (:) and
          the rocket (=>) in these two parameter lists, as you may expect?

          (testCondition: => Boolean)
          (codeBlock: => Unit)

ANSWER:  Because both those parameter lists do NOT get passed a value (i.e.,
         Int, String, Boolean, List[Float], etc.).  The first parameter list
         contains a Scala expression that evaluates to true/false.  A Scala
         expression (i.e., idx < 5) is NOT a data type.  The second parameter
         list contains a block of Scala code.  A block of code is also NOT
         a data type.  Therefore, no data type is specified for the testCondition
         and codeBlock arguments.

         In the code sample below the testCondition argument literally accepts
         this expression: (idx < 5), which has no data type but does evaluate
         to a Boolean.  So testCondition returns a Boolean type.

         The codeBlock argument literally accepts a block (several lines) of
         Scala code, which has no data type.  In the sample code below the last
         line of code executed in codeBlock doesn't evaluate to anything,
         so codeBlock returns a Unit type.

NOTE: It's possible for a block of code to evaluate to a value like Int, String,
      List[Float], etc. based on the last line of code executed.  Therefore it's
      possible for a block of code to have return data type.  For example, if
      the last line executed in codeBlock evaluated to a String, then codeBlock
      would return a String.  If that were the case, the function defined in
      the sample code below would...
      look like this:   def myWhileLoop(testCondition: => Boolean)(codeBlock: => String):Unit
      instead of this:  def myWhileLoop(testCondition: => Boolean)(codeBlock: => Unit):Unit

object Demo
{
  def main(args: Array[String])
  {
    var idx:Int = 0
    myWhileLoop(idx < 5)
    {
      // IMPORTANT: It appears the myWhileLoop() method called above is being called
      //            with only one of its two parameter lists, but that's wrong!
      //            All code between the above and below braces pair {} gets passed
      //            to the second parameter list of the myWhileLoop()() method
      //            defined below.
      print("idx = " + idx + ", ") // PRINTS: idx = 0, idx = 1, idx = 2, idx = 3, idx = 4,
      idx += 1
    }
  }

  // The following myWhileLoop()() method is RECURSIVE!  The Scala code passed to
  // this method in the codeBlock argument keeps executing (which is a recursive
  // call) until the testCondition parameter becomes false.
  def myWhileLoop(testCondition: => Boolean)(codeBlock: => Unit):Unit =
  {
    // NOTE: The following line of code can be written using any of these 3 variations:
    //       1) while(testCondition)(codeBlock)
    //       2) while(testCondition){codeBlock}
    //       3) while(testCondition) codeBlock
    while(testCondition)(codeBlock)
  }
}

========================================================================================
Here is another example of currying.  Read in-line comments below for details.

object Demo
{
  // NOTE: This wrap function is a curried function that takes
  //       3 parameter lists (all 3 are Strings), and returns a String.
  def wrap(prefix:String)(html:String)(suffix:String) =
  {
    prefix + html + suffix
  }

  // NOTE: This wrapWithDiv function RETURNS the above wrap function, where
  //       the wrap function's middle parameter list isn't specified, which
  //       is designated by the the (_) parameter list.  Therefore, this
  //       wrapWithDiv function is defined as a PARTIALLY APPLIED function
  //       call to the wrap function.
  def wrapWithDiv:(String => String) = wrap("<div>")(_)("</div>")

  def main(args: Array[String])
  {
    // NOTE: When main() calls wrapWithDiv by passing it a String, the wrap
    //       function gets called as a FULLY APPLIED function call because it's
    //       now supplied with its previously-unspecified parameter list (_).
    println(wrapWithDiv("My_Text")) // PRINTS: <div>My_Text</div>
  }
}

========================================================================================
The following sample code includes this parametric function:

def funcOfGunc[A,B,C](func:(B=>C), gunc:(A=>B)):(A=>C) = { x=>func(gunc(x)) }

Although funcOfGunc() is defined with ONE parameter list, it must get called
by passing it two (2) parameter lists.  The first parameter list gets passed
the func and gunc functions as two arguments.  The second parameter gets passed
the numeric value of x.

object Demo
{
  def main(args:Array[String]): Unit =
  {
    val plus5Func:(Double=>Double)  = { x:Double => x+5.0D }
    val squareFunc:(Double=>Double) = { x:Double => x*x }

    // NOTE: 54.0 = 5.0+(7.0*7.0)
    var result:Double = funcOfGunc(plus5Func, squareFunc)(7.0D)
    println("1) result = " + result) // PRINTS: 1) result = 54.0

    // NOTE: 144.0 = (5.0+7.0)*(5.0+7.0)
    result = funcOfGunc(squareFunc, plus5Func)(7.0D)
    println("2) result = " + result) // PRINTS: 2) result = 144.0
  }

  // NOTE: Because the A, B, and C data types in the funcOfGunc definition below
  //       are all Int types, it can instead be writen the following way, with
  //       ONLY a single parametric data type A:
  //       def funcOfGunc[A](func:(A=>A), gunc:(A=>A)):(A=>A) = { x=>func(gunc(x)) }
  //
  def funcOfGunc[A,B,C](func:(B=>C), gunc:(A=>B)):(A=>C) = { x =>func(gunc(x)) }
}

========================================================================================

The following code sample shows another example of transforming a regular
function into a curried function by first performing an eta expansion on
it by adding the underscore (_) character, and then calling Scala's .curried()
method.

object Demo
{
  def main(args: Array[String])
  {
    // The add_1() function is a regular/normal function.
    // The first time the add_1() is called here, it's
    // called in the usual way....
    println("add_1(7, 3) = " + add_1(7, 3)) // PRINTS: add_1(7, 3) = 10

    // Perform an "Eta Expansion" on add_1() by using the underscore (_) character...
    val addFunc:((Int, Int) => Int) = add_1 _

    val addFuncCurried:(Int => (Int => Int)) = addFunc.curried // Make the add_1() function a curried function.
    println("addFuncCurried(7)(3) = " + addFuncCurried(7)(3)) // PRINTS: addFuncCurried(7)(3) = 10

    // addFuncCurried called with one param returns a PARTIALLY APPLIED function...
    val partiallyAppliedCurried:(Int => Int) = addFuncCurried(7)
    // Call partiallyAppliedCurried to make addFuncCurried FULLY APPLIED...
    println("partiallyAppliedCurried(3) = " + partiallyAppliedCurried(3)) // PRINTS: partiallyAppliedCurried(3) = 10

    // *****************************************************************************************
    // The add_2()() function called below is a curried function,
    // and can be called in the following two (2) ways...
    //
    // 1) Call sum_2()() once by passing to it both Int params, so it
    //    returns an Int result...
    println("add_2(7)(3) = " + add_2(7)(3)) // PRINTS: add_2(7)(3) = 10

    // 2) Call sum_2()() twice...  sum_2()() is called the first time by
    //    initializing its x Int parameter, and it returns a function.
    //    (At this point, the sum_2()() function is PARTIALLY APPLIED)
    //    Then, sum_2()() is called the second time by initializing
    //    its y Int parameter so it will now return an Int value.
    //    (At this point, the sum_2()() function is FULLY APPLIED.)
    val func:(Int => Int) = add_2(7)(_) // The func function is PARTIALLY APPLIED here.
    println("func(3) = " + func(3)) // PRINTS: func(3) = 10  (func is now FULLY APPLIED.)
  }

  /**
   * This add_1() function is a normal function, NOT a curried function.
   */
  def add_1(x:Int, y:Int):Int = { x + y }

  /**
   * This add_2() function is a CURRIED FUNCTION because
   * it takes multiple arguments, and returns a function
   * that takes a single argument.
   */
  def add_2(x:Int) = { (y:Int) => x + y }
}

========================================================================================

The foldLeft and foldRight functions implemented by the Scala List class are recursive
AND curried functions.  Below is sample code showing the use of the List.foldLeft and
List.foldRight functions.

The first argument list of foldLeft and foldRight represents the STARTING VALUE used on
the first function call of these recursive functions.  The second argument list of
foldLeft and foldRight represents the the function that gets applied.

object Demo
{
  def main(args:Array[String]): Unit =
  {
    // NOTE: foldLeft and foldRight are both RECURSIVE, CURRIED FUNCTIONS.
    //       When foldLeft and foldRight are called below, they get called
    //       with TWO PARAMETER LISTS.

    // ******************************************************************************
    // In this section we show how to use the List.foldLeft and List.foldRight
    // functions on the following intList, implementing the subtraction operation.
    // Notice we demonstrate TWO (2) different ways of implementing the subtraction
    // operation for foldLeft and foldRight that return the same result.
    // The math operation that occurs for foldLeft is:  0−7−4−6−3−9−1 = -30
    val intList:List[Int] = List[Int](7, 4, 6, 3, 9, 1)
    var intResult:Int = intList.foldLeft(0)(_ - _)
    println("foldLeft A = " + intResult) // PRINTS: foldLeft A = -30
    intResult = intList.foldLeft(0)((x, y) => x-y)
    println("foldLeft B = " + intResult) // PRINTS: foldLeft B = -30

    // The math operation that occurs for foldRight is:  0−(1−(9−(3−(6−(4−7))))) = 14
    intResult = intList.foldRight(0)(_ - _)
    println("foldRight A = " + intResult) // PRINTS: foldRight A = 14
    intResult = intList.foldRight(0)((x, y) => x-y)
    println("foldRight B = " + intResult) // PRINTS: foldRight B = 14

    // ******************************************************************************
    // In this section we show how to count the number of characters in the following
    // wordList, using the List.foldLeft and List.foldRight functions.  Notice we
    // demonstrate TWO (2) different ways of obtaining this character count for
    // foldLeft and foldRight that return the same result.
    val wordList:List[String] = List[String]("How", "many", "characters", "are", "in", "this", "wordList?")
    intResult = wordList.foldLeft(0)((count:Int, word:String) => count + word.length)
    println("foldLeft #1 = " + intResult) // PRINTS: foldLeft #1 = 35
    intResult = wordList.foldLeft(0)(_ + _.length)
    println("foldLeft #2 = " + intResult) // PRINTS: foldLeft #2 = 35

    intResult = wordList.foldRight(0)((word:String, count:Int) => count + word.length)
    println("foldRight #1 = " + intResult) // PRINTS: foldRight #1 = 35
    intResult = wordList.foldRight(0)(_.length + _)
    println("foldRight #2 = " + intResult) // PRINTS: foldRight #2 = 35

    // ******************************************************************************
    // In this section we call the foldLeft and FoldRight functions on the
    // following strList.
    val strList:List[String] = List[String]("ABC", "DEF", "GHI", "JKL", "MNO")
    var strResult:String = strList.foldLeft("START")(myFunc)
    println(strResult) // PRINTS: START-ABC-DEF-GHI-JKL-MNO

    strResult = strList.foldRight("BEGIN")(myFunc)
    println(strResult) // PRINTS: ABC-DEF-GHI-JKL-MNO-BEGIN
  }


  /**
   * NOTE: Scala defines List.foldLeft as this:   def foldLeft[B](z: B)(op: (B, A) => B): B
   *       Scala defines List.foldRight as this:  def foldRight[B](z: B)(op: (A, B) => B): B
   *
   * Therefore, this myFunc function satisfies the 2nd parameter list of foldLeft and foldRight,
   * because myFunc gets passed 2 values as a single parameter list, and returns a value.
   */
  def myFunc(str1:String, str2:String):String =
  {
    str1.concat("-").concat(str2)
  }
}

========================================================================================

In the code sample immediately ABOVE, the Scala API functions List.foldRight
and List.foldLight are demonstrated.  In the sample code BELOW, we write our
own functions named myFoldRightFunc and myFoldLeftFunc (both curried, recursive
functions), which emulate Scala's List.foldRight and List.foldLeft functions.

object Demo
{
  def main(args:Array[String]): Unit =
  {
    val floatList:List[Float] = List[Float](7.7F, 4.9F, 6.6F, 3.5F, 9.2F, 1.4F)

    // ********************************************************************************
    // In this section we demonstrate calling the myFoldRightFunc and myFoldLeftFunc
    // functions (defined below) on floatList.
    // The math operation performed by myFoldRightFunc is:  0.0-(1.4−(9.2−(3.5−(6.6−(4.9−7.7))))) = 13.7
    var floatResult:Float = myFoldRightFunc(floatList, 0.0F)(_ - _)
    println("floatResult = " + floatResult) // PRINTS: floatResult = 13.7

    // The math operation performed by myFoldLeftFunc is:  0.0 − 7.7 − 4.9 − 6.6 − 3.5 − 9.2 − 1.4 = -33.3
    floatResult = myFoldLeftFunc(floatList, 0.0F)(_ - _)
    println("floatResult = " + floatResult) // PRINTS: floatResult = -33.3

    // ********************************************************************************
    // In this section we demonstrate calling the myFoldLeftFunc and myFoldRightFunc
    // functions (defined below) on strList.
    val strList:List[String] = List[String]("ABC", "DEF", "GHI", "JKL", "MNO")
    var strResult:String = myFoldLeftFunc(strList, "START")(concat2Strings)
    println(strResult) // PRINTS: START-ABC-DEF-GHI-JKL-MNO

    strResult = myFoldRightFunc(strList, "BEGIN")(concat2Strings)
    println(strResult) // PRINTS: ABC-DEF-GHI-JKL-MNO-BEGIN
  }

  /**
   * THIS IS A CURRIED, RECURSIVE FUNCTION.
   */
  def myFoldLeftFunc[A,B](list:List[A], base:B)(funcOperation:(B,A)=>B):B =
  {
    if (list.isEmpty)
    {
      base // Terminate recursion when list is empty.
    }
    else
    {
      // Concat the result returned by the recursive myFoldLeftFunc call with list.head.
      funcOperation(myFoldLeftFunc(list.tail, base)(funcOperation),   list.head)
    }
  }

  /**
   * THIS IS A CURRIED, RECURSIVE FUNCTION.
   */
  def myFoldRightFunc[A,B](list:List[A], base:B)(funcOperation:(A,B)=>B):B =
  {
    if (list.isEmpty)
    {
      base // Terminate recursion when list is empty.
    }
    else
    {
      // Concat list.head with the result returned by the recursive myFoldRightFunc call.
      funcOperation(list.head,   myFoldRightFunc(list.tail, base)(funcOperation))
    }
  }

  /**
   * NOTE: myFoldRightFunc is defined above as this:
   *       def myFoldRightFunc[A,B](list:List[A], base:B)(func:(A,B)=>B):B
   *
   *       myFoldLeftFunc is defined above as this:
   *       def myFoldLeftFunc[A,B](list:List[A], base:B)(func:(B,A)=>B):B
   *
   * Therefore, this concat2Strings function satisfies the 2nd parameter list of myFoldLeftFunc
   * and myFoldRightFunc because concat2Strings gets passed 2 values as a single parameter list,
   * and returns a value.
   */
  def concat2Strings(str1:String, str2:String):String =
  {
    str1.concat("-").concat(str2)
  }
}

========================================================================================
