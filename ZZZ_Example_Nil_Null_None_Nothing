The following Scala keywords and classes are explained below:

1) null    - Not to be confused with Null.  null is a Scala keyword.
2) Null    - Not to be confused with null.  Null is a Scala class.
3) Nil     - Nil is a Scala Object that represents an empty List.
4) None    - None (and its complement Some) is a Scala class.
             Both None and Some classes extend the Option class.
5) Nothing - 
6) Unit    -
==============================================================
1) null - A Scala keyword.
   The Scala keyword null represents an absent (non-existent) value.
   Scala uses the null keyword so it's compatible with Java code.
   You should refrain from using null in Scala code and instead use
   the Scala Option class, which always returns non-null values of
   type Some or type None.  SAMPLE CODE:
   
   object Demo
   {
     def main(args: Array[String]): Unit =
     {
       class Person(name:String)
       var nullClass:Person  = new Person("Joe Blow")
       nullClass = null
       val nullObject:Object = null
       val nullString:String = null
       // The following line prints:
       // nullClass = null,  nullObject = null,  nullString = null
       println(s"nullClass = $nullClass,  nullObject = $nullObject,  nullString = $nullString")
     }
   }
==============================================================
2) Null - A Scala class.
          The Scala class Null contains no values, no methods,
          can't be extended, and can't be instantiated.  The
          only possible type that a Null class can reference
          is the value null.  The Scala Null class extends
          the Scala AnyRef class.  Therefore, all Scala classes
          that extend AnyRef can be assigned a Null reference,
          which can only have a value of null.  SAMPLE CODE:

          object Demo
          {
            def main(args: Array[String]): Unit =
            {
              val theNullReference:Null = null
              // The following line prints:  theNullReference = null
              println(s"theNullReference = $theNullReference")

              class Person(name:String)
              val noList:List[Int] = theNullReference
              val noPerson:Person  = theNullReference
              val noString:String  = theNullReference
              // The following line prints:
              // noList = null,  noPerson = null,  noString = null
              println(s"noList = $noList,  noPerson = $noPerson,  noString = $noString")
            }
          }
==============================================================
3) Nil - Nil is a Scala Object that represents an empty List.
         Unlike the Scala class Null (which contains no
         values and no methods), the Nil object does contain
         methods so Nil is a proper value.  SAMPLE CODE:

         object Demo
         {
           def main(args: Array[String]): Unit =
           {
             val emptyList_1:List[Int] = List()
             val emptyList_2:List[Int] = Nil
             // The following line prints: emptyList_1 = List(),  emptyList_2 = List()
             println(s"emptyList_1 = $emptyList_1,  emptyList_2 = $emptyList_2")

             if (emptyList_1 == emptyList_2)
               println("emptyList_1 == emptyList_2") // PRINTS: emptyList_1 == emptyList_2

             // The following line prints:
             // emptyList_1.length = 0,  emptyList_2.length = 0
             println(s"emptyList_1.length = ${emptyList_1.length},  emptyList_2.length = ${emptyList_2.length}")
           }
         }
==============================================================
4) None - None is a Scala class.  None has a complement class
          named Some.  Both Some and None classes are subtypes
          of the Scala Option class.  The None class does
          contain fields and values.  Assume you want to obtain
          an Int value from a function.  If that function
          returns a valid Int, it should return it as a Some
          value, which is wrapped inside the Option class.
          If that function can't obtain an Int value, it should
          return a None value (instead of a null), which is
          also wrapped inside the Option class.  Therefore,
          this function will always return a value of type
          Option, whether it returns a valid Int value or not.
          SAMPLE CODE:

          object Demo
          {
            def main(args: Array[String]): Unit =
            {
              val absentInteger:Option[Int]   = None
              val existentInteger:Option[Int] = Some(54321)

              if (absentInteger.isEmpty)
                println("absentInteger is empty.") // PRINTS: absentInteger is empty.

              if (absentInteger == None)
                println("absentInteger == None") // PRINTS: absentInteger == None

              if (existentInteger.nonEmpty)
              {
                println("existentInteger is nonEmpty.") // PRINTS: existentInteger is nonEmpty.
                println(s"existentInteger = ${existentInteger.get}") // PRINTS: existentInteger = 54321
              }

              if (existentInteger == Some(54321))
                println("existentInteger == Some(54321)") // PRINTS: existentInteger == Some(54321)
            }
          }
==============================================================
5) Nothing
==============================================================
6) Unit
