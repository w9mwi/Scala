PASS BY VALUE VS. PASS BY NAME VS. PASS BY REFERENCE EXPLAINED
(FROM PAGES 165-166)

When a function is called via pass-by-value, the function gets a copy of
the variable passed to it, but the function cannot change the variable
that exists in the calling code.

When a function is called via pass-by-reference, the function has
the ability to change the variable in the calling code.  Scala
does NOT have this capability.  Scala allows ONLY pass-by-name
and pass-by-value.

Pass-By-Value - This is the standard (very common) way a parameter
                is passed to a function.  The following code snips
                are examples of pass-by-value:

                val name:String = "Joe Blow"
                val ssn:String = "123-45-6789"

                deleteRecord(name, ssn)
                deleteRecord("Jane Sixpack", "9876-54-3212")

Pass-By-Name - In pass-by-name, an argument/parameter is NOT passed by value,
               but is passed as a THUNK, which is a block of executable
               Scala code that gets executed, and returns a value when that
               argument/parameter is referenced in the function.  See the
               following code for examples, and read the in-line comments
               for detailed explanations.  Pass-By-Name isn't a very accurate
               description.  Better names (which aren't really used) may be:
                  * Call-On-Access
                  * Evaluate-On-Access
                  * Evaluate-On-Use
                  * Evaluate-When-Accessed
                  * Evaluate-When-Referenced

Below are some sample programs which demonstrate Scala's Pass-By-Name
feature.  Read in-line comments for explanations.
=========================================================================

object Demo
{
  def main(args: Array[String]): Unit =
  {
    var result:Int = passByValue(9)
    println("result = " + result) // PRINTS: result = 10

    result = passByName({ result = 101; result })
    println("result = " + result) //PRINTS: result = 200


    var number:Int = 2
    number = multiplyThreeTimes({ number })
    println(number) // PRINTS: 8   (Because 2*2*2 = 8)

    number = multiplyThreeTimes({ number += 1; number })
    println(number) // PRINTS: 990   (Because 9*10*11 = 990)

    number = multiplyThreeTimes({ number += 2; number })
    println(number) // PRINTS: 982103808   (Because 992*994*996 = 982103808)
  }

  def passByValue(x: Int): Int =  { x + 1 }

  /**
   * Notice the argument passed to this function is (x: => Int) and
   * NOT (x() => Int).  Here's the difference between those two:
   *
   * (x() => Int) designates a function named x, that takes no arguments,
   *              and returns an Int value.
   *
   * (x: => Int)  x is a param that contains a block of code (one or more
   *              lines of Scala code) that returns an Int value.  So when
   *              the Scala code contained in the x param executes, its
   *              last line of code evaluates to an Int value.
   *              This is an example of PASS-BY-NAME.
   *
   * @param x - The x param stores a block of Scala code, which gets passed
   *            to this function.  The block of code stored in the x param
   *            MUST return an Int value; because the below code adds a 99
   *            Int to that value, and returns the result.
   *
   * @return - an Int value.
   */
  def passByName(x: => Int): Int = { x + 99 }

  /**
   * This is another "pass by name" function, similar to the passByName() function above.
   *
   * The z param passed to this function stores a block of Scala code that evaluates
   * to (returns) an Int value.  So when this function executes z * z * z, it means
   * the Scala code stored in the z param gets executed 3 times!
   *
   * @param z - The z param stores a block of Scala code, which gets passed
   *            to this function.  The block of code stored in the z param
   *            MUST return an Int value every time it executes, which in
   *            this example is THREE (3) times.
   *
   * @return - An Int value.
   */
  def multiplyThreeTimes(z: => Int): Int = { z * z * z }
}

=========================================================================

object Demo
{
  def main(args: Array[String]): Unit = {
  {
    // Here we call the timer() function (defined below) by first assigning
    // a block of code (that gets passed to timer()) to a val...
    val blockOfCode = { Thread.sleep(444); 123 }
    val (result1, time1) = timer(blockOfCode)
    println("result1 = " + result1 + ",  time1 = " + time1)

    // Here we call the timer() function by directly passing it a block of code...
    val (result2, time2) = timer { Thread.sleep(888); 456 }
    println("result2 = " + result2 + ",  time2 = " + time2)
  }

  def timer[A](blockOfCode: => A) =
    {
      val startTime:Long = System.nanoTime()
      val result:A = blockOfCode
      val stopTime:Long = System.nanoTime()
      val delta = stopTime - startTime
      (result, delta / 1000000D)
    }
  }

}

=========================================================================

The Array.fill and List.fill functions are CURRIED FUNCTIONS that takes two argument lists.
The first argument list is an Int value specifying the number of elements in the Array/List.
The second argument is a PASS-BY-NAME argument specifying the value of each Array/List element.

WARNING: The following code is only an example that shows how the Array/List fill() function
         behaves.  It's unlikely you'd ever want to write code similar to this, cuz it's
         way too convoluted/confusing.

object Demo
{
  def main(args: Array[String]): Unit =
  {
    var arrayInts:Array[Int] = Array.fill(10)(5)
    for (x <- arrayInts) { print(x + " ") } // PRINTS: 5 5 5 5 5 5 5 5 5 5
    println()

    var listInts:List[Int] = List.fill(5)(10)
    for (x <- listInts) { print(x + " ") } // PRINTS: 10 10 10 10 10
    println()

    var listStrings:List[String] = List.fill(5)("TJB")
    for (x <- listStrings) { print(x + " ") } // PRINTS: TJB TJB TJB TJB TJB
    println()

    // Since the second argument list of Array.fill is PASSED BY NAME,
    // it is evaluated for each element, as demonstrated in the
    // following call to Array.fill, which prints this:
    // Evaluating arg.
    // Evaluating arg.
    arrayInts = Array.fill(2){ println("Evaluating arg."); 5 } // NOTE: Adding () around the {} is optional.
    // The following for() loop prints: 5 5
    for (x <- arrayInts) { print(x + " ") }
    println()

    var number:Int = 1
    // Since the second argument list of List.fill is PASSED BY NAME,
    // it is evaluated for each element, as demonstrated in the
    // following call to List.fill, which prints this: 1 2 4
    listInts = List.fill(3){ print(number + " "); number *= 2; number } // NOTE: Adding () around the {} is optional.
    println()
    // The following for() loop prints: 2 4 8
    for (x <- listInts) { print(x + " ") }
  }
}

=========================================================================

The following code sample is just another example of CURRIED FUNCTIONS
implemented by Arrays and Lists.  In other words, the fill() and tabulate()
function shown below are CURRIED FUNCTIONS.  Read the code sample immediately
above for more details about how these CURRIED FUNCTIONS work.

object Demo
{
  def main(args: Array[String])
  {
    var intArray:Array[Int] = Array.fill(10)(4)
    intArray.foreach(println)  // Prints the number 4 a total of 10 times.

    var stringList:List[String] = List.fill(6)("XYZ")
    stringList.foreach(println)  // Prints the string "XYZ" a total of 6 times.

    var idx:Int = 1
    var intList:List[Int] = List.fill(5){(idx*=2); idx} // NOTE: The second argument is in curly braces.
    intList.foreach(println)  // Prints these 5 elements of intList:  2, 4, 8, 16, 32
    intList = 1::intList      // Prepend a 1 onto intList.
    intList.foreach(println)  // Prints these 6 elements of intList:  1, 2, 4, 8, 16, 32
    intList = List.tabulate(10)(i => i*i)
    intList.foreach(println)  // Prints these 10 elements of intList: 0, 1, 4, 9, 16, 25, 36, 49, 64, 81

    // Create a new 6-element Array, where each element in the Array is initialized with
    // the value: (3*x*x + 5x - 7)   Where the value x is the index of the Array.
    // NOTE: All Arrays and Lists begin with an index value of zero (0).
    intArray = Array.tabulate(6)(x => 3*x*x + 5*x - 7) // NOTE: Uses (), equivalent to the line below.
    intArray = Array.tabulate(6){x => 3*x*x + 5*x - 7} // NOTE: Uses {}, equivalent to the line above.
    intArray.foreach(println) // Prints these 6 elements of intArray: -7, 1, 15, 35, 61, 93

    // NOTE: The last value printed below will ALWAYS be ONE LESS than the maximum value in
    //       the range.  So in this instance, the last value printed is eleven (11)...
    intArray = Array.range(0, 12)
    intArray.foreach(print) // PRINTS: 01234567891011
    println
    intList  = List.range(0, 12)
    intList.foreach(print)  // PRINTS: 01234567891011
  }
}
