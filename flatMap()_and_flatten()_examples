===========================================================================
object Demo
{
  def main(args:Array[String]): Unit =
  {
    // NOTE: The signature of the List.map method is:  map[B](f: (A) => B): List[B]
    var stringList:List[String] = List("Hey", "Neptune")
    val intList1:List[Int] = stringList.map(s => s.length) // Equivalent to the next line of code.
    val intList2:List[Int] = stringList.map(_.length)      // Equivalent to the previous line of code.
    println("A) " + intList1) // PRINTS: A) List(3, 7)
    println("B) " + intList2) // PRINTS: B) List(3, 7)

    // NOTE: The signature of the List.flatMap method is: def flatMap[B](f: (A) => GenTraversableOnce[B]): List[B]
    //       For this example we can simplify that to:    def flatMap[B](f: (A) => List[B]): List[B]
    stringList = List("mucked", "up", "all", "over")
    var stringList1 = stringList.flatMap(s => s.split("ck")) // Equivalent to the next line of code.
    var stringList2 = stringList.flatMap(_.split("ck"))      // Equivalent to the previous line of code.
    var stringList3 = stringList.flatMap(_.split(""))
    println("C) " + stringList1) // PRINTS: C) List(mu, ed, up, all, over)
    println("D) " + stringList2) // PRINTS: D) List(mu, ed, up, all, over)
    println("E) " + stringList3) // PRINTS: E) List(m, u, c, k, e, d, u, p, a, l, l, o, v, e, r)

    stringList1 = List("one", "two", "three")
    stringList2 = List("four", "five", "six", "seven")
    val stringList4:List[List[String]] = List(stringList1, stringList2)

    println("F) " + stringList4)                 // PRINTS: F) List(List(one, two, three), List(four, five, six, seven))
    println("G) " + stringList4.flatten)         // PRINTS: G) List(one, two, three, four, five, six, seven)
    println("H) " + stringList4.flatMap(z => z)) // PRINTS: H) List(one, two, three, four, five, six, seven)
    println("I) " + stringList4.map(s => s.length))         // PRINTS: I) List(3, 4)
    println("J) " + stringList4.flatten.map(s => s.length)) // PRINTS: J) List(3, 3, 5, 4, 4, 3, 5)
  }
}

===========================================================================
The following code sample shows how to use the flatten() method.

import scala.collection.immutable.NumericRange
import scala.collection.immutable

object Demo
{
  def main(args: Array[String]):Unit =
  {
    println("PART 1) ================================")
    // NOTE: This part just calls isPrime(), and has nothing to do with flatten() or flatMap().
    val number = 54321L
    println("isPrime(" + number + ") = " + isPrime(number))

    println("PART 2) ================================")
    val list_1:List[Int]   = List(9, 8, 7, 6, 5)
    val list_2:List[Int]   = List(10, 11, 12)
    val list_3:List[Int]   = List(13, 14, 15, 16)
    val array_1:Array[List[Int]] = Array(list_1, list_2, list_3)
    for (list <- array_1) // Loops through each element of array_1
    {
      // Prints all Int numbers in list_1, then in list_2, then in list_3.
      list.foreach(println) // PRINTS: 9 8 7 6 5 10 11 12 13 14 15 16
    }

    // PART 3) below prints the IDENTICAL results as PART 2) above...
    println("PART 3) ================================")
    val result_1:Array[Int] = array_1.flatten // result_1 = Array(9, 8, 7, 6, 5, 10, 11, 12, 13, 14, 15, 16)
    result_1.foreach(println) // PRINTS: 9 8 7 6 5 10 11 12 13 14 15 16

    // PART 4) below prints the IDENTICAL results as PART 3) above...
    println("PART 4) ================================")
    val array_2:Array[Int] = Array(22, 33, 44)
    val array_3:Array[Int] = Array(55, 66, 77)
    val array_4:Array[Int] = Array(88, 99)
    val list_4:List[Array[Int]] = List(array_2, array_3, array_4)
    for (array <- list_4) // Loops through each element of list_4
    {
      // Prints all Int numbers in array_2, then in array_3, then in array_4
      array.foreach(println) // PRINTS: 9 8 7 6 5 10 11 12 13 14 15 16
    }

    println("PART 5) ================================")
    val result_2:List[Int] = list_4.flatten // result_2 = List(22, 33, 44, 55, 66, 77, 88, 99)
    result_2.foreach(println) // PRINTS: 22 33 44 55 66 77 88 99

    println("PART 6) ================================")
    val list_5:List[List[Int]] = List(list_1, list_2, list_3)
    val result_3 = list_5.flatten.map(x=>x*x)
    result_3.foreach(println) // PRINTS: 81 64 49 36 25 100 121 144 169 196 225 256

    // The following 2 lines of code are used for nothing at this time.
    val immutSet:immutable.Set[Int] = immutable.Set(9, 8, 7, 6, 5)
    val immutSet_2:immutable.Set[Int] = immutable.Set(1, 8, 7, 6, 5)
  }

  /**
    * Determine if a Long value is or isn't prime.
    * @param number
    * @return
    */
  def isPrime(number:Long):Boolean =
  {
    // NOTE: NumericRange is a more generic version of the Range class,
    //       as it's a parametric function that can work with different
    //       data types (Int., Long, BigInt).
    var numericRange = NumericRange(2L, number, 1L)

    // Test ALL elements of numericRange.  If ALL elements of numericRange
    // cannot be divided by 2, true is returned.  Otherwise, false is returned.
    numericRange.forall(number % _ != 0)
  }
}
===================================================================================
The following code sample shows use of the flatten(), flatMap() and map() methods.
Calling flatMap() is just like calls the flatten() method AND the map() method
in one shot.  However, the name flatMap() is a bit misleading because flatMap()
calls the map() method FIRST, and then calls the flatten() method SECOND.

NOTE: When flatten() and flatMap() is called on a Seq, they return a Seq.
      When flatten() and flatMap() is called on a List, they return a List.
      When flatten() and flatMap() is called on an Array, they return a List!!!

object Demo
{
  def main(args: Array[String]):Unit =
  {
    println("PART 1) uses a Seq data type. ==================================")
    val fruitsSeq:Seq[String] = Seq("apple", "banana", "orange")
    val result_1:Seq[String]  = fruitsSeq.map(_.toUpperCase)
    val result_2:Seq[Char]    = fruitsSeq.flatten
    val result_3:Seq[Char]    = fruitsSeq.flatMap(_.toUpperCase)
    println(result_1) // PRINTS: List(APPLE, BANANA, ORANGE)
    println(result_2) // PRINTS: List(a, p, p, l, e, b, a, n, a, n, a, o, r, a, n, g, e)
    println(result_3) // PRINTS: List(A, P, P, L, E, B, A, N, A, N, A, O, R, A, N, G, E)

    println("PART 2) uses a List data type. ==================================")
    val fruitsList:List[String] = List("apple", "banana", "orange")
    val result_4:List[String]   = fruitsList.map(_.toUpperCase)
    val result_5:List[Char]     = fruitsList.flatten
    val result_6:List[Char]     = fruitsList.flatMap(_.toUpperCase)
    println(result_4) // PRINTS: List(APPLE, BANANA, ORANGE)
    println(result_5) // PRINTS: List(a, p, p, l, e, b, a, n, a, n, a, o, r, a, n, g, e)
    println(result_6) // PRINTS: List(A, P, P, L, E, B, A, N, A, N, A, O, R, A, N, G, E)

    println("PART 3) uses an Array data type. ==================================")
    val fruitsArray:Array[String] = Array("apple", "banana", "orange")
    val result_7:List[Char]       = fruitsList.flatten                // NOTICE: The type returned is List[Char]
    val result_8:List[String]     = fruitsList.map(_.toUpperCase)     // NOTICE: The type returned is List[String]
    val result_9:List[Char]       = fruitsList.flatMap(_.toUpperCase) // NOTICE: The type returned is List[Char]
    result_7.foreach(println) // PRINTS: a  p  p  l  e  b  a  n  a  n  a  o  r  a  n  g  e
    println(result_8)         // PRINTS: List(APPLE, BANANA, ORANGE)
    result_9.foreach(println) // PRINTS: A  P  P  L  E  B  A  N  A  N  A  O  R  A  N  G  E

    println("PART 4) ==================================")
    // NOTE: Sometimes you might think you can call flatMap() when you cannot.
    //       Recall that flatMap() calls map() FIRST, and calls flatten() SECOND.
    //       Calling doubleList_1.flatMap() below won't work because what must be
    //       done is to call flatten() FIRST, and map() SECOND, as is done below.
    val doubleList_1:List[Double]       = List(39.1, 97.3, 224.7, 359.9)
    val doubleList_2:List[Double]       = List(21.7, 77.7, 194.7, 285.2)
    val doubleList_3:List[List[Double]] = List(doubleList_1, doubleList_2)
    val result_10:List[Double]          = doubleList_3.flatten
    val result_11:List[Double]          = result_10.map(math.cos(_))
    println(result_11) // PRINTS the cosine of each number in doubleList_1 and doubleList_2.
  }
}
================================================================================
The following code shows how to use the flatten(), map() and flatMap() methods,
as well as the Some and None objects, which are both children of the Option
object.  Again, notice that the name flatMap() is a bit misleading because
flatMap() calls the map() method FIRST, and then calls the flatten() method.

NOTE: In this example, you cannot call list.flatten() because list is already
      in its 'flattened' state.  But when you call list.map(), the returned
      result is of type List[List[Int]], which means you call the flatten()
      method on the returned result.

object Demo
{
  def main(args: Array[String]):Unit =
  {
    val list:List[Int] = List(1,2,3,4,5)
    // NOTE: If you attempt to call list.flatten() here, an exception will
    //       be thrown because list is already in its 'flattened' state.

    println("PART 1 calls list.map() ==============================")
    // Calling list.map(x => func(x)) will call func() once for each Int
    // contained in list.  Each time func() gets called, it will return
    // a List containing 3 Int values.
    val result_1:List[List[Int]] = list.map(x => func(x)) // Equivalent to calling list.map(func)
    println(result_1) // PRINTS: List(List(0, 1, 2), List(1, 2, 3), List(2, 3, 4), List(3, 4, 5), List(4, 5, 6))

    println("\nPART 2 calls result_1.flatten() ==============================")
    val result_2:List[Int] = result_1.flatten
    println(result_2)         // PRINTS: List(0, 1, 2, 1, 2, 3, 2, 3, 4, 3, 4, 5, 4, 5, 6)
    result_2.foreach(println) // PRINTS: 0, 1, 2, 1, 2, 3, 2, 3, 4, 3, 4, 5, 4, 5, 6

    println("\nPART 3 calls list.map(func).flatten() ==============================")
    val result_3 = list.map(func).flatten // Equivalent to caling: list.map(x => func(x)).flatten
    result_3.foreach(println) // PRINTS: 0, 1, 2, 1, 2, 3, 2, 3, 4, 3, 4, 5, 4, 5, 6

    // In PART 4 below, we just call list.flatMap(), which generates the
    // same result as PART1 + PART 2 above, and the same result returned
    // in PART 3 above.
    println("\nPART 4 calls list.flatMap() ==============================")
    val result_4 = list.flatMap(func) // Equivalent to calling list.flatMap(x => func(x))
    result_4.foreach(println) // PRINTS: 0, 1, 2, 1, 2, 3, 2, 3, 4, 3, 4, 5, 4, 5, 6
  }

  /**
    * This function is self-explanatory.
    */
  def func(intNumber:Int):List[Int] = List(intNumber - 1, intNumber, intNumber + 1)
}

===========================================================================
