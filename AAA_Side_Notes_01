Page 156-157
Every object in Scala is an instance the Any object, which is the top object
in the object tree.  So every other object in Scala is a child of the Any object.
At the bottom of the object tree is the Nothing object, which is a subtype
(a child) of ALL Scala objects.  The Nothing object exists to handle situations
where functions never return.

Page 230
Scala provides 3 constructs for creating user-defined types:
1) classes
2) traits - SEE P. 463
3) objects - Singleton objects, meaning "static" (only one instance) objects.

==================================================================

Every object in Scala is an instance of the "Any" object, because the
"Any" object is the parent of ALL other objects.  The Any object is
the direct parent of these two objects: AnyVal and AnyRef

The "Nothing" object (which has no value) is a subtype of ALL Scala
objects, and it exists to handle situations when functions don't
return a value.
==================================================================
OBJECT-ORIENTED PROGRAMMING (PAGE 394)

An object contains both data and functonality that operates on that
data.  A class is a blueprint for an object.

A case class can contain curly braces, as do regular classes.  But
it's possible for a case class to NOT contain curly braces.

When you specify "def" to write a "function" within a class, it's
considered a method which can access vals/vars (and alter vars)
declared within the method.

In the following sample code, the name and id parameters passed to
the Student class upon instantiation are NOT ACCESSIBLE outside the
Student class because arguments passed to a class are NOT turned
into class members, and thus cannot be accessed outside
the class.  The params passed to the Student class above ARE accesible
outside the class if one (or both) of the following are done:

1) If you make the "class" a "case class" the params passed to the
   "case class" will be accessible outside the "case class".
2) If you make a class's params "var" types (they are "val"
   types by default) the params passed to the "case class" will
   be accessible outside the "case class".

Read the comments in the code sample below to understand this.
==================================================================
object Demo
{
  class Student(name:String, id:String)
  {
    var tests       = List[Double]()
    var quizzes     = List[Double]()
    var assignments = List[Double]()

    def testAverage       = tests.sum / tests.size
    def quizAverage       = quizzes.sum / quizzes.size
    def assignmentAverage = assignments.sum / assignments.size

    // Unlike the 2 println() methods called at the bottom of main(),
    // the following 2 println() methods won't cause a runtime exception
    // because the name and id params are accessible here--within
    // the Student class definition.
    println(name);  println(id)
  }

  def main(args: Array[String]):Unit =
  {
    val john = new Student("John Doe", "0123456")
    john.tests ::= 78
    john.tests ::= 85
    println(john.testAverage)

    // BOTH of the following 2 println() statements will cause a runtime
    // error because the values passed to the Student class, upon its
    // instantiation, are NOT accessible UNLESS the class is modified
    // by doing one (or both) of the following:
    // 1) Change the above class definition to this:
    //    case class Student(name:String, id:String) // The case keyword is added.
    // 2) Change the above class definition to this:
    //    class Student(val name:String, val id:String) // The val (or var) keyword is added.
    println(john.name);  println(john.id);
  }
}
==================================================================
There are three (3) main levels of visibility in Scala, they are:

1) Public - NOTE: There does NOT exist a Public/public keyword in Scala.
                  If you want something public, it's public BY DEFAULT, which
                  means you wouldn't use the private or protected keyword.
                  If the visibility level is public, a class's val/var or
                  method is accessible by code inside, or outside, the class.
2) private - A "private" declaration means a class's member val/var/method
             can be accessed only inside the class.  If you prefix a declaration
             inside a class with the private keyword, that member will be private.
3) protected - A protected declaration is much like private, except protected class
               members are also accessible in subtypes (children) of the class.
==================================================================
The binding of data and functions/methods together is called ENCAPSULATION.
One of the goals  to strive for in object-oriented programs is to have
SEPARATION OF INTERFACE AND IMPLEMENTATION.  The interface refers to how
you interact with the object--meaning its public members and methods.  The
implementation refers to the behavior of the methods.  You want interface
and implementation to be independent of each other.

An operator in Scala is right-associative if it ends with a colon (:)
so the :: operator (which works on Lists) is right-associative.  For
example, the following 3 lines of code are all equivalent:

3 :: 4 :: list
3 :: (4 :: list)
list.::(4).::(3)
=========================================================================
PASS BY VALUE VS. PASS BY NAME VS. PASS BY REFERENCE EXPLAINED
(FROM PAGES 165-166)

NOTE: 'Pass by name' is somewhat similar to 'pass by value',
      and is described below.

When a function is called via pass-by-value, the function gets a copy of
the variable passed to it, but the function cannot change the variable
that exists in the calling code.

When a function is called via pass-by-reference, the function has the
ability to change the variable in the calling code.

Even though all vars in Scala are references, Scala ALLOWS ONLY PASS-BY-VALUE
AND PASS-BY-NAME (NOT pass by reference).

Although pass-by-reference is NOT allowed in Scala, Scala does allow
pass-by-name, which few other languages allow.  In pass-by-name,
an argument isn't passed by value, but is passed as a THUNK, which is
basically some code that will be executed and given a value when the argument
is used in a function.  You can envision pass-by-name as automatically
creating a function that takes no arguments, and returns a value that will
be executed each time the argument is used.  To show this, see the following
code example.

In the below code, notice the syntax for calling a function by name is to
place the rocket symbol (=>) before the argument's type, like this:
(x: => Int)
If we were to place empty parentheses in front of the rocket, we would have
a function that takes no arguments, and returns an Int, like this:
(x() => Int)

When the following passByNameAndIncrement() and passByValueAndIncrement()
functions are called by passing a single Int value to them, they both
appear to behave same way, as they both return the same Int result.  However,
when we call those two functions by passing them a println statement followed
by an Int value, we see that the order that println("About to increment.")
and println("Evaluation.") statements get executed are different.

This means that when you pass an argument by value, the argument is evaluated
BEFORE the function executes.  When you pass an argument by name, the argument
is evaluated WHEN the parameter is used.

object Demo
{
  def main(args:Array[String]): Unit =
  {
    // ************************************************************************
    // EXECUTING THE CODE BELOW WILL PRINT THE FOLLOWING TO THE CONSOLE...
    // println() statement in blockOfCodeReturnsInt is executed.
    // passByName() called.
    // 1) passByName(9) = 10
    //
    // passByValue() called.
    // 2) passByValue(9) = 10
    // =================================
    // passByName() called.
    // println() statement is executed.
    // 3) passByName({ println("println() statement is executed."); 9; }) = 10
    //
    // println() statement is executed.
    // passByValue() called.
    // 4) passByValue({ println("println() statement is executed."); 9; }) = 10
    // ************************************************************************
    // The following line of code executes the embedded println() statement!...
    val blockOfCodeReturnsInt:Int = { println("println() statement in blockOfCodeReturnsInt is executed."); 9; }

    println("1) passByName(9) = " + passByName(9) + "\n")
    println("2) passByValue(9) = " + passByValue(9))
    println("=================================")
    println("3) passByName({ println(\"println() statement is executed.\"); 9; }) = "
            + passByName({ println("println() statement is executed."); 9; } )+ "\n")
    println("4) passByValue({ println(\"println() statement is executed.\"); 9; }) = "
            + passByValue({ println("println() statement is executed."); 9; }))
  }

  def passByValue(x:Int):Int =
  {
    println("passByValue() called.")
    x + 1
  }

  /**
    * Notice the argument passed to this function is (x: => Int), and
    * NOT (x() => Int).  Here's the difference between those two:
    *
    * (x: => Int)  designates a block of code (one or more lines of Scala code) that
    *              takes no arguments, and returns an Int value.  x represents the
    *              value returned by the block of code, which is an Int value in
    *              this example.
    *
    * (x() => Int) designates a function named x, that takes no arguments,
    *              and returns an Int value.
    *
    * @param x
    * @return
    */
  def passByName(x: => Int):Int =
  {
    println("passByName() called.")
    x + 1
  }
}

==================================================================
