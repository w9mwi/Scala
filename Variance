
Variance in Scala defines Inheritance relationships of Parameterized Types.
Variance is all about Sub-Typing, aka Inheritance.

List[T] - List[T] in known as a Generic.  T is known as a "Type Parameter."

Parameterized Types - List[T] means List can be used with many types, such as List[Int],
                      List[Float], List[String], List[Boolean], List[Any], etc.
                      So List[T] is a Parameterized Type.
          
Variance - Defines Inheritance relationship between Parameterized Types, such as
           the relationship between List[S] and List[T].

Scala supports the following THREE (3) kinds of Variance, all of which are discussed in detail below.
1) Covariant Variance     - EXAMPLE:  If type S is a subtype of type T, then List[S] is is a subtype of List[T].
2) Contravariant Variance - EXAMPLE:  If type S is a subtype of type T, then List[T] is is a subtype of List[S].
3) Invariant Variance     - EXAMPLE:  

Covariant Variance
==================
Covariant Variance is a kind of INHERITANCE RELATIONSHIP BETWEEN TWO (2) PARAMETERIZED TYPES.
For example, if type S is a subtype of type T, then List[S] is is a subtype of List[T].
EXAMPLE: Int is a subtype of Any, so List[Int] is a subtype of List[Any].
This kind of Inheritance Relationship between two Parameterized Types is known as Covariant.

To represent a Covariance relationship between two Parameterized Types, Scala prefixes a
Type Parameter with the '+' character.  This '+' character is known as Variance Annotation,
or in this example, Covariance Annotation.
FOR EXAMPLE:  List[+T]
If you look at the Scala API for List, you'll see List is defined using
the '+' (Covariance Annotation) character, like this:
sealed abstract class List[+A] extends ...
SEE --> https://www.scala-lang.org/api/current/scala/collection/immutable/List.html

In the code example shown further below we have these 4 lines...
class Animal[+T](val animal:T)
class Dog
class Puppy extends Dog
class AnimalCarer(val dog:Animal[Dog])

Notice that AnimalCarer() above is defined to be instantiated with an Animal[Dog] class.
If Animal[+T] above is changed to Animal[T], then AnimalCarer() would REQUIRE that it be
instantiated ONLY with an Animal[Dog] class.  But when we use Animal[+T], AnimalCarer()
can be instantiated with an Animal[Dog] class, OR ANY ANIMAL TYPE THAT IS A SUBTYPE OF
DOG, such as Animal[Puppy].  THIS IS COVARIANCE!!!

In other words, any code that required an Animal[Dog] type WITHOUT Covariance Annotation
(Animal[T]) will work WITH Covariance Annotation (Animal[+T]), as long as the
parameterized type IS A SUBTYPE of Dog.

This is exactly what we said above when we defined covariance:
"If type S is a subtype of type T, then List[S] is is a subtype of List[T]."
Let's restate that same sentence but: replace List with Animal.
                                      replace S with Puppy.
                                      replace T with Dog.
"If type Puppy is a subtype of type Dog, then Animal[Puppy] is a subtype of Animal[Dog]."
So when covariance annotation is used (Animal[+T]), Animal[Puppy] will work anywhere
Animal[Dog] would work without covariance annotation (without the '+' character).

NOTICE: A Scala function/method can use parameterized types as the following function
does, which just returns whatever gets passed to it--regardless of type passed to it.

def myFunction[T](t:T) = { t }

Variance Annotation NOT apply to functions/methods that implement parameterized types!
Variance Annotation applies ONLY to classes/types, NOT to functions/methods!  Therefore,
any function/method would NEVER be defined using the '+' or '-' character, which denote
Variance Annotation.

==============================================================================================

object Demo
{
  // If you remove the Variance Annotation (the '+' character) from
  // the following line of code, this line of code won't compile...
  // val puppyCarer = new AnimalCarer(puppyAnimal)
  // ...because AnimalCarer is passed a Puppy class when it requires
  // a Dog class.  The '+' character in Animal[+T] resolves this problem.
  class Animal[+T](val animal:T) { println("Animal = " + animal)}
  class Dog
  class Puppy extends Dog
  class AnimalCarer(val dog:Animal[Dog])

  def main(args:Array[String]):Unit =
  {
    val dog:Dog     = new Dog()
    val puppy:Puppy = new Puppy()
    val dogAnimal:Animal[Dog]     = new Animal[Dog](dog)
    val puppyAnimal:Animal[Puppy] = new Animal[Puppy](puppy)

    val dogCarer   = new AnimalCarer(dogAnimal)
    // The following line will NOT compile if you change
    // Animal[+T] above to Animal[T].
    val puppyCarer = new AnimalCarer(puppyAnimal)

    println("The End.")
  }
}

==============================================================================================

Contravariant Variance
======================
RECALL: List[T] in known as a Generic.  T is known as a "Type Parameter."
Recall that Covariant is defined as this:  If type S is a subtype of type T,
                                           then List[S] is is a subtype of List[T].
Contravariant Variance is defined as this: If type S is a subtype of type T,
                                           then List[T] is a subtype of List[S].

Covariance Annotation is designated with a '+' character, like this: List[+T]
Contravariance Annotation is designated with a '-' character, like this: List[-T]

--> https://www.journaldev.com/9585/scala-variances-covariant-invariant-contravariant

object Demo
{
  // If you remove the Variance Annotation (the '-' character) from
  // the following abstract class, this line of code won't compile...
  // baseType.display(superType).  Read in-line comment below for details.
  abstract class Type[-T] { def printTypeName:Unit }

  class SuperType extends Type[Any]
  {
    override def printTypeName:Unit = { println("SuperType") }
  }
  class SubType extends Type[Int]
  {
    override def printTypeName:Unit = { println("SubType") }
  }
  class BaseType
  {
    def display(t:Type[Int]) { t.printTypeName }
  }

  def main(args:Array[String]):Unit =
  {
    val superType:SuperType = new SuperType()
    val subType:SubType     = new SubType()
    val baseType:BaseType   = new BaseType()
    baseType.display(subType)   // PRINTS: SubType

    // The following line of code will NOT compile if you remove the
    // Contravariance Annotation (the '-' character) from abstract class
    // "Type" defined above.  Recall, Contavariance is defined as this:
    // If type S is a subtype of type T, then List[T] is a subtype of List[S].
    // For this code sample, Contavariance is defined as follows:
    // Type Int is a subtype of Any, so Type[Any] is a subtype of Type[Int].
    // ...OR...
    // Type Int is a subtype of Any, so SuperType is a subtype of SubType.
    // THAT'S CONTRAVARIANCE!!!  Therefore, the following line of code
    // requires Contavariance Annotation (the '-' character) above.
    baseType.display(superType) // PRINTS: SuperType

    println("The End.")
  }
}

Invariant Variance
==================
