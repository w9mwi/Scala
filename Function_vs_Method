The words "method" and "function" are often used interchangeably, as if
if a method and a function are the same.  However, in Scala there are
important differences between a method and a function that the programmer
should know about.  This section explains methods, functions, and how
the differ.  The following related concepts are also explained in this
section:

* Anonymous Function
* Eta Exapansion

METHOD - A Scala method is ALWAYS defined using the "def" keyword.
         So whenever the "def" keyword appears, a method is defined.

         A Scala method is always bound to a class/object/trait.
         In other words, a method IS A MEMBER of a class/object/trait.
         So if we create a class/object/trait named Person, and Person
         defines a method named printPerson(), then that method can be
         invoked by this code:

         Person.printPerson()

         In the following line of code, "number" appears like it could
         be a val/var.  But the keywords "val" and "var" aren't used,
         so "number" isn't a val/var.  Because the keyword "def" is used,
         "number" has to be a method.  In this example, the method number
         accepts no arguments, and always returns the Int value 123.
         (In real code, you'd never do this.  Instead, you'd make number
         a val because it's only purpose is to return a constant value.)

         // number is a method that takes no args, and always returns Int 123.
         def number:Int = 123

         Another example of a Scala method definition:

         def squareMethod(number: Float): Float = number * number  // Method definition.
         println(s"squareMethod(123.456F) = ${squareMethod(123.456F)}")  // Call the method.
         // PRINTS: squareMethod(123.456F) = 15241.384

FUNCTION - A Scala function is NEVER defined using the "def" keyword.
           Examples of how to define a function are shown further below.

           Unlike a method, a function is NOT bound to a class/object/trait.
           So you CAN'T reference a function via a class/object/trait, as you
           can with a method...
           
           Person.printPerson() // CAN'T invoke a FUNCTION with code like this!
                                // (That works only with a METHOD.)

           Every Scala function has a data type associated with it.  The
           data type of a function ALWAYS contains the rocket symbol (=>).
           The rocket symbol (=>) separates the data type of the argument
           gets passed to the function (on its leftside), and the data
           type returned by the function (on its rightside).  Here's an
           example of what a function's data type looks like:

           Int=>String   - Data type of a function that accepts an
                           Int argument, and returns a String value.

           NOTE: A parameterized (generic) argument is an argument that can
                 accept different data types (i.e., Int, and Float, and Double)
                 instead of a single data type, like only a Float.

           Unlike a method, a function CAN'T accept parameterized (generic) arguments.

           There are the three ways to define a Scala function:

           1) Define a function that gets assigned to a val/var.  The function
              is always called by referencing the val/var, as demonstrated here.
              ===========================================================
              object Demo
              {
                def main(args:Array[String]): Unit =
                {
                  // Define the function and assign it to val squareFunction.
                  val squareFunction: (Float => Float) = { (number: Float) => number * number }
                  println(s"squareFunction(123.456F) = ${squareFunction(123.456F)}") // Call the function.
                  // PRINTS: squareFunction(123.456F) = 15241.384
                }
              }
              ===========================================================

           2) Generate a Scala function from a Scala method by performing an
              ETA EXPANSION on the method, and assigning it to a val/var.
              NOTE: An ETA EXPANSION is an operation that transforms a
                    Scala method into a Scala function.
              ===========================================================
              object Demo
              {
                def main(args:Array[String]): Unit =
                {
                  // Define a Scala method.
                  def squareMethod(number: Float): Float = number * number

                  // Transform squareMethod() into a function via an ETA EXPANSION,
                  // using any of the following 3 lines--they are all equivalent.
                  val squareFunction_1: (Float => Float) = squareMethod
                  val squareFunction_2: (Float => Float) = squareMethod _
                  val squareFunction_3: (Float => Float) = squareMethod(_)
                  println(s"squareFunction_1(123.456F) = ${squareFunction_1(123.456F)}") // Call the function.
                  // PRINTS: squareFunction_1(123.456F) = 15241.384
                }
              }
              ===========================================================

           3) The Scala API contains hundreds of methods that accept a function
              as an argument.  For example, List.map() requires a function to
              be passed as its argument.  When a method/function accepts a function
              as an argument, you can pass it an ANONYMOUS FUNCTION, as the
              following example demonstrates.

              An ANONYMOUS FUNCTION is written with the rocket symbol (=>).
              The token(s) on the leftside of "=>" represents the argument(s)
              passed to the function.  The expression on the rightside of
              "=>" is the algorithm that calculates the function's return
              value.  That algorithm must always reference the argument(s)
              passed to the anonymous function.  The following code sample
              demonstrates some examples of how to use anonymous functions.
              ===========================================================
              object Demo
              {
                def main(args: Array[String])
                {
                  var floatList:List[Float] = List(1.0F, 2.0F, 3.0F, 4.0F, 5.0F)
                  floatList = floatList.map(x => x * x) // Pass List.map() this anonymous function: x => x * x
                  println(s"floatList = $floatList") // PRINTS: floatList = List(1.0, 4.0, 9.0, 16.0, 25.0)

                  // The following line defines an anonymous function, and assigns it to the var result.
                  var result:(Int, Int) => Int = (a:Int, b:Int) => a+b
                  // The following line calls the function assigned to the var result.
                  println(result(222, 444)) // PRINTS: 666

                  // The following line defines an anonymous function, and assigns it to the var result.
                  // This anonymous function is IDENTICAL to the one above, but its syntax is different.
                  result = (_:Int)+(_:Int)
                  println(result(444, 222)) // PRINTS: 666
                }
              }
              ===========================================================
              
              Although List.map() specifies that it takes a function as its
              argument, it will accept a method.  The following code sample
              demonstrates how to perform an ETA EXPANSION on a method.  An
              ETA EXPANSION transforms a Scala method into a Scala function.
              
              object Demo
              {
                def main(args:Array[String]): Unit =
                {
                  // The Scala API contains hundreds of functions that take a function
                  // as an argument.  In many of these instances you can pass a method
                  // instead of a function, and Scala automatically will automatically
                  // transform the method into a function (via an ETA EXPANSION), so
                  // it will compile.  This example shows that the List.map() method
                  // works by passing to it a method, as Scala will transform it
                  // into a function.
                  def squareMethod(number: Float): Float = number * number
                  var floatList:List[Float] = List(1.0F, 2.0F, 3.0F, 4.0F, 5.0F)
                  floatList = floatList.map(squareMethod) // Pass List.map() a method.
                  println(s"floatList = $floatList") // PRINTS: floatList = List(1.0, 4.0, 9.0, 16.0, 25.0)

                  // =====================================================
                  // EXAMPLE 2)
                      floatList = floatList.map(x => x * x) // Pass List.map() an anonymous function.
                      println(s"floatList = $floatList") // PRINTS: List(1.0, 16.0, 81.0, 256.0, 625.0)
                }
              }
              ===========================================================

========================================================================================

The following code sample shows another example of transforming
a regular function into a curried function by first performing
an ETA EXPANSION on it by adding the underscore (_) character,
and then calling Scala's .curried() method.

object Demo
{
  def main(args: Array[String])
  {
    // The add_1() function is a regular/normal function.
    // The first time the add_1() is called here, it's
    // called in the usual way....
    println("add_1(7, 3) = " + add_1(7, 3)) // PRINTS: add_1(7, 3) = 10

    // Perform an "Eta Expansion" on add_1() by using the underscore (_) character...
    val addFunc:((Int, Int) => Int) = add_1 _

    val addFuncCurried:(Int => (Int => Int)) = addFunc.curried // Make the add_1() function a curried function.
    println("addFuncCurried(7)(3) = " + addFuncCurried(7)(3)) // PRINTS: addFuncCurried(7)(3) = 10

    // addFuncCurried called with one param returns a PARTIALLY APPLIED function...
    val partiallyAppliedCurried:(Int => Int) = addFuncCurried(7)
    // Call partiallyAppliedCurried to make addFuncCurried FULLY APPLIED...
    println("partiallyAppliedCurried(3) = " + partiallyAppliedCurried(3)) // PRINTS: partiallyAppliedCurried(3) = 10

    // *****************************************************************************************
    // The add_2()() function called below is a curried function,
    // and can be called in the following two (2) ways...
    //
    // 1) Call sum_2()() once by passing to it both Int params, so it
    //    returns an Int result...
    println("add_2(7)(3) = " + add_2(7)(3)) // PRINTS: add_2(7)(3) = 10

    // 2) Call sum_2()() twice...  sum_2()() is called the first time by
    //    initializing its x Int parameter, and it returns a function.
    //    (At this point, the sum_2()() function is PARTIALLY APPLIED)
    //    Then, sum_2()() is called the second time by initializing
    //    its y Int parameter so it will now return an Int value.
    //    (At this point, the sum_2()() function is FULLY APPLIED.)
    val func:(Int => Int) = add_2(7)(_) // The func function is PARTIALLY APPLIED here.
    println("func(3) = " + func(3)) // PRINTS: func(3) = 10  (func is now FULLY APPLIED.)
  }

  /**
   * This add_1() function is a normal function, NOT a curried function.
   */
  def add_1(x:Int, y:Int):Int = { x + y }

  /**
   * This add_2() function is a CURRIED FUNCTION because
   * it takes multiple arguments, and returns a function
   * that takes a single argument.
   */
  def add_2(x:Int) = { (y:Int) => x + y }
}

========================================================================================
ANONYMOUS FUNCTION - Read in-line comments in sample code below.

object Demo
{
  def main(args: Array[String])
  {
    // The var result is assigned an anonymous function, which has this signature:  (Int, Int) => Int
    var result:(Int, Int) => Int = (a:Int, b:Int) => a+b
    println(result(222, 444)) // PRINTS: 666

    // Here result is again assinged an anonymous function.  This anonymous function is
    // IDENTICAL to the one above.  Howvever, the syntax used to define it is different.
    result = (_:Int)+(_:Int)
    println(result(123, 321)) // PRINTS: 444
  }
}

========================================================================================
The following program shows another example of how functions and methods are used.

object Demo
{
  def main(args: Array[String]): Unit =
  {
    // The twice_1 method and the twice_2 function defined below have
    // IDENTICAL SIGNATURES AND IDENTICAL BEHAVIOR.  twice_1 and twice_2
    // both accept a function (named "op") as the first argument, and
    // "number" as the second argument.  The op() function is then
    // performed on number, which becomes the returned result.
    def twice_1(op:Double=>Double, number:Double):Double = { op(op(number)) }
    val twice_2:(Double=>Double, Double)=>Double = { (op:Double=>Double, number:Double) => op(op(number)) }

    // EXPLANATION: In the following call to twice_1()...
    //              1) The "_ + 1" is a function that gets passed to the "op" argument of
    //                 twice_1(), and 5 gets passed to the "number" argument of twice_1().
    //              2) The underscore (_) references the "number" argument passed
    //                 to twice_1(), which is the number 5.
    //              3) twice_1() returns this expression:  op(op(5))
    //                 First, op(5) returns:  (5.0 + 1.0) = 6.0
    //                 Next, op(6.0) is called, which returns this final value:  (6.0 + 1.0) = 7.0
    var result:Double = twice_1(_ + 1, 5)
    println(s"result #1 = $result") // PRINTS: result #1 = 7.0

    // The EXPLANATION given above for what happens when twice_1() gets called
    // applies equally to what happens when twice_2() is called below.
    result = twice_2(_ + 1, 5)
    println(s"result #2 = $result") // PRINTS: result #2 = 7.0
  }
}

========================================================================================
PARTIAL FUNCTIONS - PART 1 of 3

DON'T confuse partial functions with partially-applied functions!  Partial functions
are NOT related to, or similar to, partially-applied functions.  Partial functions
and partially-applied functions are totally unrelated, and totally different from
each other.

A Scala partial function is a function that returns values for
only a specific set of values passed to it.  A partial function
DOESN'T return anything when it's passed an invalid value.

EXAMPLE: If a partial function performs mathematical division on
         a number passed to it, NO RESULT WILL BE RETURNED when
         that number is zero; because dividing by zero is invalid.

Implementing a partial function in Scala requires the programmer
to define these two methods:
1) apply()       - Automatically called when you pass the function an argument.
2) isDefinedAt() - This method returns a Boolean true for all valid values passed
                   to it.  It returns false for invalid values passed to it.

object Demo
{
  // The [Int, Int] below means you pass the PartialFunction
  // an Int argument, and it returns an Int.
  val dividePF = new PartialFunction[Int, Int]
                 {
                   def apply(number:Int):Int = { 124 / number }
                   // The isDefined() method defines the valid/invalid values.
                   // In this example all Int values are valid except zero.
                   def isDefinedAt(number:Int):Boolean = { number != 0 }
                 }

  def main(args: Array[String])
  {
    // It's possible to call a partial function directly, like this...
    var intValue:Int = dividePF(6)   // Calls the PartialFunction.apply() method.
    println(s"intValue = $intValue") // PRINTS: intValue = 20

    // However, it make sense no sense to call a partial function directly
    // because if you pass it an undefined value, it won't return anything.
    // The following 2 lines of commented-out code will compile, but they'll
    // throw an ArithmeticException because dividePF(0) doesn't return anything.
    // dividePF(0)
    // intValue = dividePF(0)

    // The Scala API contains some methods that accept a partial function
    // as an argument.  That is where partial functions should be used.
    // List.collect is a Scala API method that accepts a partial function.
    var intList:List[Int] = List(0,1,2,4)
    intList = intList.collect{ dividePF }
    println(s"intList = $intList") // PRINTS: intList = List(124, 62, 31)
  }
}

========================================================================================
PARTIAL FUNCTIONS - PART 2 OF 3

object Demo
{
  // NOTICE: In the above example the PartialFunction definition requires
  //         the apply() and isDefinedAt() methods to be defined.  But in the
  //         below example the PartialFunction definition requires only
  //         a case statement.  Because a single case statement effectively
  //         contains the isDefinedAt() and apply() methods.  In the "val Case1"
  //         declaration below:  isDefinedAt() = if (x % 3) != 0
  //                             isApply()     = The entire "case x" statement.
  val Case1:PartialFunction[Int, String] =
  { case x if (x % 3) != 0 => "odd" }

  val Case2:PartialFunction[Int, String] =
  { case y if (y % 2) == 0 => "even" }

  // NOTE: orElse is a method defined in the PartialFunction trait that's
  //       used as an operator on two PartialFunctions.  The following line
  //       of code could also be written like this:  Case1.orElse(Case2)
  val evenOrOdd:PartialFunction[Int, String] = Case1 orElse Case2

  def main(args: Array[String])
  {
    var x:Int = 324
    var result:String = evenOrOdd(x).toString + "."
    println(s"The number $x is $result") // PRINTS: The number 324 is even.

    x = 325
    result = evenOrOdd(x).toString + "."
    println(s"The number $x is $result") // PRINTS: The number 324 is odd.
  }
}

========================================================================================
PARTIAL FUNCTIONS - PART 3 OF 3

object Demo
{
  def main(args: Array[String])
  {
    // Like the 2 PartialFunctions defined in the above example, here we define
    // the operation1 PartialFunction with a single case statement, instead
    // of needing to define the apply() and isDefinedAt() methods.
    val operation1:PartialFunction[Int, Int] = { case x if (x%4 != 0) => x*42 }
    val operation2:(Int=>Int)                = (x: Int) => x/3
    // NOTE: andThen is a method defined in the PartialFunction trait.
    //       andThen is used as an operator.  The following line of code
    //       could also be written like this:  operation1.andThen(operation1)
    val op = operation1 andThen operation2
    // *****************************************************************
    var intValue = 34
    // When op(intValue) is called is called below, these operations occur...
    // operation1:  x%4 = ((34/4) = 8) is NOT zero, so (34*42) = 1428
    // andThen
    // operation2:  x/3 = 1428/3 = 476
    println(s"Initial value = $intValue.\nValue after operations = " + op(intValue))
    // PRINTS:
    // Initial value = 34.
    // Value after operations = 476
    // *****************************************************************
    // *****************************************************************
    intValue = 40
    // When op(intValue) is called below, these operations occur...
    // operation1:  x%4 = ((40/4) = 0) IS zero, so NOTHING IS RETURNED by operation1.
    //              So operation2 is NOT invoked.  NOTHING IS RETURNED, period!
    //              Therefore, the following commented-out line will throw a
    //              MatchError exception if it's not commented out.
    // op(intValue)
    // *****************************************************************
    // *****************************************************************
    // When intList.collect(op) is called below, nothing is returned
    // for elements 8, 12, 40, 44.  Only elements 45 and 77 result
    // in returned values.
    var intList:List[Int] = List (8, 12, 40, 44, 45, 77)
    intList = intList.collect(op)
    println(s"intList = $intList") // PRINTS: intList = List(630, 1078)
  }
}

========================================================================================
ANONYMOUS FUNCTIONS - Some examples below.

object Demo
{
  def main(args: Array[String]): Unit = {
    // EXAMPLE 1 **************************************************************************
    case class StringToInt(run:String => Int)
    // Instantiate a StringToInt class by passing to it an anonymous function,
    // which will get assigned to its member val named "run".
    // NOTE: You could replace this text: StringToInt(x => x.toInt)
    //       with this text:              StringToInt{ str:String => str.toInt }
    val myClass_1:StringToInt = StringToInt(x => x.toInt)
    var myInt:Int = myClass_1.run("-777") // "run" is a val member of myClass_1.
    println(s"myInt #1 = $myInt") // PRINTS: result #1 = -777

    // This time we pass stringToInt() a defined function named: myStrLengthFunc
    def myStrLengthFunc(str:String):Int = { str.length }
    val valFunc_1:StringToInt = StringToInt(myStrLengthFunc)
    myInt = valFunc_1.run("Madison, Wisconsin")
    println(s"myInt #2 = $myInt") // PRINTS: myInt #2 = 18

    // EXAMPLE 2 **************************************************************************
    case class TwoStringsToInt[A,B](func:(A,A) => B)
    val anonFunc = (a:String, b:String) => (a.length + b.length)
    val myClass_2:TwoStringsToInt[String, Int] = TwoStringsToInt(anonFunc)
    // func is a member val of the TwoStringsToInt class, created upon instantiation of TwoStringsToInt.
    myInt = myClass_2.func("Madison", "Wisconsin")
    println(s"myInt #3 = $myInt") // PRINTS: myInt #3 = 16
  }
}

========================================================================================
OBSCURE WAYS FUNCTIONS CAN BE USED
==================================

Read in-line comments if the following code sample.


object Demo
{
  def main(args: Array[String])
  {
    // Here we declare a function that gets passed the "Any" Scala data type, and
    // returns a String.  NOTICE: It's possible to implement case statements within
    // a function without using the "match" keyword!
    val func:(Any=>String) =
    {
      case d:Double => "Double"
      case f:Float  => "Float"
      case i:Int    => "Int"
      case s:String => "String"
      case _        => "Other"
    }
    println(func('X'))       // PRINTS: Other
    println(func(123.456D))  // PRINTS: Double
    println(func(-98.76F))   // PRINTS: Float
    println(func(12345))     // PRINTS: Int
    println(func("Jupiter")) // PRINTS: String

    // The List.collect method accepts a PARTIAL FUNCTION as an argument.
    // A PARTIAL FUNCTION executes for some values, but not all values.
    // The case statement passed to List.collect below is a PARTIAL FUNCTION,
    // as it returns a value ONLY for intList elements NOT equal to zero.
    var intList:List[Int] = List(0,1,2,4)
    intList = intList.collect{ case i: Int if i != 0 => 42 / i }
    println(s"intList = $intList") // PRINTS: intList = List(42, 21, 10)

    // In this section List.collect is called with the same PARTIAL FUNCTION
    // case statement as above.  However, because all elements in intList
    // are zero, List.collect returns List(), which is an EMPTY List..
    intList = List(0,0,0,0)
    intList = intList.collect{ case i: Int if i != 0 => 42 / i }
    println(s"intList = $intList") // PRINTS: intList = List()

    // In this section the List.map method is called, which accepts a regular
    // function, NOT a partial function.  However, List.map can still accept
    // a case statement as its function.  But unlike the case statement
    // passed to List.collect() above, the below case statement ALWAYS
    // returns a value, which means it's NOT a partial function.
    var strList:List[String] = List("Jupiter", "Uranus", "Neptune")
    var result:List[Boolean] = strList.map{ case s: String => s.length > 6 }
    println(s"result = $result") // PRINTS: result = List(true, false, true)

    // The following function passed to List.map is a more common way of
    // calling List.map, and it returns the identical result as the
    // case statement used in the previous example.
    result = strList.map(_.length > 6)
    println(s"result = $result") // PRINTS: result = List(true, false, true)
  }
}

========================================================================================
