The words "method" and "function" are often used interchangeably.
However, in Scala there are important differences between a method
and a function.

NOTE: This section also demonstrates the use of VARARGS (Variable
      number of arguments).  For more information on VARARGS, see
      the section titled:  Variable_No_Of_Args
      SEE --> https://github.com/w9mwi/Scala/edit/master/Variable_No_Of_Args

Method - A Scala method's signature will NEVER contain the rocket symbol (=>),
         and will look similar to this:
         (String):Int   (The method takes an String argument, and returns an Int value.)

         A Scala method is always bound to a class/object/trait.
         In other words, a method IS A MEMBER of a class/object/trait.
         A Scala method is always defined using the keyword "def", like this:

         def squareMethod(number: Float): Float = number * number  // Method definition.
         println(s"squareMethod(123.456F) = ${squareMethod(123.456F)}")  // Call the method.
         // PRINTS: squareMethod(123.456F) = 15241.384

Function - A Scala function's signature ALWAYS contains the rocket symbol (=>),
           and will look similar to this:
           String=>Int   (The function takes a String argument, and returns an Int value.)

           A Scala function is NOT bound to a class/object/trait.  (Although,
           any function you write will reside in some class/object/trait.)
           You CAN'T create a Scala function using the "def" keyword because
           the "def" keyword makes it a method.  The following shows three (3)
           ways to write a Scala function.

           1) Write the function code, and assign it to a val/var.  This allows
              you to call the function repeatedly after it's written, by
              referencing the val/var.

              val squareFunction:(Float=>Float) = { (number:Float) => number*number } // Function assigned to a val.
              println(s"squareFunction(123.456F) = ${squareFunction(123.456F)}") // Call the function.
              // PRINTS: squareFunction(123.456F) = 15241.384

           2) Create a Scala function by transform a method into a function, which
              is performed by doing an ETA EXPANSION on the method.  Then assign
              the function to a val/var.

              // Define a Scala method.
              def squareMethod(number: Float): Float = number * number
              
              // Transform the squareMethod() method into a function.
              val squareFunction:(Float=>Float) = squareMethod
              // NOTE: The above line can also be written these 2 ways, with the underscore (_) char.
              //       val squareFunction:(Float=>Float) = squareMethod _
              //       val squareFunction:(Float=>Float) = squareMethod(_)
              println(s"squareFunction(123.456F) = ${squareFunction(123.456F)}") // Call the function.
              // PRINTS: squareFunction(123.456F) = 15241.384

           3) When a method/function has an argument that requires a function data type,
              you can write an anonymous function directly inside the argument.  The
              Scala API contains hundreds of methods that take function arguments.
              Here is an example.

              var floatList:List[Float] = List(1.0F, 2.0F, 3.0F, 4.0F, 5.0F)
              floatList = floatList.map(x=>x*x)  // Pass List.map() an anonymous function
              println(s"floatList = $floatList") // PRINTS: floatList = List(1.0, 4.0, 9.0, 16.0, 25.0)

              // You can also pass a method OR a function to the List.map() function.
              def squareMethod(number: Float): Float = number * number
              floatList = floatList.map(squareMethod)
              println(s"floatList = $floatList")
              // PRINTS: floatList = floatList = List(1.0, 16.0, 81.0, 256.0, 625.0)


           
The code samples below shows examples of how to write both Scala methods
and Scala functions.

A Scala function CAN'T be written to accept parameterized (generic) arguments.
A Scala method (which is created with the "def" keyword) CAN be written to
accept parameterized (generic) arguments, like this:

// firstChar works with args of type Double, Float, Int, String, etc.
def firstChar[A](a: A) = { a.toString.charAt(0) }

IMPORTANT: To distinguish a Scala function from a Scala method LOOK AT THE SIGNATURE!

           A Scala function's signature will ALWAYS include the rocket symbol (=>),
           and will look similar to this:
           Int=>Int  -  The function takes an Int argument, and returns an Int value.

           A Scala method's signature will look similar to this:
           (Int):Int  -  The method takes an Int argument, and returns an Int value.


========================================================================================

object Demo
{
  def main(args: Array[String])
  {
    // ********************************************************************
    // When the "def" keyword is used, a method (not a function) is created.
    // Therefore, squareMethod is a METHOD, not a function.
    def squareMethod(number:Int):Int = number*number
    val numberList:List[Int] = List(1, 2, 3, 4, 5)

    // Many Scala methods REQUIRE A FUNCTION to be passed as an argument.
    // EXAMPLE: The List.map method called below is defined to accept a
    //          function as its argument, NOT a method.  But in the code
    //          below we pass a method to List.map and it works because
    //          Scala automatically converts the method into a function.
    // When a Scala method is defined to accept a function as an argument,
    // you can usually pass a method instead and it'll work because Scala
    // will automatically convert the method into a function.  The following
    // call to the List.map() method demonstrates this because it gets
    // passed a method, even though its API documentation says it accepts
    // a function argument.
    var listResult:List[Int] = numberList.map(squareMethod)
    println(s"listResult 1) = $listResult") // PRINTS: listResult 1) = List(1, 4, 9, 16, 25)
    // ********************************************************************

    // ********************************************************************
    // THERE ARE THREE (3) WAYS TO WRITE A FUNCTION:
    // 1) Upon declaring a val/var, assign a function to it.
    val squareFunction:(Int=>Int) = { (number:Int) => number*number }
    listResult = numberList.map(squareFunction)
    println(s"listResult 2) = $listResult") // PRINTS: listResult 2) = List(1, 4, 9, 16, 25)
    //
    // 2) Pass an anonymous function (i.e., x=>x*x) as the argument to a method.
    listResult = numberList.map(x=>x*x)
    println(s"listResult 3) = $listResult") // PRINTS: listResult 3) = List(1, 4, 9, 16, 25)
    //
    // 3) Transform a Scala method into a function via an ETA EXPANSION.
    //    The following 3 lines of code all perform an ETA EXPANSION on
    //    squareMethod, which transforms it into a function.  It makes
    //    no difference which syntax (shown in the 3 lines below) you
    //    choose to use.
    val squareFunction2A:(Int=>Int) = squareMethod
    val squareFunction2B            = squareMethod _
    val squareFunction2C            = squareMethod(_)
    var intResult:Int = squareFunction2A(7)
    println(s"intResult 1) = $intResult") // PRINTS: intResult 1) = 49
    intResult = squareFunction2B(8)
    println(s"intResult 2) = $intResult") // PRINTS: intResult 2) = 64
    intResult = squareFunction2C(9)
    println(s"intResult 3) = $intResult") // PRINTS: intResult 3) = 81
    // ********************************************************************
  }
}

========================================================================================
ETA EXPANSION - The above code sample shows some examples of ETA EXPANSION.
                The below code shows another example of an ETA EXPANSION.

object Demo
{
  def main(args: Array[String])
  {
    // THIS TEXT IS ALL ABOUT THE makeSentence() METHOD IMMEDIATELY BELOW.
    // When a method's definition contains an asterisk (*) in its argument list,
    // it designates that it can be called with a variable number of arguments.
    // In the below makeSentence method, the asterisk (*) is preceded with the data
    // type "String".  Therefore, this makeSentence method MUST get passed one or
    // more String arguments when it's called.  That part is easy to understand.
    //
    // When you inspect the argument named "words" in the makeSentence definition,
    // you'll discover its data type is Seq[String].  That's confusing because the
    // "words" argument is defined to have data type of String*.  When Scala sees
    // an asterisk (*) after the data type String, Scala translates that into a
    // data type of Seq[String], which makes sense because String* is NOT a
    // valid data type.
    //
    // Although Scala assigns a data type of Seq[String] to the "words" argument in
    // makeSentence, you CAN'T pass makeSentence an argument of type Seq[String].
    // WHY NOT?...  Because when an argument is defined with an asterisk (*) char,
    // Scala forces the method to accept ONLY arguments of the data type preceding
    // the asterisk (*) char--in this example the data type is String.  ONLY AFTER
    // string arguments are passed to makeSentence does Scala build the "words"
    // argument (from the strings) and assign it the data type Seq[String].
    //
    // In the next sample program (below this one) we'll transform makeSentence
    // from a method into a FUNCTION via an ETA EXPANSION.  Then makeSentence
    // will accept a single Seq[String] argument instead of a variable number
    // of string arguments.  So we'll be able to call makeSentence by passing
    // it a single List[String] instead of multiple string arguments.
    //
    // Since "words" is of type Seq[String], we must call words.mkString
    // to convert that Seq[String] data type into a single string, which
    // gets returned.
    def makeSentence(words:String*):String = words.mkString(" ") + "."

    // Call makeSentence() to test it...
    var strResult = makeSentence("Make", "these", "words", "into", "a", "single", "sentence")
    println(s"strResult 1) = $strResult")
    // PRINTS:  strResult 1) = Make these words into a single sentence.

    // Next, perform an ETA EXPANSION on makeSentence.  This will transform
    // makeSentence into a function that takes a single Seq[String] as an
    // argument, and returns a string.  NOTE: A List[String] data type
    // also works because its a child of the Seq[String] data type.
    val listOfWords:List[String] = List("Tomorrow", "is", "a", "different", "day")
    val etaExpand:(Seq[String]=>String) = makeSentence
    strResult = etaExpand(listOfWords)
    println(s"strResult 2) = $strResult")
    // PRINTS: strResult 2) = Tomorrow is a different day.
  }
}

========================================================================================
The following code sample shows another example of transforming
a regular function into a curried function by first performing
an ETA EXPANSION on it by adding the underscore (_) character,
and then calling Scala's .curried() method.

object Demo
{
  def main(args: Array[String])
  {
    // The add_1() function is a regular/normal function.
    // The first time the add_1() is called here, it's
    // called in the usual way....
    println("add_1(7, 3) = " + add_1(7, 3)) // PRINTS: add_1(7, 3) = 10

    // Perform an "Eta Expansion" on add_1() by using the underscore (_) character...
    val addFunc:((Int, Int) => Int) = add_1 _

    val addFuncCurried:(Int => (Int => Int)) = addFunc.curried // Make the add_1() function a curried function.
    println("addFuncCurried(7)(3) = " + addFuncCurried(7)(3)) // PRINTS: addFuncCurried(7)(3) = 10

    // addFuncCurried called with one param returns a PARTIALLY APPLIED function...
    val partiallyAppliedCurried:(Int => Int) = addFuncCurried(7)
    // Call partiallyAppliedCurried to make addFuncCurried FULLY APPLIED...
    println("partiallyAppliedCurried(3) = " + partiallyAppliedCurried(3)) // PRINTS: partiallyAppliedCurried(3) = 10

    // *****************************************************************************************
    // The add_2()() function called below is a curried function,
    // and can be called in the following two (2) ways...
    //
    // 1) Call sum_2()() once by passing to it both Int params, so it
    //    returns an Int result...
    println("add_2(7)(3) = " + add_2(7)(3)) // PRINTS: add_2(7)(3) = 10

    // 2) Call sum_2()() twice...  sum_2()() is called the first time by
    //    initializing its x Int parameter, and it returns a function.
    //    (At this point, the sum_2()() function is PARTIALLY APPLIED)
    //    Then, sum_2()() is called the second time by initializing
    //    its y Int parameter so it will now return an Int value.
    //    (At this point, the sum_2()() function is FULLY APPLIED.)
    val func:(Int => Int) = add_2(7)(_) // The func function is PARTIALLY APPLIED here.
    println("func(3) = " + func(3)) // PRINTS: func(3) = 10  (func is now FULLY APPLIED.)
  }

  /**
   * This add_1() function is a normal function, NOT a curried function.
   */
  def add_1(x:Int, y:Int):Int = { x + y }

  /**
   * This add_2() function is a CURRIED FUNCTION because
   * it takes multiple arguments, and returns a function
   * that takes a single argument.
   */
  def add_2(x:Int) = { (y:Int) => x + y }
}

========================================================================================
ANONYMOUS FUNCTION - Read in-line comments in sample code below.

object Demo
{
  def main(args: Array[String])
  {
    // The var result is assigned an anonymous function, which has this signature:  (Int, Int) => Int
    var result:(Int, Int) => Int = (a:Int, b:Int) => a+b
    println(result(222, 444)) // PRINTS: 666

    // Here result is again assinged an anonymous function.  This anonymous function is
    // IDENTICAL to the one above.  Howvever, the syntax used to define it is different.
    result = (_:Int)+(_:Int)
    println(result(123, 321)) // PRINTS: 444
  }
}

========================================================================================
The following program shows another example of how functions and methods are used.

object Demo
{
  def main(args: Array[String]): Unit =
  {
    // The twice_1 method and the twice_2 function defined below have
    // IDENTICAL SIGNATURES AND IDENTICAL BEHAVIOR.  twice_1 and twice_2
    // both accept a function (named "op") as the first argument, and
    // "number" as the second argument.  The op() function is then
    // performed on number, which becomes the returned result.
    def twice_1(op:Double=>Double, number:Double):Double = { op(op(number)) }
    val twice_2:(Double=>Double, Double)=>Double = { (op:Double=>Double, number:Double) => op(op(number)) }

    // EXPLANATION: In the following call to twice_1()...
    //              1) The "_ + 1" is a function that gets passed to the "op" argument of
    //                 twice_1(), and 5 gets passed to the "number" argument of twice_1().
    //              2) The underscore (_) references the "number" argument passed
    //                 to twice_1(), which is the number 5.
    //              3) twice_1() returns this expression:  op(op(5))
    //                 First, op(5) returns:  (5.0 + 1.0) = 6.0
    //                 Next, op(6.0) is called, which returns this final value:  (6.0 + 1.0) = 7.0
    var result:Double = twice_1(_ + 1, 5)
    println(s"result #1 = $result") // PRINTS: result #1 = 7.0

    // The EXPLANATION given above for what happens when twice_1() gets called
    // applies equally to what happens when twice_2() is called below.
    result = twice_2(_ + 1, 5)
    println(s"result #2 = $result") // PRINTS: result #2 = 7.0
  }
}

========================================================================================
PARTIAL FUNCTIONS - PART 1 of 3

DON'T confuse partial functions with partially-applied functions!  Partial functions
are NOT related to, or similar to, partially-applied functions.  Partial functions
and partially-applied functions are totally unrelated, and totally different from
each other.

A Scala partial function is a function that returns values for
only a specific set of values passed to it.  A partial function
DOESN'T return anything when it's passed an invalid value.

EXAMPLE: If a partial function performs mathematical division on
         a number passed to it, NO RESULT WILL BE RETURNED when
         that number is zero; because dividing by zero is invalid.

Implementing a partial function in Scala requires the programmer
to define these two methods:
1) apply()       - Automatically called when you pass the function an argument.
2) isDefinedAt() - This method returns a Boolean true for all valid values passed
                   to it.  It returns false for invalid values passed to it.

object Demo
{
  // The [Int, Int] below means you pass the PartialFunction
  // an Int argument, and it returns an Int.
  val dividePF = new PartialFunction[Int, Int]
                 {
                   def apply(number:Int):Int = { 124 / number }
                   // The isDefined() method defines the valid/invalid values.
                   // In this example all Int values are valid except zero.
                   def isDefinedAt(number:Int):Boolean = { number != 0 }
                 }

  def main(args: Array[String])
  {
    // It's possible to call a partial function directly, like this...
    var intValue:Int = dividePF(6)   // Calls the PartialFunction.apply() method.
    println(s"intValue = $intValue") // PRINTS: intValue = 20

    // However, it make sense no sense to call a partial function directly
    // because if you pass it an undefined value, it won't return anything.
    // The following 2 lines of commented-out code will compile, but they'll
    // throw an ArithmeticException because dividePF(0) doesn't return anything.
    // dividePF(0)
    // intValue = dividePF(0)

    // The Scala API contains some methods that accept a partial function
    // as an argument.  That is where partial functions should be used.
    // List.collect is a Scala API method that accepts a partial function.
    var intList:List[Int] = List(0,1,2,4)
    intList = intList.collect{ dividePF }
    println(s"intList = $intList") // PRINTS: intList = List(124, 62, 31)
  }
}

========================================================================================
PARTIAL FUNCTIONS - PART 2 OF 3

object Demo
{
  // NOTICE: In the above example the PartialFunction definition requires
  //         the apply() and isDefinedAt() methods to be defined.  But in the
  //         below example the PartialFunction definition requires only
  //         a case statement.  Because a single case statement effectively
  //         contains the isDefinedAt() and apply() methods.  In the "val Case1"
  //         declaration below:  isDefinedAt() = if (x % 3) != 0
  //                             isApply()     = The entire "case x" statement.
  val Case1:PartialFunction[Int, String] =
  { case x if (x % 3) != 0 => "odd" }

  val Case2:PartialFunction[Int, String] =
  { case y if (y % 2) == 0 => "even" }

  // NOTE: orElse is a method defined in the PartialFunction trait that's
  //       used as an operator on two PartialFunctions.  The following line
  //       of code could also be written like this:  Case1.orElse(Case2)
  val evenOrOdd:PartialFunction[Int, String] = Case1 orElse Case2

  def main(args: Array[String])
  {
    var x:Int = 324
    var result:String = evenOrOdd(x).toString + "."
    println(s"The number $x is $result") // PRINTS: The number 324 is even.

    x = 325
    result = evenOrOdd(x).toString + "."
    println(s"The number $x is $result") // PRINTS: The number 324 is odd.
  }
}

========================================================================================
PARTIAL FUNCTIONS - PART 3 OF 3

object Demo
{
  def main(args: Array[String])
  {
    // Like the 2 PartialFunctions defined in the above example, here we define
    // the operation1 PartialFunction with a single case statement, instead
    // of needing to define the apply() and isDefinedAt() methods.
    val operation1:PartialFunction[Int, Int] = { case x if (x%4 != 0) => x*42 }
    val operation2:(Int=>Int)                = (x: Int) => x/3
    // NOTE: andThen is a method defined in the PartialFunction trait.
    //       andThen is used as an operator.  The following line of code
    //       could also be written like this:  operation1.andThen(operation1)
    val op = operation1 andThen operation2
    // *****************************************************************
    var intValue = 34
    // When op(intValue) is called is called below, these operations occur...
    // operation1:  x%4 = ((34/4) = 8) is NOT zero, so (34*42) = 1428
    // andThen
    // operation2:  x/3 = 1428/3 = 476
    println(s"Initial value = $intValue.\nValue after operations = " + op(intValue))
    // PRINTS:
    // Initial value = 34.
    // Value after operations = 476
    // *****************************************************************
    // *****************************************************************
    intValue = 40
    // When op(intValue) is called below, these operations occur...
    // operation1:  x%4 = ((40/4) = 0) IS zero, so NOTHING IS RETURNED by operation1.
    //              So operation2 is NOT invoked.  NOTHING IS RETURNED, period!
    //              Therefore, the following commented-out line will throw a
    //              MatchError exception if it's not commented out.
    // op(intValue)
    // *****************************************************************
    // *****************************************************************
    // When intList.collect(op) is called below, nothing is returned
    // for elements 8, 12, 40, 44.  Only elements 45 and 77 result
    // in returned values.
    var intList:List[Int] = List (8, 12, 40, 44, 45, 77)
    intList = intList.collect(op)
    println(s"intList = $intList") // PRINTS: intList = List(630, 1078)
  }
}

========================================================================================
ANONYMOUS FUNCTIONS - Some examples below.

object Demo
{
  def main(args: Array[String]): Unit = {
    // EXAMPLE 1 **************************************************************************
    case class StringToInt(run:String => Int)
    // Instantiate a StringToInt class by passing to it an anonymous function,
    // which will get assigned to its member val named "run".
    // NOTE: You could replace this text: StringToInt(x => x.toInt)
    //       with this text:              StringToInt{ str:String => str.toInt }
    val myClass_1:StringToInt = StringToInt(x => x.toInt)
    var myInt:Int = myClass_1.run("-777") // "run" is a val member of myClass_1.
    println(s"myInt #1 = $myInt") // PRINTS: result #1 = -777

    // This time we pass stringToInt() a defined function named: myStrLengthFunc
    def myStrLengthFunc(str:String):Int = { str.length }
    val valFunc_1:StringToInt = StringToInt(myStrLengthFunc)
    myInt = valFunc_1.run("Madison, Wisconsin")
    println(s"myInt #2 = $myInt") // PRINTS: myInt #2 = 18

    // EXAMPLE 2 **************************************************************************
    case class TwoStringsToInt[A,B](func:(A,A) => B)
    val anonFunc = (a:String, b:String) => (a.length + b.length)
    val myClass_2:TwoStringsToInt[String, Int] = TwoStringsToInt(anonFunc)
    // func is a member val of the TwoStringsToInt class, created upon instantiation of TwoStringsToInt.
    myInt = myClass_2.func("Madison", "Wisconsin")
    println(s"myInt #3 = $myInt") // PRINTS: myInt #3 = 16
  }
}

========================================================================================
OBSCURE WAYS FUNCTIONS CAN BE USED
==================================

Read in-line comments if the following code sample.


object Demo
{
  def main(args: Array[String])
  {
    // Here we declare a function that gets passed the "Any" Scala data type, and
    // returns a String.  NOTICE: It's possible to implement case statements within
    // a function without using the "match" keyword!
    val func:(Any=>String) =
    {
      case d:Double => "Double"
      case f:Float  => "Float"
      case i:Int    => "Int"
      case s:String => "String"
      case _        => "Other"
    }
    println(func('X'))       // PRINTS: Other
    println(func(123.456D))  // PRINTS: Double
    println(func(-98.76F))   // PRINTS: Float
    println(func(12345))     // PRINTS: Int
    println(func("Jupiter")) // PRINTS: String

    // The List.collect method accepts a PARTIAL FUNCTION as an argument.
    // A PARTIAL FUNCTION executes for some values, but not all values.
    // The case statement passed to List.collect below is a PARTIAL FUNCTION,
    // as it returns a value ONLY for intList elements NOT equal to zero.
    var intList:List[Int] = List(0,1,2,4)
    intList = intList.collect{ case i: Int if i != 0 => 42 / i }
    println(s"intList = $intList") // PRINTS: intList = List(42, 21, 10)

    // In this section List.collect is called with the same PARTIAL FUNCTION
    // case statement as above.  However, because all elements in intList
    // are zero, List.collect returns List(), which is an EMPTY List..
    intList = List(0,0,0,0)
    intList = intList.collect{ case i: Int if i != 0 => 42 / i }
    println(s"intList = $intList") // PRINTS: intList = List()

    // In this section the List.map method is called, which accepts a regular
    // function, NOT a partial function.  However, List.map can still accept
    // a case statement as its function.  But unlike the case statement
    // passed to List.collect() above, the below case statement ALWAYS
    // returns a value, which means it's NOT a partial function.
    var strList:List[String] = List("Jupiter", "Uranus", "Neptune")
    var result:List[Boolean] = strList.map{ case s: String => s.length > 6 }
    println(s"result = $result") // PRINTS: result = List(true, false, true)

    // The following function passed to List.map is a more common way of
    // calling List.map, and it returns the identical result as the
    // case statement used in the previous example.
    result = strList.map(_.length > 6)
    println(s"result = $result") // PRINTS: result = List(true, false, true)
  }
}

========================================================================================
