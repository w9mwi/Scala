The words "method" and "function" are often used interchangeably.
However, in Scala there are important differences between a method
and a function.

Method - A Scala method is bound to a class/object/trait.  In other
         words, a method IS A MEMBER of a class/object/trait.
         A Scala method is ALWAYS created using the "def" keyword.
         A Scala method can be transformed into a Scala function by
         performing an ETA EXPANSION on the method.  The code sample
         below performs an ETA EXPANSION on some methods, so you can
         see how this is done.

Function - A Scala function is NOT bound to a class/object/trait.
           You CAN'T create a Scala function using the "def" keyword,
           because using the "def" keyword makes it a method.  The
           code sample below shows examples of how to write both
           Scala methods and Scala functions.

IMPORTANT: To distinguish a Scala function from a Scala method, LOOK AT ITS SIGNATURE!

           A Scala method's signature will look similar to this:
           (Int):Int  -  The method takes an Int argument, and returns an Int value.

           A Scala function's signature will ALWAYS include the rocket symbol (=>),
           and will look similar to this:
           Int=>Int  -  The function takes an Int argument, and returns an Int value.

========================================================================================

object Demo
{
  def main(args: Array[String])
  {
    // ********************************************************************
    // When the "def" keyword is used, a method (not a function) is created.
    // Therefore, squareMethod1 is a METHOD, not a function.
    def squareMethod1(number:Int):Int = number*number
    val numberList:List[Int] = List(1, 2, 3, 4, 5)

    // Many Scala methods REQUIRE A FUNCTION to be passed as an argument.
    // (The List.map method called below is defined to accept a function
    // as its argument, NOT a method.)  However, if a method has the same
    // functionality as the required argument, you can pass a method
    // (instead of a function) and it WILL WORK.  As Scala AUTOMATICALLY
    // CONVERTS methods into functions when an argument requires a function.
    // The following call to the List.map() method demonstrates this.
    var listResult:List[Int] = numberList.map(squareMethod1)
    println(s"listResult 1) = $listResult") // PRINTS: listResult 1) = List(1, 4, 9, 16, 25)
    // ********************************************************************

    // ********************************************************************
    // THERE ARE THREE (3) WAYS TO WRITE A FUNCTION:
    // 1) Upon declaring a val/var, assign a function to it.
    val squareFunction:(Int=>Int) = { (number:Int) => number*number }
    listResult = numberList.map(squareFunction)
    println(s"listResult 2) = $listResult") // PRINTS: listResult 2) = List(1, 4, 9, 16, 25)
    //
    // 2) Pass an anonymous function (i.e., x=>x*x) as the argument to a method.
    listResult = numberList.map(x=>x*x)
    println(s"listResult 3) = $listResult") // PRINTS: listResult 3) = List(1, 4, 9, 16, 25)
    //
    // 3) Transform a Scala method into a function via an ETA EXPANSION.
    //    The following 3 lines of code all perform an ETA EXPANSION on
    //    squareMethod1, which transforms it into a function.  It makes
    //    no difference which syntax (shown in the 3 lines below) you
    //    choose to use.
    val squareFunction2A:(Int=>Int) = squareMethod1
    val squareFunction2B            = squareMethod1 _
    val squareFunction2C            = squareMethod1(_)
    var intResult:Int = squareFunction2A(7)
    println(s"intResult 1) = $intResult") // PRINTS: intResult 1) = 49
    intResult = squareFunction2B(8)
    println(s"intResult 2) = $intResult") // PRINTS: intResult 2) = 64
    intResult = squareFunction2C(9)
    println(s"intResult 3) = $intResult") // PRINTS: intResult 3) = 81
    // ********************************************************************

    // The following testMethod requires a function as its second argument.
    def testMethod(x:Int, function:Int=>Int) = function(x)
    val poop = testMethod(99, squareMethod1)
    println("poop = " + poop)
  }
}

========================================================================================

object Demo
{
  def main(args: Array[String])
  {
    // When a method's definition contains an asterisk (*) in its argument list,
    // it designates that it can be called with a variable number of arguments.
    // In the below makeSentence method, the asterisk (*) is preceded with the data
    // type "String".  Therefore, this makeSentence method MUST get passed one or
    // more String arguments when it's called.  That part is easy to understand.
    //
    // When you inspect the data type of the argument named "words" you'll
    // discover its data type is Seq[String].  That's confusing because
    // the below text specifies the data type as "String*".  When Scala
    // sees an asterisk (*) after the data type String, Scala translates
    // that into a data type of Seq[String], which now makes sense.
    //
    // Although Scala assigns a data type of Seq[String] to the "words" argument in
    // makeSentence, you CAN'T pass makeSentence an argument of type Seq[String].
    // Because the "words" argument in the makeSentence definition is declared of
    // data type "String*", you are forced to pass ONLY string arguments to
    // makeSentence.  In the next sample program (below this one) we'll transform
    // makeSentence from a method into a FUNCTION via an ETA EXPANSION.  Then
    // makeSentence will accept a single Seq[String] argument instead of a
    // variable number of string arguments.  So we'll be able to call makeSentence
    // by passing it a List[String] instead of multiple string arguments.
    //
    // Since "words" is of type Seq[String], we must call words.mkString
    // to convert that Seq[String] data type into a single string, which
    // gets returned.
    def makeSentence(words:String*):String = words.mkString(" ") + "."

    // Call makeSentence() to test it...
    var strResult = makeSentence("Make", "these", "words", "into", "a", "single", "sentence")
    println(s"strResult 1) = $strResult")
    // PRINTS:  strResult 1) = Make these words into a single sentence.

    // Next, perform an ETA EXPANSION on makeSentence.  This will transform
    // makeSentence into a function that takes a single Seq[String] as an
    // argument, and returns a string.  NOTE: A List[String] data type
    // also works because its a child of the Seq[String] data type.
    val listOfWords:List[String] = List("Tomorrow", "is", "a", "different", "day")
    val etaExpand:(Seq[String]=>String) = makeSentence
    strResult = etaExpand(listOfWords)
    println(s"strResult 2) = $strResult")
    // PRINTS: strResult 2) = Tomorrow is a different day.
  }
}
