READ THESE LINKS ABOUT FUNCTIONS VS. METHODS
--> https://www.baeldung.com/scala/functions-methods
--> http://jim-mcbeath.blogspot.com/2009/05/scala-functions-vs-methods.html



The words "method" and "function" are often used interchangeably as if
a method and a function are identical.  In Scala there are important
differences between a method and a function that the programmer should
know.  This section explains methods, functions, and how they differ.

This web page covers the following topics, all of which are related to
methods and functions:

* METHOD
* FUNCTION
* ETA EXPANSION
* ANONYMOUS FUNCTION
* NULLARY FUNCTION
* PARTIAL FUNCTION
* FUNCTIONS BUILT WITH ONLY CASE STATEMENTS

==========================================================================================

METHOD
======
A Scala method is ALWAYS written using the "def" keyword.  So whenever the "def" keyword
appears, a method is defined.  Here's an example of a Scala method named squareMethod(),
which accepts a Float number as an argument, squares the number, and returns the result
as a Float number.

object Demo
{
  // Define the method.
  def squareMethod(number: Float): Float = number * number

  def main(args: Array[String]): Unit = {
    // The following line calls squareMethod(), and prints its returned result.
    println(s"squareMethod(123.456F) = ${squareMethod(123.456F)}")
    // PRINTS: squareMethod(123.456F) = 15241.384
  }
}

The following code sample shows two method definitions that may look strange to a
newcomer.  Both methods accept no arguments and return the same Int value (123).
One of the methods is defined WITHOUT parenthesis.  The other method is defined
WITH parenthesis.  Read in-line comments for details.

object Demo
{
  def main(args:Array[String]): Unit =
  {
    // You can define a method that accepts no arguments by leaving
    // out the parenthesis, OR by including empty parenthesis ().
    def number_1:Int   = 123  // Method number_1 has no parenthesis, and accepts no arguments.
    def number_2():Int = 123  // Method number_2 has parenthesis, and accepts no arguments.

    // A method defined without parenthesis MUST be called without parenthesis.
    println("number_1 = " + number_1)  // PRINTS: number_1 = 123

    // If you uncomment the following commented-out line it WON'T COMPILE,
    // as you're trying to call the number_1 method with empty parenthesis.
    // println("number_1() = " + number_1()) // WON'T COMPILE!

    // A method defined with empty parenthesis can be called
    // without parenthesis OR with empty parenthesis.
    println("number_2 = " + number_2)     // PRINTS: number_2 = 123
    println("number_2() = " + number_2()) // PRINTS: number_2() = 123
  }
}

Because methods number_1 and number_2() above accept no arguments and always return
the same value, you'd never write such methods.  Instead, you'd just declare number
as a val, like this:

val number:Int = 123

A Scala method is ALWAYS bound to some class/object/trait.  In other words, a method
IS A MEMBER of some class/object/trait.  The following code demonstrates this by
showing that the method Person.printPerson() is invoked via the instantiated
Person class, which is assigned to the val joe.

object Demo
{
  case class Person(name:String, yearBorn:Int) {
    def printPerson = println(s"Name = $name,  Born = $yearBorn")
  }

  def main(args:Array[String]): Unit = {
    val joe:Person = Person("Joe", 1963)
    joe.printPerson  // PRINTS: Name = Joe,  Born = 1963
  }
}

You can't write a Scala method to accept another Scala method as an argument
because the language doesn't allow that.  However, you can write a Scala method
to accept a Scala function as an argument.

If you pass a Scala method to another Scala method as an argument that accepts
a function, the code will compile and run.  Because the Scala compiler converts
methods to functions when they're passed as arguments.  The following code
sample demonstrates this.  NOTE: The data type of a function is always written
using the rocket symbol (=>), as shown in the processNumber() method below.

object Demo
{
  def main(args:Array[String]): Unit =
  {
    // addTen() is a Scala method, NOT a function.
    def addTen(number:Int):Int = { number + 10 }

    // processNumber() is a Scala method that accepts these 2 arguments:
    // 1) an Int type
    // 2) A function type, which accepts an Int argument, and returns an Int value.
    def processNumber(number:Int, funky:Int=>Int):Int = { funky(number) }

    // Even though processNumber() is defined to accept a function as an argument,
    // you can pass to it a Scala method.  The Scala compiler automatically
    // converts the method to a function.
    val result = processNumber(10, addTen)
    println(s"processNumber(10, addTen) = $result") // PRINTS: processNumber(10, addTen) = 20
  }
}

==========================================================================================

FUNCTION
========
READ --> https://www.baeldung.com/scala/functions-methods

When you write a Scala method the "def" keyword is REQUIRED.  But a Scala function
is NEVER written using the "def" keyword.  Here are the three ways to create a
Scala function:

1) You can transform a Scala method into a Scala function by performing an Eta Expansion
   on the method, which is explained in the below section titled "ETA EXPANSION".

2) You can write a function as an Anonymous Function (a function that has no name),
   which is explained in below section titled "ANONYMOUS FUNCTION".

3) You can write code that is a function, then assign it to a val/var, as shown in
   the following example.  This code is very similar to the code sample immediately
   above in the section titled "METHOD".  A function cannot be written so that the
   function itself is a member of the Person class (as a method can be a member of
   the Person class).  Instead, the Person class contains a val, and the function
   is assigned to it.  The function is then invoked by referencing the val, as shown
   in the main() method below.  Again, only the val func is a member of the Person
   class.  A stand-alone function on its own CAN'T be a member of a class/object/trait.

   object Demo
   {
     case class Person(name:String, yearBorn:Int) {
       // The following function is assigned to the val func.
       val func:Unit = println(s"Name = $name,  Born = $yearBorn")
     }

     def main(args:Array[String]): Unit = {
       val joe:Person = Person("Joe", 1963)
       joe.func  // PRINTS: Name = Joe,  Born = 1963
     }
   }

REPEAT:  A Scala method is ALWAYS bound to a class/object/trait.
         A Scala function is NEVER bound to a class/object/trait.

When Scala compiles code that becomes a function (code that you don't see),
the function becomes a Scala object named Function, which also extends
a trait corresponding to the number of arguments the function accepts.
These are the 23 trait names that the object Function can extend:

Function0  (If the function accepts 0 arguments.)
Function1  (If the function accepts 1 arguments.)
Function2  (If the function accepts 2 arguments.)
...
Function22  (If the function accepts 22 arguments, which is the maximum limit.)

A NOTE ABOUT SCALA FUNCTION DATA TYPES...
Every Scala function has a data type associated with it.  The data type of a function ALWAYS
contains the rocket symbol (=>).  On the LEFT SIDE of the rocket symbol (=>) is the data
type of each argument passed to the function.  On the RIGHT SIDE of the rocket symbol (=>)
is the data type returned by the function.

Examples of how a function's data type is written:
()=>Char                    (Data type of a function that accepts no arguments, returns a Char value.)
Int=>String                 (Data type of a function that accepts an Int argument, returns a String value.)
(Int,Char,Float)=>Boolean   (Data type of a function that accepts an Int, Char, Float argument, returns a Boolean value.)

A NOTE ABOUT PARAMETRIC (GENERIC) DATA TYPES...
Assume you define a method that accepts a number as an argument, squares that number,
and returns the result.  Typically, the argument passed to that method, and the
returned value, has a specific data type (i.e., an Int, a Float, a Double).  However,
Scala methods can be defined to accept parametric data types as arguments, and can
return a parametric data type.  (A parametric data type is also known as a generic
data type.)

For example, a method named squareNumber() could be defined to accept a generic
data type as an argument, and return a generic data type as a result.  So you
could pass squareNumber() an argument of any valid numeric type (Int, Float,
Double), and it would return that same data type as a result.

IMPORTANT:
Only Scala methods (NOT functions) can be written to accept and return paramatized
(generic) data types.  To learn more about generic data types, read this section:
https://github.com/w9mwi/Scala/blob/master/Parametric_Method



==========================================================================================

ETA EXPANSION
=============
An ETA EXPANSION is an operation that transforms a Scala method into a Scala function.
The following code sample demonstrates severals examples of how to perform an Eta
Expnansion on a method, thus transforming the method into a function.

object Demo
{
  def main(args:Array[String]): Unit =
  {
    // *********************************************************************
    // Define methods here that will be transformed into functions
    // further below by performing an ETA EXPANSION on them.
    def noArgumentMethod_1:Int = 123;
    def noArgumentMethod_2():Int = 123;
    def squareMethod(number: Float): Float = number * number
    def multiply2NumbersMethod(number_1: Float, number_2: Float): Float = number_1 * number_2

    // *********************************************************************
    // This section demonstrates how to perform an ETA EXPANSION on...
    // 1) noArgumentMethod_1 - A method defined WITHOUT parenthesis that accepts no argument.
    // 2) noArgumentMethod_2 - A method defined WITH parenthesis that accepts no argument.
    val func_1: () => Int = noArgumentMethod_1 _      // Underscore char (_) is REQUIRED.
    println(s"1) func_1.apply = ${func_1.apply}")     // PRINTS: 1) func_1.apply = 123
    println(s"2) func_1().toInt = ${func_1().toInt}") // PRINTS: 2) func_1().toInt = 123
    val func_2: () => Int = noArgumentMethod_2 _      // Underscore char (_) is OPTIONAL.
    println(s"3) func_2.apply = ${func_2.apply}")     // PRINTS: 3) func_2.apply = 123
    println(s"4) func_2().toInt = ${func_2().toInt}") // PRINTS: 4) func_2().toInt = 123

    // *********************************************************************
    // The following 3 assignments to the var squareFunction all perform
    // the same Eta Expansion.  It's done 3 times to show that when a
    // method contains ONLY ONE (1) ARGUMENT (like squareMethod), you
    // can perform the Eta Expansion without the underscore char, with the
    // underscore char, or with the underscore char enclosed in parenthesis.

    var squareFunction:(Float => Float) = squareMethod // Without underscore char.
    println(s"5) squareFunction(123.456F) = ${squareFunction(123.456F)}")
    // PRINTS: 5) squareFunction(123.456F) = 15241.384

    squareFunction = squareMethod _  // With underscore char.
    println(s"6) squareFunction(123.456F) = ${squareFunction(123.456F)}")
    // PRINTS: 6) squareFunction(123.456F) = 15241.384

    squareFunction = squareMethod(_)  // With underscore char. in parenthesis
    println(s"7) squareFunction(123.456F) = ${squareFunction(123.456F)}")
    // PRINTS: 7) squareFunction(123.456F) = 15241.384

    // *********************************************************************
    // Transform multiply2NumbersMethod() into a function via an ETA EXPANSION.
    // Notice the data type of multiply2NumbersFunction is written designating
    // that it accepts TWO ARGUMENTS.  Also note that when parenthesis are
    // included in the ETA EXPANSION, the ETA EXPANSION must be written to
    // designate that multiply2NumbersMethod accepts TWO ARGUMENTS, like this:
    // multiply2NumbersMethod(_, _)
    var multiply2NumbersFunction: (Float, Float) => Float = multiply2NumbersMethod
    println(s"8) multiply2NumbersFunction(123F, 456F) = ${multiply2NumbersFunction(123F, 456F)}")
    // PRINTS: 9) multiply2NumbersFunction(123F, 456F) = 56088.0

    multiply2NumbersFunction = multiply2NumbersMethod _
    println(s"9) multiply2NumbersFunction(123F, 456F) = ${multiply2NumbersFunction(123F, 456F)}")
    // PRINTS: 9) multiply2NumbersFunction(123F, 456F) = 56088.0

    multiply2NumbersFunction = multiply2NumbersMethod(_, _)
    println(s"10) multiply2NumbersFunction(123F, 456F) = ${multiply2NumbersFunction(123F, 456F)}")
    // PRINTS: 10) multiply2NumbersFunction(123F, 456F) = 56088.0

    // *********************************************************************
    // The Scala API contains hundreds of methods that accept a function as an argument.
    // For example, List.map() accepts a function as its argument.  But if you pass a
    // method to List.map(), Scala automatically transforms the method into a function.
    // This behavior is common in Scala.  If a method or a function accepts a function
    // as an argument, and it's easier to pass it a method, then pass it a method and
    // see if it works.  The following code demonstrates that List.map() works by passing
    // to it a method (squareMethod) or a function (squareFunction).
    var floatList: List[Float] = List(1.0F, 2.0F, 3.0F, 4.0F, 5.0F)
    // The following 2 lines are equivalent.  (The underscore (_) char is OPTIONAL.)
    floatList = floatList.map(squareMethod)
    floatList = floatList.map(squareMethod _)
    println(s"11) floatList = $floatList") // PRINTS: 11) floatList = List(1.0, 4.0, 9.0, 16.0, 25.0)
    floatList = floatList.map(squareFunction)
    println(s"12) floatList = $floatList") // PRINTS: 12) floatList = List(1.0, 16.0, 81.0, 256.0, 625.0)
  }
}

==========================================================================================

ANONYMOUS FUNCTION
==================

READ --> https://www.baeldung.com/scala/functions-methods

An anonymous function is a function that does not have a name, and is not
bound to a class/object/trait.  In the "FUNCTION" section above, we wrote
a function and assigned it to the val squareFunction, like this:

val squareFunction: (Float => Float) = { (number: Float) => number * number }

If only the code on the right side of the equal sign (=) existed, like this...

(number: Float) => number * number

...the program would still compile, but you'd never be able to call the function
because it has no name--it's an anonymous function.  When a method or a function
accepts a function as an argument, you can pass that argument a function in any
of these 3 ways:

1) Pass the argument a method that's been transformed into a function
   via an Eta Expansion.  (See the "ETA EXPANSION" section above.)

2) Pass the argument a val/var that points to a function, like the
   val squareFunction shown above.

3) Pass the argument an anonymous function.  So instead of passing the argument
   squareFunction, you could instead pass to the argument this code:

   (number: Float) => number * number

   Which is an anonymous function because it has no name.  Notice it's also
   the same code that defines the val squareFunction above.  THIS IS HOW
   ANONYMOUS FUNCTION ARE MOSTLY USED IN SCALA CODE.

The Scala API contains hundreds of methods that accept a function as an argument.
For example, List.map() requires a function to be passed as its argument.  When a
method/function accepts a function as an argument, you can pass the argument an
anonymous function, as the following example demonstrates.

NOTE: When an ANONYMOUS FUNCTION is written using the rocket symbol (=>)
      the token(s) on the left side of "=>" represents the argument(s)
      passed to the function.  The expression on the right side of "=>"
      is the algorithm that calculates the function's return value.
      The left side of "=>" must reference all arguments designated on
      the left side of "=>".  The following code sample demonstrates
      some examples of how to use anonymous functions.

object Demo
{
  def main(args: Array[String])
  {
    var floatList:List[Float] = List(1.0F, 2.0F, 3.0F, 4.0F, 5.0F)
    floatList = floatList.map(x => x * x) // Anonymous Function is: x => x * x
    println(s"floatList = $floatList") // PRINTS: floatList = List(1.0, 4.0, 9.0, 16.0, 25.0)

    // The following line defines an anonymous function, and assigns it to the var result.
    var result:(Int, Int) => Int = (a:Int, b:Int) => a+b  // Anonymous Function is: (a:Int, b:Int) => a+b

    // Both of the following 2 lines invoke the same function!
    println(result(222, 444))                  // PRINTS: 666
    println(((a:Int, b:Int) => a+b)(222, 444)) // PRINTS: 666

    // The following line defines an anonymous function, and assigns it to the var result.
    // This anonymous function is IDENTICAL to the one above, but its syntax is different.
    result = (_:Int)+(_:Int)  // // Anonymous Function is: (_:Int)+(_:Int)

    // Both of the following 2 lines invoke the same function!
    println(result(444, 222))            // PRINTS: 666
    println(((_:Int)+(_:Int))(444, 222)) // PRINTS: 666
  }
}

==========================================================================================

NULLARY FUNCTION
================
When a class constructor, a method, or a function accepts an argument, that argument
usually represents some basic data type (i.e., class, Int, String, etc.).  But an
argument can also accept a function.

The data type of any function ALWAYS includes the rocket symbol (=>).  The data type
on the left side of the rocket symbol (=>) is the data type of the argument(s) passed
to the function.  The data type on the right side of the rocket symbol (=>) is the
data type returned by the function.

The following are two example of a FUNCTION'S DATA TYPE:

Int=>String                              - The function accepts an Int argument, returns a String value.
(Boolean, Float, String)=>(Int, String)  - The function accepts 3 arguments, returns an (Int, String) tuple.

NULLARY FUNCTION DEFINITION - An argument passed to a class constructor, a method, or a function
                              that references a block of Scala code.

                              A block of Scala code NEVER has a data type, so there's NEVER any text
                              on the left side of the rocket (=>) symbol.  A block of code ALWAYS
                              returns a data type, which is specified on the right side of the
                              rocket (=>) symbol.  The data type returned is determined by the
                              last line of code executed in the code block.  If that last line
                              returns nothing, the return type is Unit.

Below are three examples of how to write the data type of a nullary function.  Notice that
the data type of a nullary function NEVER has any text before the rocket (=>) symbol.

=>String // Data type of an argument that references a nullary function, and returns a String value.
=>Double // Data type of an argument that references a nullary function, and returns a Double value.
=>Unit   // Data type of an argument that references a nullary function, and returns nothing.

It's important to understand the block of code is NOT executed when the argument gets passed
to the class constructor, method, or function.  Only the class constructor, the method, or
the function receiving the block of code argument can execute the block of code, which is
done by referencing the argument.

When passing a block of code to an argument, the block of code MUST be enclosed in braces {},
and NOT in parenthesis ().  The exception is a simple expression (such as "idx == 0"), which
can be passed between parenthesis () or between braces {}.

Nullary Function Example #1
===========================

object Demo
{
  // The blockOfCode argument passed to myMethod() references a NULLARY FUNCTION.
  def myMethod(blockOfCode: => Boolean): Unit = {
    // The following line executes the block of code passed to this method,
    // and assigns its returned value to the val result.
    val result: Boolean = blockOfCode

    if (result == true)
      println("blockOfCode returned true.")
    else
      println("blockOfCode returned false.")
  }

  def main(args: Array[String]): Unit = {
    // Call myMethod() by passing a block of Scala code to its argument.
    // NOTE: The block of Scala code MUST be enclosed by braces {}.
    myMethod {
      val number = 123
      if (number == 123)
        true
      else false
    }
  }
}


Nullary Function Example #2
===========================

object Demo
{
  class LoopUntilCond_1(blockOfCode: => Unit)
  {
    // This until() method accepts a nullary function (a block of code) as its argument.
    def until(cond: => Boolean): Unit = {
      blockOfCode // Execute the block of code passed to this LoopUntilCond_1 class instance.
      if (false == cond)
        until(cond) // Recursively call the until() method until the "cond" argument evaluates to true.
    }
  }
  // Invoking this loop_1() method returns an instance of the LoopUntilCond_1 class.
  def loop_1(blockOfCode: => Unit):LoopUntilCond_1 = { new LoopUntilCond_1(blockOfCode) }

  def main(args: Array[String]): Unit = {
    // **************************************************************************************
    // EXAMPLE #1 - Demonstrates passing a nullary function (a block of code)
    //              as an argument to a method.
    //
    // The following code is explained in these 3 steps...
    // 1) The loop_1() method gets passed a block of Scala code between a pair of braces {}.
    // 2) The loop_1() method returns an instance of the LoopUntilCond_1 class,
    //    which also gets passed the same block of Scala code.
    // 3) Because the loop_1() method returns an instance of the LoopUntilCond_1 class,
    //    the LoopUntilCond_1.until() method can be invoked in the same line of code.
    var idx:Int = 5
    loop_1 {
      print("idx = " + idx + ", ") // PRINTS: idx = 5, idx = 4, idx = 3, idx = 2, idx = 1,
      idx -= 1
    } until idx == 0 // This line can be rewritten like this:   }.until(idx == 0)

    println()

    // **************************************************************************************
    // EXAMPLE #2 - Identical behavior to EXAMPLE #1 above.  But it's written so the
    //              LoopUntilCond_1 class (returned by invoking the loop_1() method)
    //              gets assigned to the val myLoop.
    idx = 5 // Reset the idx var.
    val myLoop:LoopUntilCond_1 = loop_1 {
      print("idx = " + idx + ", ")
      idx -= 1
    }
    myLoop.until(idx == 0)  // Can also be written:  myLoop.until{idx == 0}
  }
}

==========================================================================================
==========================================================================================
==========================================================================================

The following code sample shows another example of transforming
a regular function into a curried function by first performing
an ETA EXPANSION on it by adding the underscore (_) character,
and then calling Scala's .curried() method.

object Demo
{
  def main(args: Array[String])
  {
    // The add_1() function is a regular/normal function.
    // The first time the add_1() is called here, it's
    // called in the usual way....
    println("add_1(7, 3) = " + add_1(7, 3)) // PRINTS: add_1(7, 3) = 10

    // Perform an "Eta Expansion" on add_1() by using the underscore (_) character...
    val addFunc:((Int, Int) => Int) = add_1 _

    val addFuncCurried:(Int => (Int => Int)) = addFunc.curried // Make the add_1() function a curried function.
    println("addFuncCurried(7)(3) = " + addFuncCurried(7)(3)) // PRINTS: addFuncCurried(7)(3) = 10

    // addFuncCurried called with one param returns a PARTIALLY APPLIED function...
    val partiallyAppliedCurried:(Int => Int) = addFuncCurried(7)
    // Call partiallyAppliedCurried to make addFuncCurried FULLY APPLIED...
    println("partiallyAppliedCurried(3) = " + partiallyAppliedCurried(3)) // PRINTS: partiallyAppliedCurried(3) = 10

    // *****************************************************************************************
    // The add_2()() function called below is a curried function,
    // and can be called in the following two (2) ways...
    //
    // 1) Call sum_2()() once by passing to it both Int params, so it
    //    returns an Int result...
    println("add_2(7)(3) = " + add_2(7)(3)) // PRINTS: add_2(7)(3) = 10

    // 2) Call sum_2()() twice...  sum_2()() is called the first time by
    //    initializing its x Int parameter, and it returns a function.
    //    (At this point, the sum_2()() function is PARTIALLY APPLIED)
    //    Then, sum_2()() is called the second time by initializing
    //    its y Int parameter so it will now return an Int value.
    //    (At this point, the sum_2()() function is FULLY APPLIED.)
    val func:(Int => Int) = add_2(7)(_) // The func function is PARTIALLY APPLIED here.
    println("func(3) = " + func(3)) // PRINTS: func(3) = 10  (func is now FULLY APPLIED.)
  }

  /**
   * This add_1() function is a normal function, NOT a curried function.
   */
  def add_1(x:Int, y:Int):Int = { x + y }

  /**
   * This add_2() function is a CURRIED FUNCTION because
   * it takes multiple arguments, and returns a function
   * that takes a single argument.
   */
  def add_2(x:Int) = { (y:Int) => x + y }
}

========================================================================================
The following program shows another example of how functions and methods are used.

object Demo
{
  def main(args: Array[String]): Unit =
  {
    // The twice_1 method and the twice_2 function defined below have
    // IDENTICAL SIGNATURES AND IDENTICAL BEHAVIOR.  twice_1 and twice_2
    // both accept a function (named "func") as the first argument, and
    // "number" as the second argument.  The func() function is then
    // performed on number, which becomes the returned result.
    def twice_1(func:Double=>Double, number:Double):Double = { func(func(number)) }
    val twice_2:(Double=>Double, Double)=>Double = { (func:Double=>Double, number:Double) => func(func(number)) }

    // EXPLANATION: In the following call to twice_1()...
    //              1) The "_ + 1" is a function that gets passed to the "func" argument of
    //                 twice_1(), and 5 gets passed to the "number" argument of twice_1().
    //              2) The underscore (_) references the "number" argument passed
    //                 to twice_1(), which is the number 5.
    //              3) twice_1() returns this expression:  func(func(5))
    //                 First, func(5) returns:  (5.0 + 1.0) = 6.0
    //                 Next, func(6.0) is called, which returns this final value:  (6.0 + 1.0) = 7.0
    var result:Double = twice_1(_ + 1, 5)
    println(s"result #1 = $result") // PRINTS: result #1 = 7.0

    // The EXPLANATION given above for what happens when twice_1() gets called
    // applies equally to what happens when twice_2() is called below.
    result = twice_2(_ + 1, 5)
    println(s"result #2 = $result") // PRINTS: result #2 = 7.0
  }
}

========================================================================================
PARTIAL FUNCTIONS - PART 1 of 3

DON'T confuse partial functions with partially-applied functions!  Partial functions
are NOT related to, or similar to, partially-applied functions.  Partial functions
and partially-applied functions are totally unrelated, and totally different from
each other.

A Scala partial function is a function that returns values for
only a specific set of values passed to it.  A partial function
DOESN'T return anything when it's passed an invalid value.

EXAMPLE: If a partial function performs mathematical division on
         a number passed to it, NO RESULT WILL BE RETURNED when
         that number is zero; because dividing by zero is invalid.

Implementing a partial function in Scala requires the programmer
to define these two methods:
1) apply()       - Automatically called when you pass the function an argument.
2) isDefinedAt() - This method returns a Boolean true for all valid values passed
                   to it.  It returns false for invalid values passed to it.

object Demo
{
  // The [Int, Int] below means you pass the PartialFunction
  // an Int argument, and it returns an Int.
  val dividePF = new PartialFunction[Int, Int]
                 {
                   def apply(number:Int):Int = { 124 / number }
                   // The isDefined() method defines the valid/invalid values.
                   // In this example all Int values are valid except zero.
                   def isDefinedAt(number:Int):Boolean = { number != 0 }
                 }

  def main(args: Array[String])
  {
    // It's possible to call a partial function directly, like this...
    var intValue:Int = dividePF(6)   // Calls the PartialFunction.apply() method.
    println(s"intValue = $intValue") // PRINTS: intValue = 20

    // However, it make sense no sense to call a partial function directly
    // because if you pass it an undefined value, it won't return anything.
    // The following 2 lines of commented-out code will compile, but they'll
    // throw an ArithmeticException because dividePF(0) doesn't return anything.
    // dividePF(0)
    // intValue = dividePF(0)

    // The Scala API contains some methods that accept a partial function
    // as an argument.  That is where partial functions should be used.
    // List.collect is a Scala API method that accepts a partial function.
    var intList:List[Int] = List(0,1,2,4)
    intList = intList.collect{ dividePF }
    println(s"intList = $intList") // PRINTS: intList = List(124, 62, 31)
  }
}

========================================================================================
PARTIAL FUNCTIONS - PART 2 OF 3

object Demo
{
  // NOTICE: In the above example the PartialFunction definition requires
  //         the apply() and isDefinedAt() methods to be defined.  But in the
  //         below example the PartialFunction definition requires only
  //         a case statement.  Because a single case statement effectively
  //         contains the isDefinedAt() and apply() methods.  In the "val Case1"
  //         declaration below:  isDefinedAt() = if (x % 3) != 0
  //                             isApply()     = The entire "case x" statement.
  val Case1:PartialFunction[Int, String] =
  { case x if (x % 3) != 0 => "odd" }

  val Case2:PartialFunction[Int, String] =
  { case y if (y % 2) == 0 => "even" }

  // NOTE: orElse is a method defined in the PartialFunction trait that's
  //       used as an operator on two PartialFunctions.  The following line
  //       of code could also be written like this:  Case1.orElse(Case2)
  val evenOrOdd:PartialFunction[Int, String] = Case1 orElse Case2

  def main(args: Array[String])
  {
    var x:Int = 324
    var result:String = evenOrOdd(x).toString + "."
    println(s"The number $x is $result") // PRINTS: The number 324 is even.

    x = 325
    result = evenOrOdd(x).toString + "."
    println(s"The number $x is $result") // PRINTS: The number 324 is odd.
  }
}

========================================================================================
PARTIAL FUNCTIONS - PART 3 OF 3

object Demo
{
  def main(args: Array[String])
  {
    // Like the 2 PartialFunctions defined in the above example, here we define
    // the operation1 PartialFunction with a single case statement, instead
    // of needing to define the apply() and isDefinedAt() methods.
    val operation1:PartialFunction[Int, Int] = { case x if (x%4 != 0) => x*42 }
    val operation2:(Int=>Int)                = (x: Int) => x/3
    // NOTE: andThen is a method defined in the PartialFunction trait.
    //       andThen is used as an operator.  The following line of code
    //       could also be written like this:  operation1.andThen(operation1)
    val op = operation1 andThen operation2
    // *****************************************************************
    var intValue = 34
    // When op(intValue) is called is called below, these operations occur...
    // operation1:  x%4 = ((34/4) = 8) is NOT zero, so (34*42) = 1428
    // andThen
    // operation2:  x/3 = 1428/3 = 476
    println(s"Initial value = $intValue.\nValue after operations = " + op(intValue))
    // PRINTS:
    // Initial value = 34.
    // Value after operations = 476
    // *****************************************************************
    // *****************************************************************
    intValue = 40
    // When op(intValue) is called below, these operations occur...
    // operation1:  x%4 = ((40/4) = 0) IS zero, so NOTHING IS RETURNED by operation1.
    //              So operation2 is NOT invoked.  NOTHING IS RETURNED, period!
    //              Therefore, the following commented-out line will throw a
    //              MatchError exception if it's not commented out.
    // op(intValue)
    // *****************************************************************
    // *****************************************************************
    // When intList.collect(op) is called below, nothing is returned
    // for elements 8, 12, 40, 44.  Only elements 45 and 77 result
    // in returned values.
    var intList:List[Int] = List (8, 12, 40, 44, 45, 77)
    intList = intList.collect(op)
    println(s"intList = $intList") // PRINTS: intList = List(630, 1078)
  }
}

========================================================================================
ANONYMOUS FUNCTIONS - Some examples below.

object Demo
{
  def main(args: Array[String]): Unit = {
    // EXAMPLE 1 **************************************************************************
    case class StringToInt(run:String => Int)
    // Instantiate a StringToInt class by passing to it an anonymous function,
    // which will get assigned to its member val named "run".
    // NOTE: You could replace this text: StringToInt(x => x.toInt)
    //       with this text:              StringToInt{ str:String => str.toInt }
    val myClass_1:StringToInt = StringToInt(x => x.toInt)
    var myInt:Int = myClass_1.run("-777") // "run" is a val member of myClass_1.
    println(s"myInt #1 = $myInt") // PRINTS: result #1 = -777

    // This time we pass stringToInt() a defined function named: myStrLengthFunc
    def myStrLengthFunc(str:String):Int = { str.length }
    val valFunc_1:StringToInt = StringToInt(myStrLengthFunc)
    myInt = valFunc_1.run("Madison, Wisconsin")
    println(s"myInt #2 = $myInt") // PRINTS: myInt #2 = 18

    // EXAMPLE 2 **************************************************************************
    case class TwoStringsToInt[A,B](func:(A,A) => B)
    val anonFunc = (a:String, b:String) => (a.length + b.length)
    val myClass_2:TwoStringsToInt[String, Int] = TwoStringsToInt(anonFunc)
    // func is a member val of the TwoStringsToInt class, created upon instantiation of TwoStringsToInt.
    myInt = myClass_2.func("Madison", "Wisconsin")
    println(s"myInt #3 = $myInt") // PRINTS: myInt #3 = 16
  }
}

========================================================================================

FUNCTIONS BUILT WITH ONLY CASE STATEMENTS
=========================================
It's possible to write a Scala function where the body of the function consists
of nothing but case statements, and the "match" keyword isn't used.  Below is
an example.  Read in-line comments for details.

object Demo {
  def main(args: Array[String]) {
    // Declare a function where its body contains only case statements,
    // and the "match" keyword is NOT used.  In this example, the function
    // gets passed the "Any" data type, returns a String.
    val func: (Any => String) = { // Assigns the function to the val func.
      case d: Double => "Double"
      case f: Float  => "Float"
      case i: Int    => "Int"
      case s: String => "String"
      case _         => "Other"
    }
    println(func('X'))       // PRINTS: Other
    println(func(123.456D))  // PRINTS: Double
    println(func(-98.76F))   // PRINTS: Float
    println(func(12345))     // PRINTS: Int
    println(func("Jupiter")) // PRINTS: String

    // The following code exists only to remind how
    // case statements are used with the "match"
    // keyword to perform pattern matching.
    val number: Int = 3
    val result: String = number match {
      case 1 => "One"
      case 2 => "Two"
      case 3 => "Three"
      case _ => "Other"
    }
    println(s"result = $result") // PRINTS: result = Three
  }
}


  /*****
    // The List.collect method accepts a PARTIAL FUNCTION as an argument.
    // A PARTIAL FUNCTION executes for some values, but not all values.
    // The case statement passed to List.collect below is a PARTIAL FUNCTION,
    // as it returns a value ONLY for intList elements NOT equal to zero.
    var intList:List[Int] = List(0,1,2,4)
    intList = intList.collect{ case i: Int if i != 0 => 42 / i }
    println(s"intList = $intList") // PRINTS: intList = List(42, 21, 10)

    // In this section List.collect is called with the same PARTIAL FUNCTION
    // case statement as above.  However, because all elements in intList
    // are zero, List.collect returns List(), which is an EMPTY List..
    intList = List(0,0,0,0)
    intList = intList.collect{ case i: Int if i != 0 => 42 / i }
    println(s"intList = $intList") // PRINTS: intList = List()

    // In this section the List.map method is called, which accepts a regular
    // function, NOT a partial function.  However, List.map can still accept
    // a case statement as its function.  But unlike the case statement
    // passed to List.collect() above, the below case statement ALWAYS
    // returns a value, which means it's NOT a partial function.
    var strList:List[String] = List("Jupiter", "Uranus", "Neptune")
    var result:List[Boolean] = strList.map{ case s: String => s.length > 6 }
    println(s"result = $result") // PRINTS: result = List(true, false, true)

    // The following function passed to List.map is a more common way of
    // calling List.map, and it returns the identical result as the
    // case statement used in the previous example.
    result = strList.map(_.length > 6)
    println(s"result = $result") // PRINTS: result = List(true, false, true)
  }
}
*****/

========================================================================================
