The words "method" and "function" are often used interchangeably.
However, in Scala there are important differences between a method
and a function.

Method - A Scala method is bound to a class/object/trait.  In other
         words, a method IS A MEMBER of a class/object/trait.
         A Scala method is ALWAYS created using the "def" keyword.
         A Scala method can be transformed into a Scala function by
         performing an ETA EXPANSION on the method.  The code sample
         below performs an ETA EXPANSION on some methods, so you can
         see how this is done.

Function - A Scala function is NOT bound to a class/object/trait.
           You CAN'T create a Scala function using the "def" keyword,
           because using the "def" keyword makes it a method.  The
           code sample below shows examples of how to write both Scala
           methods and Scala functions.

A Scala function CAN'T be written to accept parameterized (generic) arguments.
A Scala method (which is created with the "def" keyword) can be written to
accept parameterized (generic) arguments, like this:

def firstChar[A](a: A) = { a.toString.charAt(0) }  // Works with arguments of type Double, Float, Int, String, etc.

IMPORTANT: To distinguish a Scala function from a Scala method, LOOK AT ITS SIGNATURE!

           A Scala method's signature will look similar to this:
           (Int):Int  -  The method takes an Int argument, and returns an Int value.

           A Scala function's signature will ALWAYS include the rocket symbol (=>),
           and will look similar to this:
           Int=>Int  -  The function takes an Int argument, and returns an Int value.

========================================================================================

object Demo
{
  def main(args: Array[String])
  {
    // ********************************************************************
    // When the "def" keyword is used, a method (not a function) is created.
    // Therefore, squareMethod is a METHOD, not a function.
    def squareMethod(number:Int):Int = number*number
    val numberList:List[Int] = List(1, 2, 3, 4, 5)

    // Many Scala methods REQUIRE A FUNCTION to be passed as an argument.
    // EXAMPLE: The List.map method called below is defined to accept a
    //          function as its argument, NOT a method.  But in the code
    //          below we pass a method to List.map and it works because
    //          Scala automatically converts the method into a function.
    // In most cases you can pass an argument to a method, when it expects
    // a function, and it'll work because Scala will automatically convert
    // the method into a function.  The following call to the List.map()
    // method demonstrates this because it gets passed a method even
    // though it expects a function.
    var listResult:List[Int] = numberList.map(squareMethod)
    println(s"listResult 1) = $listResult") // PRINTS: listResult 1) = List(1, 4, 9, 16, 25)
    // ********************************************************************

    // ********************************************************************
    // THERE ARE THREE (3) WAYS TO WRITE A FUNCTION:
    // 1) Upon declaring a val/var, assign a function to it.
    val squareFunction:(Int=>Int) = { (number:Int) => number*number }
    listResult = numberList.map(squareFunction)
    println(s"listResult 2) = $listResult") // PRINTS: listResult 2) = List(1, 4, 9, 16, 25)
    //
    // 2) Pass an anonymous function (i.e., x=>x*x) as the argument to a method.
    listResult = numberList.map(x=>x*x)
    println(s"listResult 3) = $listResult") // PRINTS: listResult 3) = List(1, 4, 9, 16, 25)
    //
    // 3) Transform a Scala method into a function via an ETA EXPANSION.
    //    The following 3 lines of code all perform an ETA EXPANSION on
    //    squareMethod, which transforms it into a function.  It makes
    //    no difference which syntax (shown in the 3 lines below) you
    //    choose to use.
    val squareFunction2A:(Int=>Int) = squareMethod
    val squareFunction2B            = squareMethod _
    val squareFunction2C            = squareMethod(_)
    var intResult:Int = squareFunction2A(7)
    println(s"intResult 1) = $intResult") // PRINTS: intResult 1) = 49
    intResult = squareFunction2B(8)
    println(s"intResult 2) = $intResult") // PRINTS: intResult 2) = 64
    intResult = squareFunction2C(9)
    println(s"intResult 3) = $intResult") // PRINTS: intResult 3) = 81
    // ********************************************************************
  }
}

========================================================================================

object Demo
{
  def main(args: Array[String])
  {
    // THE FOLLOWING TEXT IS ALL ABOUT THE makeSentence() METHOD IMMEDIATELY BELOW.
    // When a method's definition contains an asterisk (*) in its argument list,
    // it designates that it can be called with a variable number of arguments.
    // In the below makeSentence method, the asterisk (*) is preceded with the data
    // type "String".  Therefore, this makeSentence method MUST get passed one or
    // more String arguments when it's called.  That part is easy to understand.
    //
    // When you inspect the argument named "words" in the makeSentence definition,
    // you'll discover its data type is Seq[String].  That's confusing because the
    // "words" argument is defined to have data type of String*.  When Scala sees
    // an asterisk (*) after the data type String, Scala translates that into a
    // data type of Seq[String], which makes sense because String* is NOT a
    // valid data type.
    //
    // Although Scala assigns a data type of Seq[String] to the "words" argument in
    // makeSentence, you CAN'T pass makeSentence an argument of type Seq[String].
    // WHY NOT?...  Because when an argument is defined with an asterisk (*) char,
    // Scala forces the method to accept ONLY arguments of the data type preceding
    // the asterisk (*) char--in this example the data type is String.  ONLY AFTER
    // string arguments are passed to makeSentence does Scala build the "words"
    // argument (from the strings) and assign it the data type Seq[String].
    //
    // In the next sample program (below this one) we'll transform makeSentence
    // from a method into a FUNCTION via an ETA EXPANSION.  Then makeSentence
    // will accept a single Seq[String] argument instead of a variable number
    // of string arguments.  So we'll be able to call makeSentence by passing
    // it a single List[String] instead of multiple string arguments.
    //
    // Since "words" is of type Seq[String], we must call words.mkString
    // to convert that Seq[String] data type into a single string, which
    // gets returned.
    def makeSentence(words:String*):String = words.mkString(" ") + "."

    // Call makeSentence() to test it...
    var strResult = makeSentence("Make", "these", "words", "into", "a", "single", "sentence")
    println(s"strResult 1) = $strResult")
    // PRINTS:  strResult 1) = Make these words into a single sentence.

    // Next, perform an ETA EXPANSION on makeSentence.  This will transform
    // makeSentence into a function that takes a single Seq[String] as an
    // argument, and returns a string.  NOTE: A List[String] data type
    // also works because its a child of the Seq[String] data type.
    val listOfWords:List[String] = List("Tomorrow", "is", "a", "different", "day")
    val etaExpand:(Seq[String]=>String) = makeSentence
    strResult = etaExpand(listOfWords)
    println(s"strResult 2) = $strResult")
    // PRINTS: strResult 2) = Tomorrow is a different day.
  }
}

========================================================================================

    val f: (Any) => String = {
      case i: Int => "Int"
      case d: Double => "Double"
      case s: String => "String"
      case _ => "Other"
    }
    println(f("123.456D"))

========================================================================================
