The words "method" and "function" are often used interchangeably.
However, in Scala there are important differences between a method
and a function.

This section also demonstrates the use of VARARGS (Variable
number of arguments).  For more information on VARARGS, see
the section titled:  Variable_No_Of_Args
SEE --> https://github.com/w9mwi/Scala/edit/master/Variable_No_Of_Args

Method - A Scala method is bound to a class/object/trait.  In other
         words, a method IS A MEMBER of a class/object/trait.
         A Scala method is ALWAYS created using the "def" keyword.
         A Scala method can be transformed into a Scala function by
         performing an ETA EXPANSION on the method.  The code sample
         below performs an ETA EXPANSION on some methods, so you can
         see how this is done.

Function - A Scala function is NOT bound to a class/object/trait.  You
           CAN'T create a Scala function using the "def" keyword because
           using the "def" keyword makes it a method.  A function CAN be
           assigned to a val/var, a method CAN'T be assigned to a val/var.
           
The code samples below shows examples of how to write both Scala methods
and Scala functions.

A Scala function CAN'T be written to accept parameterized (generic) arguments.
A Scala method (which is created with the "def" keyword) CAN be written to
accept parameterized (generic) arguments, like this:

// firstChar works with args of type Double, Float, Int, String, etc.
def firstChar[A](a: A) = { a.toString.charAt(0) }

IMPORTANT: To distinguish a Scala function from a Scala method LOOK AT THE SIGNATURE!

           A Scala function's signature will ALWAYS include the rocket symbol (=>),
           and will look similar to this:
           Int=>Int  -  The function takes an Int argument, and returns an Int value.

           A Scala method's signature will look similar to this:
           (Int):Int  -  The method takes an Int argument, and returns an Int value.


========================================================================================

object Demo
{
  def main(args: Array[String])
  {
    // ********************************************************************
    // When the "def" keyword is used, a method (not a function) is created.
    // Therefore, squareMethod is a METHOD, not a function.
    def squareMethod(number:Int):Int = number*number
    val numberList:List[Int] = List(1, 2, 3, 4, 5)

    // Many Scala methods REQUIRE A FUNCTION to be passed as an argument.
    // EXAMPLE: The List.map method called below is defined to accept a
    //          function as its argument, NOT a method.  But in the code
    //          below we pass a method to List.map and it works because
    //          Scala automatically converts the method into a function.
    // When a Scala method is defined to accept a function as an argument,
    // you can usually pass a method instead and it'll work because Scala
    // will automatically convert the method into a function.  The following
    // call to the List.map() method demonstrates this because it gets
    // passed a method, even though its API documentation says it accepts
    // a function argument.
    var listResult:List[Int] = numberList.map(squareMethod)
    println(s"listResult 1) = $listResult") // PRINTS: listResult 1) = List(1, 4, 9, 16, 25)
    // ********************************************************************

    // ********************************************************************
    // THERE ARE THREE (3) WAYS TO WRITE A FUNCTION:
    // 1) Upon declaring a val/var, assign a function to it.
    val squareFunction:(Int=>Int) = { (number:Int) => number*number }
    listResult = numberList.map(squareFunction)
    println(s"listResult 2) = $listResult") // PRINTS: listResult 2) = List(1, 4, 9, 16, 25)
    //
    // 2) Pass an anonymous function (i.e., x=>x*x) as the argument to a method.
    listResult = numberList.map(x=>x*x)
    println(s"listResult 3) = $listResult") // PRINTS: listResult 3) = List(1, 4, 9, 16, 25)
    //
    // 3) Transform a Scala method into a function via an ETA EXPANSION.
    //    The following 3 lines of code all perform an ETA EXPANSION on
    //    squareMethod, which transforms it into a function.  It makes
    //    no difference which syntax (shown in the 3 lines below) you
    //    choose to use.
    val squareFunction2A:(Int=>Int) = squareMethod
    val squareFunction2B            = squareMethod _
    val squareFunction2C            = squareMethod(_)
    var intResult:Int = squareFunction2A(7)
    println(s"intResult 1) = $intResult") // PRINTS: intResult 1) = 49
    intResult = squareFunction2B(8)
    println(s"intResult 2) = $intResult") // PRINTS: intResult 2) = 64
    intResult = squareFunction2C(9)
    println(s"intResult 3) = $intResult") // PRINTS: intResult 3) = 81
    // ********************************************************************
  }
}

========================================================================================
ETA EXPANSION - The above code sample shows some examples of ETA EXPANSION.
                The below code shows another example of an ETA EXPANSION.

object Demo
{
  def main(args: Array[String])
  {
    // THIS TEXT IS ALL ABOUT THE makeSentence() METHOD IMMEDIATELY BELOW.
    // When a method's definition contains an asterisk (*) in its argument list,
    // it designates that it can be called with a variable number of arguments.
    // In the below makeSentence method, the asterisk (*) is preceded with the data
    // type "String".  Therefore, this makeSentence method MUST get passed one or
    // more String arguments when it's called.  That part is easy to understand.
    //
    // When you inspect the argument named "words" in the makeSentence definition,
    // you'll discover its data type is Seq[String].  That's confusing because the
    // "words" argument is defined to have data type of String*.  When Scala sees
    // an asterisk (*) after the data type String, Scala translates that into a
    // data type of Seq[String], which makes sense because String* is NOT a
    // valid data type.
    //
    // Although Scala assigns a data type of Seq[String] to the "words" argument in
    // makeSentence, you CAN'T pass makeSentence an argument of type Seq[String].
    // WHY NOT?...  Because when an argument is defined with an asterisk (*) char,
    // Scala forces the method to accept ONLY arguments of the data type preceding
    // the asterisk (*) char--in this example the data type is String.  ONLY AFTER
    // string arguments are passed to makeSentence does Scala build the "words"
    // argument (from the strings) and assign it the data type Seq[String].
    //
    // In the next sample program (below this one) we'll transform makeSentence
    // from a method into a FUNCTION via an ETA EXPANSION.  Then makeSentence
    // will accept a single Seq[String] argument instead of a variable number
    // of string arguments.  So we'll be able to call makeSentence by passing
    // it a single List[String] instead of multiple string arguments.
    //
    // Since "words" is of type Seq[String], we must call words.mkString
    // to convert that Seq[String] data type into a single string, which
    // gets returned.
    def makeSentence(words:String*):String = words.mkString(" ") + "."

    // Call makeSentence() to test it...
    var strResult = makeSentence("Make", "these", "words", "into", "a", "single", "sentence")
    println(s"strResult 1) = $strResult")
    // PRINTS:  strResult 1) = Make these words into a single sentence.

    // Next, perform an ETA EXPANSION on makeSentence.  This will transform
    // makeSentence into a function that takes a single Seq[String] as an
    // argument, and returns a string.  NOTE: A List[String] data type
    // also works because its a child of the Seq[String] data type.
    val listOfWords:List[String] = List("Tomorrow", "is", "a", "different", "day")
    val etaExpand:(Seq[String]=>String) = makeSentence
    strResult = etaExpand(listOfWords)
    println(s"strResult 2) = $strResult")
    // PRINTS: strResult 2) = Tomorrow is a different day.
  }
}

========================================================================================
ANONYMOUS FUNCTION - Read in-line comments in sample code below.

object Demo
{
  def main(args: Array[String])
  {
    // The var result is assigned an anonymous function, which has this signature:  (Int, Int) => Int
    var result:(Int, Int) => Int = (a:Int, b:Int) => a+b
    println(result(222, 444)) // PRINTS: 666

    // Here result is again assinged an anonymous function.  This anonymous function is
    // IDENTICAL to the one above.  Howvever, the syntax used to define it is different.
    result = (_:Int)+(_:Int)
    println(result(123, 321)) // PRINTS: 444
  }
}

========================================================================================
PARTIAL FUNCTIONS - PART 1 of 3

DON'T confuse partial functions with partially-applied functions!  Partial functions
are NOT related to, or similar to, partially-applied functions.  Partial functions
and partially-applied functions are totally unrelated, and totally different from
each other.

A Scala partial function is a function that returns values for
only a specific set of values passed to it.  A partial function
DOESN'T return anything when it's passed an invalid value.

EXAMPLE: If a partial function performs mathematical division on
         a number passed to it, NO RESULT WILL BE RETURNED when
         that number is zero; because dividing by zero is invalid.

Implementing a partial function in Scala requires the programmer
to define these two methods:
1) apply()       - Automatically called when you pass the function an argument.
2) isDefinedAt() - This method returns a Boolean true for all valid values passed
                   to it.  It returns false for invalid values passed to it.

object Demo
{
  // The [Int, Int] below means you pass the PartialFunction
  // an Int argument, and it returns an Int.
  val dividePF = new PartialFunction[Int, Int]
                 {
                   def apply(number:Int):Int = { 124 / number }
                   // The isDefined() method defines the valid/invalid values.
                   // In this example all Int values are valid except zero.
                   def isDefinedAt(number:Int):Boolean = { number != 0 }
                 }

  def main(args: Array[String])
  {
    // It's possible to call a partial function directly, like this...
    var intValue:Int = dividePF(6)   // Calls the PartialFunction.apply() method.
    println(s"intValue = $intValue") // PRINTS: intValue = 20

    // However, it make sense no sense to call a partial function directly
    // because if you pass it an undefined value, it won't return anything.
    // The following 2 lines of commented-out code will compile, but they'll
    // throw an ArithmeticException because dividePF(0) doesn't return anything.
    // dividePF(0)
    // intValue = dividePF(0)

    // The Scala API contains some methods that accept a partial function
    // as an argument.  That is where partial functions should be used.
    // List.collect is a Scala API method that accepts a partial function.
    var intList:List[Int] = List(0,1,2,4)
    intList = intList.collect{ dividePF }
    println(s"intList = $intList") // PRINTS: intList = List(124, 62, 31)
  }
}

========================================================================================
PARTIAL FUNCTIONS - PART 2 OF 3

object Demo
{
  // NOTICE: In the above example the PartialFunction definition requires
  //         the apply() and isDefinedAt() methods to be defined.  But in the
  //         below example the PartialFunction definition requires only
  //         a case statement.  Because a single case statement effectively
  //         contains the isDefinedAt() and apply() methods.  In the "val Case1"
  //         declaration below:  isDefinedAt() = if (x % 3) != 0
  //                             isApply()     = The entire "case x" statement.
  val Case1:PartialFunction[Int, String] =
  { case x if (x % 3) != 0 => "odd" }

  val Case2:PartialFunction[Int, String] =
  { case y if (y % 2) == 0 => "even" }

  // NOTE: orElse is a method defined in the PartialFunction trait that's
  //       used as an operator on two PartialFunctions.  The following line
  //       of code could also be written like this:  Case1.orElse(Case2)
  val evenOrOdd:PartialFunction[Int, String] = Case1 orElse Case2

  def main(args: Array[String])
  {
    var x:Int = 324
    var result:String = evenOrOdd(x).toString + "."
    println(s"The number $x is $result") // PRINTS: The number 324 is even.

    x = 325
    result = evenOrOdd(x).toString + "."
    println(s"The number $x is $result") // PRINTS: The number 324 is odd.
  }
}

========================================================================================
PARTIAL FUNCTIONS - PART 3 OF 3

object Demo
{
  def main(args: Array[String])
  {
    // Like the 2 PartialFunctions defined in the above example, here we define
    // the operation1 PartialFunction with a single case statement, instead
    // of needing to define the apply() and isDefinedAt() methods.
    val operation1:PartialFunction[Int, Int] = { case x if (x%4 != 0) => x*42 }
    val operation2:(Int=>Int)                = (x: Int) => x/3
    // NOTE: andThen is a method defined in the PartialFunction trait.
    //       andThen is used as an operator.  The following line of code
    //       could also be written like this:  operation1.andThen(operation1)
    val op = operation1 andThen operation2
    // *****************************************************************
    var intValue = 34
    // When op(intValue) is called is called below, these operations occur...
    // operation1:  x%4 = ((34/4) = 8) is NOT zero, so (34*42) = 1428
    // andThen
    // operation2:  x/3 = 1428/3 = 476
    println(s"Initial value = $intValue.\nValue after operations = " + op(intValue))
    // PRINTS:
    // Initial value = 34.
    // Value after operations = 476
    // *****************************************************************
    // *****************************************************************
    intValue = 40
    // When op(intValue) is called below, these operations occur...
    // operation1:  x%4 = ((40/4) = 0) IS zero, so NOTHING IS RETURNED by operation1.
    //              So operation2 is NOT invoked.  NOTHING IS RETURNED, period!
    //              Therefore, the following commented-out line will throw a
    //              MatchError exception if it's not commented out.
    // op(intValue)
    // *****************************************************************
    // *****************************************************************
    // When intList.collect(op) is called below, nothing is returned
    // for elements 8, 12, 40, 44.  Only elements 45 and 77 result
    // in returned values.
    var intList:List[Int] = List (8, 12, 40, 44, 45, 77)
    intList = intList.collect(op)
    println(s"intList = $intList") // PRINTS: intList = List(630, 1078)
  }
}

SEE ALSO:
https://www.geeksforgeeks.org/partial-functions-in-scala/
https://www.includehelp.com/scala/partial-functions.aspx#:~:text=Scala%20partial%20functions%20A%20partial%20function%20is%20a,are%20allowed%20in%20the%20processing%20of%20the%20code.

========================================================================================
OBSCURE WAYS FUNCTIONS CAN BE USED - Read in-line comments if the following code sample.


object Demo
{
  def main(args: Array[String])
  {
    // Here we declare a function that gets passed the "Any" Scala data type, and
    // returns a String.  NOTICE: It's possible to implement case statements within
    // a function without using the "match" keyword!
    val func:(Any=>String) =
    {
      case d:Double => "Double"
      case f:Float  => "Float"
      case i:Int    => "Int"
      case s:String => "String"
      case _        => "Other"
    }
    println(func('X'))       // PRINTS: Other
    println(func(123.456D))  // PRINTS: Double
    println(func(-98.76F))   // PRINTS: Float
    println(func(12345))     // PRINTS: Int
    println(func("Jupiter")) // PRINTS: String

    // The List.collect method accepts a PARTIAL FUNCTION as an argument.
    // A PARTIAL FUNCTION executes for some values, but not all values.
    // The case statement passed to List.collect below is a PARTIAL FUNCTION,
    // as it returns a value ONLY for intList elements NOT equal to zero.
    var intList:List[Int] = List(0,1,2,4)
    intList = intList.collect{ case i: Int if i != 0 => 42 / i }
    println(s"intList = $intList") // PRINTS: intList = List(42, 21, 10)

    // In this section List.collect is called with the same PARTIAL FUNCTION
    // case statement as above.  However, because all elements in intList
    // are zero, List.collect returns List(), which is an EMPTY List..
    intList = List(0,0,0,0)
    intList = intList.collect{ case i: Int if i != 0 => 42 / i }
    println(s"intList = $intList") // PRINTS: intList = List()

    // In this section the List.map method is called, which accepts a regular
    // function, NOT a partial function.  However, List.map can still accept
    // a case statement as its function.  But unlike the case statement
    // passed to List.collect() above, the below case statement ALWAYS
    // returns a value, which means it's NOT a partial function.
    var strList:List[String] = List("Jupiter", "Uranus", "Neptune")
    var result:List[Boolean] = strList.map{ case s: String => s.length > 6 }
    println(s"result = $result") // PRINTS: result = List(true, false, true)

    // The following function passed to List.map is a more common way of
    // calling List.map, and it returns the identical result as the
    // case statement used in the previous example.
    result = strList.map(_.length > 6)
    println(s"result = $result") // PRINTS: result = List(true, false, true)
  }
}

========================================================================================
