
READ THIS LINK ABOUT FUNCTIONAL PROGRAMMING
--> https://www.infoworld.com/article/3613715/what-is-functional-programming-a-practical-guide.html


The words "method" and "function" are often used interchangeably as if
a method and a function are the same.  In Scala there are important
differences between a method and a function that the programmer should
know.  This section explains methods, functions, and how they differ.

This web page covers the following topics, all of which are related to
methods and functions:

* METHOD
* FUNCTION
* ETA EXPANSION
* ANONYMOUS FUNCTION
* NULLARY FUNCTION
* PARTIAL FUNCTION
* FUNCTIONS BUILT WITH ONLY CASE STATEMENTS

==========================================================================================

METHOD
======
A Scala method is ALWAYS written using the "def" keyword.  So whenever the "def" keyword
appears, a method is defined.  Here's an example of a Scala method named squareMethod(),
which accepts a Float number as an argument, squares the number, and returns the result
as a Float number.

object Demo
{
  def squareMethod(number: Float): Float = number * number // Method definition.
  def main(args: Array[String]): Unit = {
    println(s"squareMethod(123.456F) = ${squareMethod(123.456F)}") // Call the method.
    // PRINTS: squareMethod(123.456F) = 15241.384
  }
}

The following sample code shows two method definitions that may look rather
strange to a newcomer.  Both methods accept no arguments and return the same
constant value.  One of the methods is defined WITHOUT parenthesis, and the
other method is defined WITH parenthesis.  Read in-line comments for details.

object Demo
{
  def main(args:Array[String]): Unit =
  {
    // You can define a method that accepts no arguments by leaving
    // out the parenthesis, OR by including empty parenthesis ().
    def number_1:Int = 123    // Method number_1 method accepts no arguments.
    def number_2():Int = 123  // Method number_2 method accepts no arguments.

    // A method defined without parenthesis MUST be called without parenthesis!
    println("number_1 = " + number_1)  // PRINTS: number_1 = 123

    // If you uncomment the following commented-out line it WON'T COMPILE,
    // as you're trying to call the number_1 method with empty parenthesis.
    // println("number_1() = " + number_1()) // WON'T COMPILE!

    // A method defined with empty parenthesis can be called
    // without parenthesis OR with empty parenthesis.
    println("number_2 = " + number_2)     // PRINTS: number_2 = 123
    println("number_2() = " + number_2()) // PRINTS: number_2() = 123
  }
}

Because the methods above accept no arguments and always return a constant value, you'd
never write such methods.  Instead, you'd just define number as a val, like this:

val number:Int = 123

A Scala method is ALWAYS bound to a class/object/trait.  In other words, a method
IS A MEMBER of a class/object/trait.  Assume a class named Person is defined, and
it contains a method named printPerson().  If we instantiate the Person class and
assign it to a val named "joe", we can then invoke the printPerson() method with
the following code because printPerson() is a member of the Person class.

joe.printPerson()  // Invokes the Person.printPerson() method on the "joe" Person class.

==========================================================================================

FUNCTION
========
Unlike a method (which is ALWAYS bound to a class/object/trait), a function is NEVER bound
to a class/object/trait.

If "joe" is an instance of a class named Person, and printPerson() is a function,
the function printPerson() CAN'T be a member of the Person class.  Therefore, you
CAN'T invoke the printPerson() function by calling it like this:

joe.printPerson()  // This works ONLY if printPerson() is a method,
                   // NOT if printPerson() is a function.

When you write a Scala method the "def" keyword is REQUIRED.  But a Scala function
is NEVER written using the "def" keyword.  Code samples of how to write Scala
functions are shown further below.

Every Scala function has a data type associated with it.  The data type of a function ALWAYS
contains the rocket symbol (=>).  On the LEFT SIDE of the rocket symbol (=>) is the data
type of each argument passed to the function.  On the RIGHT SIDE of the rocket symbol (=>)
is the data type returned by the function.

Examples of how a function's data type is written:

Int=>String                 (Data type of a function that accepts an Int argument, and returns a String value.)
(Int,Char,Float)=>Boolean   (Data type of a function that accepts Int, Char, and Float arguments, and returns a Boolean value.)

A NOTE ABOUT PARAMETRIC (GENERIC) DATA TYPES...
Assume you define a METHOD that accepts a number as an argument, squares that number,
and returns the result.  Typically the argument passed to that METHOD, and the result
it returns, must have a specific data type (i.e., an Int, a Float, a Double).  However,
Scala METHODS can accept parametric data types as arguments, and can return a parametric
data type.  (A parametric data type is also known as a generic data type.)

Therefore, if a METHOD named squareNumber() is defined to accept and return a parametric
data type (AKA a generic type), the squareNumber() method will be able to accept an argument
of type Int, or Float, or Double, and return the same data type passed to the argument.

IMPORTANT: ONLY Scala methods (NOT functions) can be written to accept and return
           parametric (generic) data types!  To learn more about parametric (generic)
           data types, read this section:
           https://github.com/w9mwi/Scala/blob/master/Parametric_Method

When you write a function, you can assign the function to a val/var.  When a function
is assigned to a val/var, that function gets invoked by referencing the val/var as
is shown in the following example.

object Demo
{
  def main(args:Array[String]): Unit =
  {
    // The following line of code ASSIGNS a function to the val squareFunction.
    val squareFunction: (Float => Float) = { (number: Float) => number * number }

    // The following line of code INVOKES the function assigned to val squareFunction.
    println(s"squareFunction(123.456F) = ${squareFunction(123.456F)}")
    // PRINTS: squareFunction(123.456F) = 15241.384
  }
}

Besides assigning a function to a val/var, there are other ways to write functions.
Alternative ways to write functions are shown in examples below.  (Keep reading.)

==========================================================================================

ETA EXPANSION
=============
An ETA EXPANSION is an operation that transforms a Scala method into a Scala function.
The following code sample demonstrates severals examples of how to perform an Eta
Expnansion on a method, thus transforming the method into a function.

object Demo
{
  def main(args:Array[String]): Unit =
  {
    // *********************************************************************
    // Define methods here that will be transformed into functions
    // further below by performing an ETA EXPANSION on them.
    def noArgumentMethod_1:Int = 123;
    def noArgumentMethod_2():Int = 123;
    def squareMethod(number: Float): Float = number * number
    def multiply2NumbersMethod(number_1: Float, number_2: Float): Float = number_1 * number_2

    // *********************************************************************
    // This section demonstrates how to perform an ETA EXPANSION on...
    // 1) noArgumentMethod_1 - A method defined WITHOUT parenthesis that accepts no argument.
    // 2) noArgumentMethod_2 - A method defined WITH parenthesis that accepts no argument.
    val func_1: () => Int = noArgumentMethod_1 _      // Underscore char (_) is REQUIRED.
    println(s"1) func_1.apply = ${func_1.apply}")     // PRINTS: 1) func_1.apply = 123
    println(s"2) func_1().toInt = ${func_1().toInt}") // PRINTS: 2) func_1().toInt = 123
    val func_2: () => Int = noArgumentMethod_2 _      // Underscore char (_) is OPTIONAL.
    println(s"3) func_2.apply = ${func_2.apply}")     // PRINTS: 3) func_2.apply = 123
    println(s"4) func_2().toInt = ${func_2().toInt}") // PRINTS: 4) func_2().toInt = 123

    // *********************************************************************
    // Transform squareMethod() into a function via an ETA EXPANSION.
    // NOTE: An Eta Expansion works for all 3 of the following lines
    //       when the method accepts ONLY ONE ARGUMENT.
    //        1)  squareMethod
    //        2)  squareMethod _
    //        3)  squareMethod(_)
    var squareFunction: Float => Float = squareMethod
    println(s"5) squareFunction(123.456F) = ${squareFunction(123.456F)}")
    // PRINTS: 5) squareFunction(123.456F) = 15241.384

    squareFunction = squareMethod _
    println(s"6) squareFunction(123.456F) = ${squareFunction(123.456F)}")
    // PRINTS: 6) squareFunction(123.456F) = 15241.384

    squareFunction = squareMethod(_)
    println(s"7) squareFunction(123.456F) = ${squareFunction(123.456F)}")
    // PRINTS: 7) squareFunction(123.456F) = 15241.384

    // *********************************************************************
    // Transform multiply2NumbersMethod() into a function via an ETA EXPANSION.
    // Notice the data type of multiply2NumbersFunction is written designating
    // that it accepts TWO ARGUMENTS.  Also note that when parenthesis are
    // included in the ETA EXPANSION, the ETA EXPANSION must be written to
    // designate that multiply2NumbersMethod accepts TWO ARGUMENTS, like this:
    // multiply2NumbersMethod(_, _)
    var multiply2NumbersFunction: (Float, Float) => Float = multiply2NumbersMethod
    println(s"8) multiply2NumbersFunction(123F, 456F) = ${multiply2NumbersFunction(123F, 456F)}")
    // PRINTS: 9) multiply2NumbersFunction(123F, 456F) = 56088.0

    multiply2NumbersFunction = multiply2NumbersMethod _
    println(s"9) multiply2NumbersFunction(123F, 456F) = ${multiply2NumbersFunction(123F, 456F)}")
    // PRINTS: 9) multiply2NumbersFunction(123F, 456F) = 56088.0

    multiply2NumbersFunction = multiply2NumbersMethod(_, _)
    println(s"10) multiply2NumbersFunction(123F, 456F) = ${multiply2NumbersFunction(123F, 456F)}")
    // PRINTS: 10) multiply2NumbersFunction(123F, 456F) = 56088.0

    // *********************************************************************
    // The Scala API contains hundreds of methods that accept a function as an argument.
    // For example, List.map() accepts a function as its argument.  But if you pass a
    // method to List.map(), Scala automatically transforms the method into a function.
    // This behavior is common in Scala.  If a method or a function accepts a function
    // as an argument, and it's easier to pass it a method, then pass it a method and
    // see if it works.  The following code demonstrates that List.map() works by passing
    // to it a method (squareMethod) or a function (squareFunction).
    var floatList: List[Float] = List(1.0F, 2.0F, 3.0F, 4.0F, 5.0F)
    // The following 2 lines are equivalent.  (The underscore (_) char is OPTIONAL.)
    floatList = floatList.map(squareMethod)
    floatList = floatList.map(squareMethod _)
    println(s"11) floatList = $floatList") // PRINTS: 11) floatList = List(1.0, 4.0, 9.0, 16.0, 25.0)
    floatList = floatList.map(squareFunction)
    println(s"12) floatList = $floatList") // PRINTS: 12) floatList = List(1.0, 16.0, 81.0, 256.0, 625.0)
  }
}

==========================================================================================

ANONYMOUS FUNCTION
==================
The Scala API contains hundreds of methods that accept a function as an argument.
For example, List.map() requires a function to be passed as its argument.  When a
method/function accepts a function as an argument, you can pass it an ANONYMOUS
FUNCTION, as the following example demonstrates.

NOTE: When an ANONYMOUS FUNCTION is written using the rocket symbol (=>)
      the token(s) on the left side of "=>" represents the argument(s)
      passed to the function.  The expression on the right side of "=>"
      is the algorithm that calculates the function's return value.
      The left side of "=>" must reference all arguments designated on
      the left side of "=>".  The following code sample demonstrates
      some examples of how to use anonymous functions.

object Demo
{
  def main(args: Array[String])
  {
    var floatList:List[Float] = List(1.0F, 2.0F, 3.0F, 4.0F, 5.0F)
    floatList = floatList.map(x => x * x) // Anonymous Function is: x => x * x
    println(s"floatList = $floatList") // PRINTS: floatList = List(1.0, 4.0, 9.0, 16.0, 25.0)

    // The following line defines an anonymous function, and assigns it to the var result.
    var result:(Int, Int) => Int = (a:Int, b:Int) => a+b  // Anonymous Function is: (a:Int, b:Int) => a+b
    // The following line calls the function assigned to the var result.
    println(result(222, 444)) // PRINTS: 666

    // The following line defines an anonymous function, and assigns it to the var result.
    // This anonymous function is IDENTICAL to the one above, but its syntax is different.
    result = (_:Int)+(_:Int)  // // Anonymous Function is: (_:Int)+(_:Int)
    println(result(444, 222)) // PRINTS: 666
  }
}

==========================================================================================

NULLARY FUNCTION
================
When a class constructor, or a method, or a function accepts an argument, that argument
usually references some common data type such as a class, an Int, a String, etc.
The following is the data type of a "regular" (non-nullary) function that accepts
an Int argument, and returns a String value:

Int=>String

Scala allows you to pass A BLOCK OF SCALA CODE to an argument.  When an argument accepts
a block of Scala code, that argument references a NULLARY FUNCTION.  The data type of a
nullary function is written differently than the data type of a "regular" (non-nullary) function.

Below are three examples of how to write the data type of a nullary function.  Remember,
an argument that accepts a block of code ALWAYS references a nullary function.

=>String // Data type of an argument that references a nullary function, and returns a String value.
=>Double // Data type of an argument that references a nullary function, and returns a Double value.
=>Unit   // Data type of an argument that references a nullary function, and returns nothing.

Four important points to remember about nullary functions:

1) When a block of code is passed as an argument to a class constructor, a method,
   or a function, that argument references a NULLARY FUNCTION.  The nullary function
   (the block of code) gets executed by referencing the argument.

2) The data type of a nullary function will ALWAYS include the rocket symbol (=>).
   There will NEVER be a data type on the left side of the rocket symbol because
   a block of code doesn't have a data type.  There will ALWAYS be a data type on
   the right side of the rocket symbol (=>), which designates the data type
   returned by the last line of code executed in the code block.  (If the code
   block returns nothing, its data type will be "Unit".)

3) A block of code passed as an argument can contain a single line of code, or
   many lines of code.  It's important to understand the block of code is NEVER
   executed when the argument gets passed.  Only the class constructor, the method,
   or the function receiving the block of code argument can execute the block of code,
   which is done by referencing the argument.

4) When passing a block of code to an argument, the block of code MUST be enclosed
   in braces {}, and NOT in parenthesis ().  The exception is a simple expression
   (such as "idx == 0"), which can be passed between parenthesis () or between
   braces {}.

Nullary Function Example #1
===========================

object Demo
{
  // The blockOfCode argument passed to myMethod() references a NULLARY FUNCTION.
  def myMethod(blockOfCode: => Boolean): Unit = {
    // The following line executes the block of code passed to this method,
    // and assigns its returned value to the val result.
    val result: Boolean = blockOfCode

    if (result == true)
      println("blockOfCode returned true.")
    else
      println("blockOfCode returned false.")
  }

  def main(args: Array[String]): Unit = {
    // Call myMethod() by passing a block of Scala code to its argument.
    // NOTE: The block of Scala code MUST be enclosed by braces {}.
    myMethod {
      val number = 123
      if (number == 123)
        true
      else false
    }
  }
}


Nullary Function Example #2
===========================

object Demo
{
  class LoopUntilCond_1(blockOfCode: => Unit)
  {
    // This until() method accepts a nullary function (a block of code) as its argument.
    def until(cond: => Boolean): Unit = {
      blockOfCode // Execute the block of code passed to this LoopUntilCond_1 class instance.
      if (false == cond)
        until(cond) // Recursively call the until() method until the "cond" argument evaluates to true.
    }
  }
  // Invoking this loop_1() method returns an instance of the LoopUntilCond_1 class.
  def loop_1(blockOfCode: => Unit):LoopUntilCond_1 = { new LoopUntilCond_1(blockOfCode) }

  def main(args: Array[String]): Unit = {
    // **************************************************************************************
    // EXAMPLE #1 - Demonstrates passing a nullary function (a block of code)
    //              as an argument to a method.
    //
    // The following code is explained in these 3 steps...
    // 1) The loop_1() method gets passed a block of Scala code between a pair of braces {}.
    // 2) The loop_1() method returns an instance of the LoopUntilCond_1 class,
    //    which also gets passed the same block of Scala code.
    // 3) Because the loop_1() method returns an instance of the LoopUntilCond_1 class,
    //    the LoopUntilCond_1.until() method can be invoked in the same line of code.
    var idx:Int = 5
    loop_1 {
      print("idx = " + idx + ", ") // PRINTS: idx = 5, idx = 4, idx = 3, idx = 2, idx = 1,
      idx -= 1
    } until idx == 0 // This line can be rewritten like this:   }.until(idx == 0)

    println()

    // **************************************************************************************
    // EXAMPLE #2 - Identical behavior to EXAMPLE #1 above.  But it's written so the
    //              LoopUntilCond_1 class (returned by invoking the loop_1() method)
    //              gets assigned to the val myLoop.
    idx = 5 // Reset the idx var.
    val myLoop:LoopUntilCond_1 = loop_1 {
      print("idx = " + idx + ", ")
      idx -= 1
    }
    myLoop.until(idx == 0)  // Can also be written:  myLoop.until{idx == 0}
  }
}

==========================================================================================
==========================================================================================
==========================================================================================

The following code sample shows another example of transforming
a regular function into a curried function by first performing
an ETA EXPANSION on it by adding the underscore (_) character,
and then calling Scala's .curried() method.

object Demo
{
  def main(args: Array[String])
  {
    // The add_1() function is a regular/normal function.
    // The first time the add_1() is called here, it's
    // called in the usual way....
    println("add_1(7, 3) = " + add_1(7, 3)) // PRINTS: add_1(7, 3) = 10

    // Perform an "Eta Expansion" on add_1() by using the underscore (_) character...
    val addFunc:((Int, Int) => Int) = add_1 _

    val addFuncCurried:(Int => (Int => Int)) = addFunc.curried // Make the add_1() function a curried function.
    println("addFuncCurried(7)(3) = " + addFuncCurried(7)(3)) // PRINTS: addFuncCurried(7)(3) = 10

    // addFuncCurried called with one param returns a PARTIALLY APPLIED function...
    val partiallyAppliedCurried:(Int => Int) = addFuncCurried(7)
    // Call partiallyAppliedCurried to make addFuncCurried FULLY APPLIED...
    println("partiallyAppliedCurried(3) = " + partiallyAppliedCurried(3)) // PRINTS: partiallyAppliedCurried(3) = 10

    // *****************************************************************************************
    // The add_2()() function called below is a curried function,
    // and can be called in the following two (2) ways...
    //
    // 1) Call sum_2()() once by passing to it both Int params, so it
    //    returns an Int result...
    println("add_2(7)(3) = " + add_2(7)(3)) // PRINTS: add_2(7)(3) = 10

    // 2) Call sum_2()() twice...  sum_2()() is called the first time by
    //    initializing its x Int parameter, and it returns a function.
    //    (At this point, the sum_2()() function is PARTIALLY APPLIED)
    //    Then, sum_2()() is called the second time by initializing
    //    its y Int parameter so it will now return an Int value.
    //    (At this point, the sum_2()() function is FULLY APPLIED.)
    val func:(Int => Int) = add_2(7)(_) // The func function is PARTIALLY APPLIED here.
    println("func(3) = " + func(3)) // PRINTS: func(3) = 10  (func is now FULLY APPLIED.)
  }

  /**
   * This add_1() function is a normal function, NOT a curried function.
   */
  def add_1(x:Int, y:Int):Int = { x + y }

  /**
   * This add_2() function is a CURRIED FUNCTION because
   * it takes multiple arguments, and returns a function
   * that takes a single argument.
   */
  def add_2(x:Int) = { (y:Int) => x + y }
}

========================================================================================
The following program shows another example of how functions and methods are used.

object Demo
{
  def main(args: Array[String]): Unit =
  {
    // The twice_1 method and the twice_2 function defined below have
    // IDENTICAL SIGNATURES AND IDENTICAL BEHAVIOR.  twice_1 and twice_2
    // both accept a function (named "func") as the first argument, and
    // "number" as the second argument.  The func() function is then
    // performed on number, which becomes the returned result.
    def twice_1(func:Double=>Double, number:Double):Double = { func(func(number)) }
    val twice_2:(Double=>Double, Double)=>Double = { (func:Double=>Double, number:Double) => func(func(number)) }

    // EXPLANATION: In the following call to twice_1()...
    //              1) The "_ + 1" is a function that gets passed to the "func" argument of
    //                 twice_1(), and 5 gets passed to the "number" argument of twice_1().
    //              2) The underscore (_) references the "number" argument passed
    //                 to twice_1(), which is the number 5.
    //              3) twice_1() returns this expression:  func(func(5))
    //                 First, func(5) returns:  (5.0 + 1.0) = 6.0
    //                 Next, func(6.0) is called, which returns this final value:  (6.0 + 1.0) = 7.0
    var result:Double = twice_1(_ + 1, 5)
    println(s"result #1 = $result") // PRINTS: result #1 = 7.0

    // The EXPLANATION given above for what happens when twice_1() gets called
    // applies equally to what happens when twice_2() is called below.
    result = twice_2(_ + 1, 5)
    println(s"result #2 = $result") // PRINTS: result #2 = 7.0
  }
}

========================================================================================
PARTIAL FUNCTIONS - PART 1 of 3

DON'T confuse partial functions with partially-applied functions!  Partial functions
are NOT related to, or similar to, partially-applied functions.  Partial functions
and partially-applied functions are totally unrelated, and totally different from
each other.

A Scala partial function is a function that returns values for
only a specific set of values passed to it.  A partial function
DOESN'T return anything when it's passed an invalid value.

EXAMPLE: If a partial function performs mathematical division on
         a number passed to it, NO RESULT WILL BE RETURNED when
         that number is zero; because dividing by zero is invalid.

Implementing a partial function in Scala requires the programmer
to define these two methods:
1) apply()       - Automatically called when you pass the function an argument.
2) isDefinedAt() - This method returns a Boolean true for all valid values passed
                   to it.  It returns false for invalid values passed to it.

object Demo
{
  // The [Int, Int] below means you pass the PartialFunction
  // an Int argument, and it returns an Int.
  val dividePF = new PartialFunction[Int, Int]
                 {
                   def apply(number:Int):Int = { 124 / number }
                   // The isDefined() method defines the valid/invalid values.
                   // In this example all Int values are valid except zero.
                   def isDefinedAt(number:Int):Boolean = { number != 0 }
                 }

  def main(args: Array[String])
  {
    // It's possible to call a partial function directly, like this...
    var intValue:Int = dividePF(6)   // Calls the PartialFunction.apply() method.
    println(s"intValue = $intValue") // PRINTS: intValue = 20

    // However, it make sense no sense to call a partial function directly
    // because if you pass it an undefined value, it won't return anything.
    // The following 2 lines of commented-out code will compile, but they'll
    // throw an ArithmeticException because dividePF(0) doesn't return anything.
    // dividePF(0)
    // intValue = dividePF(0)

    // The Scala API contains some methods that accept a partial function
    // as an argument.  That is where partial functions should be used.
    // List.collect is a Scala API method that accepts a partial function.
    var intList:List[Int] = List(0,1,2,4)
    intList = intList.collect{ dividePF }
    println(s"intList = $intList") // PRINTS: intList = List(124, 62, 31)
  }
}

========================================================================================
PARTIAL FUNCTIONS - PART 2 OF 3

object Demo
{
  // NOTICE: In the above example the PartialFunction definition requires
  //         the apply() and isDefinedAt() methods to be defined.  But in the
  //         below example the PartialFunction definition requires only
  //         a case statement.  Because a single case statement effectively
  //         contains the isDefinedAt() and apply() methods.  In the "val Case1"
  //         declaration below:  isDefinedAt() = if (x % 3) != 0
  //                             isApply()     = The entire "case x" statement.
  val Case1:PartialFunction[Int, String] =
  { case x if (x % 3) != 0 => "odd" }

  val Case2:PartialFunction[Int, String] =
  { case y if (y % 2) == 0 => "even" }

  // NOTE: orElse is a method defined in the PartialFunction trait that's
  //       used as an operator on two PartialFunctions.  The following line
  //       of code could also be written like this:  Case1.orElse(Case2)
  val evenOrOdd:PartialFunction[Int, String] = Case1 orElse Case2

  def main(args: Array[String])
  {
    var x:Int = 324
    var result:String = evenOrOdd(x).toString + "."
    println(s"The number $x is $result") // PRINTS: The number 324 is even.

    x = 325
    result = evenOrOdd(x).toString + "."
    println(s"The number $x is $result") // PRINTS: The number 324 is odd.
  }
}

========================================================================================
PARTIAL FUNCTIONS - PART 3 OF 3

object Demo
{
  def main(args: Array[String])
  {
    // Like the 2 PartialFunctions defined in the above example, here we define
    // the operation1 PartialFunction with a single case statement, instead
    // of needing to define the apply() and isDefinedAt() methods.
    val operation1:PartialFunction[Int, Int] = { case x if (x%4 != 0) => x*42 }
    val operation2:(Int=>Int)                = (x: Int) => x/3
    // NOTE: andThen is a method defined in the PartialFunction trait.
    //       andThen is used as an operator.  The following line of code
    //       could also be written like this:  operation1.andThen(operation1)
    val op = operation1 andThen operation2
    // *****************************************************************
    var intValue = 34
    // When op(intValue) is called is called below, these operations occur...
    // operation1:  x%4 = ((34/4) = 8) is NOT zero, so (34*42) = 1428
    // andThen
    // operation2:  x/3 = 1428/3 = 476
    println(s"Initial value = $intValue.\nValue after operations = " + op(intValue))
    // PRINTS:
    // Initial value = 34.
    // Value after operations = 476
    // *****************************************************************
    // *****************************************************************
    intValue = 40
    // When op(intValue) is called below, these operations occur...
    // operation1:  x%4 = ((40/4) = 0) IS zero, so NOTHING IS RETURNED by operation1.
    //              So operation2 is NOT invoked.  NOTHING IS RETURNED, period!
    //              Therefore, the following commented-out line will throw a
    //              MatchError exception if it's not commented out.
    // op(intValue)
    // *****************************************************************
    // *****************************************************************
    // When intList.collect(op) is called below, nothing is returned
    // for elements 8, 12, 40, 44.  Only elements 45 and 77 result
    // in returned values.
    var intList:List[Int] = List (8, 12, 40, 44, 45, 77)
    intList = intList.collect(op)
    println(s"intList = $intList") // PRINTS: intList = List(630, 1078)
  }
}

========================================================================================
ANONYMOUS FUNCTIONS - Some examples below.

object Demo
{
  def main(args: Array[String]): Unit = {
    // EXAMPLE 1 **************************************************************************
    case class StringToInt(run:String => Int)
    // Instantiate a StringToInt class by passing to it an anonymous function,
    // which will get assigned to its member val named "run".
    // NOTE: You could replace this text: StringToInt(x => x.toInt)
    //       with this text:              StringToInt{ str:String => str.toInt }
    val myClass_1:StringToInt = StringToInt(x => x.toInt)
    var myInt:Int = myClass_1.run("-777") // "run" is a val member of myClass_1.
    println(s"myInt #1 = $myInt") // PRINTS: result #1 = -777

    // This time we pass stringToInt() a defined function named: myStrLengthFunc
    def myStrLengthFunc(str:String):Int = { str.length }
    val valFunc_1:StringToInt = StringToInt(myStrLengthFunc)
    myInt = valFunc_1.run("Madison, Wisconsin")
    println(s"myInt #2 = $myInt") // PRINTS: myInt #2 = 18

    // EXAMPLE 2 **************************************************************************
    case class TwoStringsToInt[A,B](func:(A,A) => B)
    val anonFunc = (a:String, b:String) => (a.length + b.length)
    val myClass_2:TwoStringsToInt[String, Int] = TwoStringsToInt(anonFunc)
    // func is a member val of the TwoStringsToInt class, created upon instantiation of TwoStringsToInt.
    myInt = myClass_2.func("Madison", "Wisconsin")
    println(s"myInt #3 = $myInt") // PRINTS: myInt #3 = 16
  }
}

========================================================================================

FUNCTIONS BUILT WITH ONLY CASE STATEMENTS
=========================================
It's possible to write a Scala function where the body of the function consists
of nothing but case statements, and the "match" keyword isn't used.  Below is
an example.  Read in-line comments for details.

object Demo {
  def main(args: Array[String]) {
    // Declare a function where its body contains only case statements,
    // and the "match" keyword is NOT used.  In this example, the function
    // gets passed the "Any" data type, returns a String.
    val func: (Any => String) = { // Assigns the function to the val func.
      case d: Double => "Double"
      case f: Float  => "Float"
      case i: Int    => "Int"
      case s: String => "String"
      case _         => "Other"
    }
    println(func('X'))       // PRINTS: Other
    println(func(123.456D))  // PRINTS: Double
    println(func(-98.76F))   // PRINTS: Float
    println(func(12345))     // PRINTS: Int
    println(func("Jupiter")) // PRINTS: String

    // The following code exists only to remind how
    // case statements are often used, along with the
    // "match" keyword, to perform pattern matching.
    val number: Int = 3
    val result: String = number match {
      case 1 => "One"
      case 2 => "Two"
      case 3 => "Three"
      case _ => "Other"
    }
    println(s"result = $result") // PRINTS: result = Three
  }
}


  /*****
    // The List.collect method accepts a PARTIAL FUNCTION as an argument.
    // A PARTIAL FUNCTION executes for some values, but not all values.
    // The case statement passed to List.collect below is a PARTIAL FUNCTION,
    // as it returns a value ONLY for intList elements NOT equal to zero.
    var intList:List[Int] = List(0,1,2,4)
    intList = intList.collect{ case i: Int if i != 0 => 42 / i }
    println(s"intList = $intList") // PRINTS: intList = List(42, 21, 10)

    // In this section List.collect is called with the same PARTIAL FUNCTION
    // case statement as above.  However, because all elements in intList
    // are zero, List.collect returns List(), which is an EMPTY List..
    intList = List(0,0,0,0)
    intList = intList.collect{ case i: Int if i != 0 => 42 / i }
    println(s"intList = $intList") // PRINTS: intList = List()

    // In this section the List.map method is called, which accepts a regular
    // function, NOT a partial function.  However, List.map can still accept
    // a case statement as its function.  But unlike the case statement
    // passed to List.collect() above, the below case statement ALWAYS
    // returns a value, which means it's NOT a partial function.
    var strList:List[String] = List("Jupiter", "Uranus", "Neptune")
    var result:List[Boolean] = strList.map{ case s: String => s.length > 6 }
    println(s"result = $result") // PRINTS: result = List(true, false, true)

    // The following function passed to List.map is a more common way of
    // calling List.map, and it returns the identical result as the
    // case statement used in the previous example.
    result = strList.map(_.length > 6)
    println(s"result = $result") // PRINTS: result = List(true, false, true)
  }
}
*****/

========================================================================================
