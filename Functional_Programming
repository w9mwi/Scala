// FACTORIAL FUNCTION
object Demo
{
  def main(args: Array[String]): Unit =
  {
    println("factorial(4400) = " + factorial(4400))
  }

  def factorial(x:BigInt):BigInt =
  {
    if (x <= 1)
    {
      return(1)
    }
    else
    {
      x * factorial(x-1)
    }
  }
}
// =================================================================
// =================================================================
// NOTE: The following 2 lines are examples of FUNCTION LITERALS...
//       (a:Int, b:Int) => a+b
//       (x:Double)     => x*x
object Demo
{
  // The following 2 vals (add and square) are initialized as functions.
  // The text to the right of the '=' sign would be considered a function
  // literal, if that text stood alone and was NOT assigned to a val or var.
  val add    = (a:Int, b:Int) => a+b
  val square = (x:Double)     => x*x

  // The following 2 functions have behavior identical
  // to the 2 corresponding function literals above.
  def add2(a:Double, b:Double):Double = a+b
  def square2(x: Double):Double       = x*x

  def main(args: Array[String]): Unit =
  {
    println("add(4,5)  = " + add(4,5))
    println("square(7) = " + square(7))

    println("add2(4,5)  = " + add2(4,5))
    println("square2(7) = " + square2(7))
  }
}
// =================================================================
// =================================================================
A HIGHER-ORDER FUNCTION is a function that operates on other functions.
In other words, a HIGHER-ORDER FUNCTION is a function that gets passed
a function as a parameter, and/or returns a function.  The following
code defines two functions (compose and compose2, both of which have
identical behavior) that are higher-order functions--as they both
get passed functions as parameters, and they both return a function.
Both compose and compose2 return the function f(g(x))...

object FunctionFGX
{
  val plus5   = (x:Double) => x+5.0  // EQUIVALENT TO:  def plus5(x:Double):Double = x+5.0
  val square  = (x:Double) => x*x    // EQUIVALENT TO:  def square(x:Double):Double = x*x
  val compose = (f:Double  => Double, g:Double => Double, x:Double) => f(g(x))

  // The following compose2() function gets passed 2 functions as params (f and g),
  // and returns a function that gets passed a Double and returns a Double.
  def compose2(f:Double => Double, g:Double => Double):Double => Double =
  {
    x => f(g(x)) // This is the returned function.
  }

  def main(args: Array[String])
  {
    val a:(Double => Double) = compose2(plus5, square) // EQUIVALENT TO:  val a  = compose2(plus5, square)
    val b                    = compose2(square, plus5) // EQUIVALENT TO:  val b:(Double => Double) = compose2(square, plus5)

    println("a(3) = " + a(3))
    println("b(3) = " + b(3))

    // The following 2 calls to compose() are identical
    // to the above two function calls a(3) and b(3)...
    println("compose(plus5,  square, 3) = " + compose(plus5, square, 3))
    println("compose(square, plus5,  3) = " + compose(square, plus5, 3))
  }
}
// =================================================================
// =================================================================
The following code contains a function named "funcOfGunc", which is
a parametric function (not type dependent) that's equivalent to the
function named "compose2" in the FunctionFGX program immediately above.
(Taken from Page 156 of the book.)
object Demo
{
  def main(args:Array[String]): Unit =
  {
    val plus5  = (x:Double) => x+5
    val square = (x:Double) => x*x

    // First, test the plus5 and square functions defined above...
    println("plus5(3)  = " + plus5(3))  // Prints: plus5(3)  = 8.0
    println("square(3) = " + square(3)) // Prints: square(3) = 9.0

    // Next, initialize myFunc so it points to funcOfGunc...
    val myFunc:(Double=>Double) = funcOfGunc(plus5, square)

    // Finally, call myFunc with a numeric value and print the result...
    val result:Double = myFunc(7.0D)
    println("result = " + result) // Prints: result = 54.0  (NOTE: 54.0 = 5.0+(7.0*7.0))
  }

  def funcOfGunc[A,B,C](func:(B=>A), gunc:(C=>B)):(C=> A) = { x=>func(gunc(x)) }
}
