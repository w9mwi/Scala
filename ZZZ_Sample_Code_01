This sample program demonstrates MODULAR FUNCTIONAL PROGRAMMING.
The sample program BELOW THIS ONE demonstrates how to write the
same program using FUNCTIONAL OBJECTS PROGRAMMING.

object Demo
{
  object ListUtils
  {
    def dropFirstMatch[A](ls: Seq[A], value: A): Seq[A] =
    {
      val index = ls.indexOf(value)
      if (index < 0) { ls }  // index = -1 if there is no match.
      else if (index == 0) { ls.tail }
      else { val (a, b) = ls.splitAt(index); // splitAt keeps the matching element in the second group.
        a ++ b.tail }
    }
  }

  type Money = BigDecimal
  sealed trait Topping
  case object Cheese    extends Topping
  case object Pepperoni extends Topping
  case object Sausage   extends Topping
  case object Mushrooms extends Topping
  case object Onions    extends Topping

  sealed trait CrustSize
  case object SmallCrustSize  extends CrustSize
  case object MediumCrustSize extends CrustSize
  case object LargeCrustSize  extends CrustSize

  sealed trait CrustType
  case object RegularCrustType extends CrustType
  case object ThinCrustType    extends CrustType
  case object ThickCrustType   extends CrustType

  case class Address (street1: String,
                      street2: Option[String],
                      city: String,
                      state: String,
                      zipCode: String)
  {
    override def toString = s"Address($street1, $street2, $city, $state, $zipCode)"
  }

  case class Pizza(crustSize: CrustSize,
                   crustType: CrustType,
                   toppings:  Seq[Topping])
  {
    override def toString = s"Pizza($crustSize, $crustType, $toppings)"
  }

  case class Customer(name:String, phone:String, address:Address)
  {
    override def toString = s"Customer($name, $phone, $address)"
  }

  case class Order(pizzas:Seq[Pizza], customer:Customer)
  {
    override def toString = s"Order($customer, $pizzas)"
  }

  trait PizzaServiceInterface
  {
    def addTopping(p:Pizza, t:Topping):Pizza
    def removeTopping(p:Pizza, t:Topping):Pizza
    def removeAllToppings(p:Pizza):Pizza
    def updateCrustSize(p:Pizza, cs:CrustSize):Pizza
    def updateCrustType(p:Pizza, ct:CrustType):Pizza
    def calculatePizzaPrice(p:Pizza,
                            toppingsPrices:Map[Topping, Money],
                            crustSizePrices:Map[CrustSize, Money],
                            crustTypePrices:Map[CrustType, Money]):Money
  }

  trait PizzaService extends PizzaServiceInterface
  {
    def addTopping(p:Pizza, t:Topping):Pizza =
    {
      val newToppings = p.toppings :+ t
      p.copy(toppings = newToppings) // NOTE: The copy() method is available to all case classes.
    }

    def removeTopping(p:Pizza, t:Topping):Pizza =
    {
      val newToppings = ListUtils.dropFirstMatch(p.toppings, t)
      p.copy(toppings = newToppings) // NOTE: The copy() method is available to all case classes.
    }
    def removeAllToppings(p:Pizza):Pizza =
    {
      val newToppings = Seq[Topping]()
      p.copy(toppings = newToppings) // NOTE: The copy() method is available to all case classes.
    }
    def updateCrustSize(p:Pizza, cs:CrustSize):Pizza =
    {
      p.copy(crustSize = cs) // NOTE: The copy() method is available to all case classes.
    }
    def updateCrustType(p:Pizza, ct:CrustType):Pizza =
    {
      p.copy(crustType = ct) // NOTE: The copy() method is available to all case classes.
    }

    def calculatePizzaPrice(p:Pizza,
                            toppingsPrices:Map[Topping, Money],
                            crustSizePrices:Map[CrustSize, Money],
                            crustTypePrices:Map[CrustType, Money]):Money =
    {
      val base:BigDecimal = BigDecimal(10)
      val numToppings:Int = p.toppings.size
      val price:Money     = base + 1.00 * numToppings
      price
    }
  } // END: trait PizzaService extends PizzaServiceInterface

  trait PizzaDaoInterface // NOTE: Dao = Data Access Object
  {
    def getToppingPrices():Map[Topping, Money]
    def getCrustSizePrices():Map[CrustSize, Money]
    def getCrustTypePrices():Map[CrustType, Money]
  }

  object MockPizzaDao extends PizzaDaoInterface
  {
    def getToppingPrices(): Map[Topping, Money] =
    {
      Map(Cheese    -> BigDecimal(1),
        Pepperoni -> BigDecimal(1),
        Sausage   -> BigDecimal(1),
        Mushrooms -> BigDecimal(1))
    }

    def getCrustSizePrices(): Map[CrustSize, Money] =
    {
      Map(SmallCrustSize  -> BigDecimal(0),
        MediumCrustSize -> BigDecimal(1),
        LargeCrustSize  -> BigDecimal(2))
    }

    def getCrustTypePrices(): Map[CrustType, Money] =
    {
      Map(RegularCrustType -> BigDecimal(0),
        ThickCrustType   -> BigDecimal(1),
        ThinCrustType    -> BigDecimal(1))
    }
  } // END: object MockPizzaDao extends PizzaDaoInterface

  object MockDbOrderService extends AbstractOrderService
  {
    val database = MockPizzaDao
  }

  trait OrderServiceInterface
  {
    protected def database:PizzaDaoInterface
    def calculateOrderPrice(o:Order):Money
  }

  trait AbstractOrderService extends OrderServiceInterface
  {
    object PizzaService extends PizzaService
    import PizzaService.calculatePizzaPrice
    private lazy val toppingPricesMap   = database.getToppingPrices()
    private lazy val crustSizePricesMap = database.getCrustSizePrices()
    private lazy val crustTypePricesMap = database.getCrustTypePrices()
    def calculateOrderPrice(o:Order):Money = calculateOrderPriceInternal(o,
                                                                         toppingPricesMap,
                                                                         crustSizePricesMap,
                                                                         crustTypePricesMap)
    private def calculateOrderPriceInternal(o:Order,
                                            toppingPrices:Map[Topping, Money],
                                            crustSizePrices:Map[CrustSize, Money],
                                            crustTypePrices:Map[CrustType, Money]):Money =
    {
      val pizzaPrices:Seq[Money] = for (pizza <- o.pizzas)
                                   yield { calculatePizzaPrice(pizza,
                                           toppingPrices,
                                           crustSizePrices,
                                           crustTypePrices) }
      pizzaPrices.sum
    }
  }

  /********************************************
   * main() function
   ********************************************/
  def main(args: Array[String])
  {
    val address:Address = Address("1717 Philippen St.", None, "Manitowoc", "Wisconsin", "54220")
    val customer:Customer = Customer("Joe Blow", "920-682-1882", address)
    println(s"customer = $customer\n")

    var pizza_1:Pizza = Pizza(LargeCrustSize, RegularCrustType, Seq(Pepperoni, Cheese))
    println(s"pizza_1 = $pizza_1")

    var pizza_2:Pizza = Pizza(SmallCrustSize, ThickCrustType, Seq(Sausage, Mushrooms, Onions))
    println(s"pizza_2 = $pizza_2\n")

    var order = Order(Seq(pizza_1, pizza_2), customer)
    println(s"order = $order\n")
  }
}

========================================================================
This sample program demonstrates FUNCTIONAL OBJECTS PROGRAMMING.
The sample program ABOVE THIS ONE demonstrates how to write the
same program using MODULAR FUNCTIONAL PROGRAMMING.

object Demo
{
  type Money = BigDecimal
  object Price
  {
    val zeroDollars:Money      = BigDecimal(0.00D).setScale(2)
    val pizzaBasePrice:Money   = BigDecimal(10.00D).setScale(2)
    val pizzaTopping:Money     = BigDecimal(1.00D).setScale(2)
    val crustTypeRegular:Money = zeroDollars
    val crustTypeThin:Money    = BigDecimal(1.00D).setScale(2)
    val crustTypeThick:Money   = BigDecimal(2.00D).setScale(2)
    val pizzaSizeSmall:Money   = zeroDollars
    val pizzaSizeMedium:Money  = BigDecimal(1.00D).setScale(2)
    val pizzaSizeLarge:Money   = BigDecimal(2.00D).setScale(2)
  }

  sealed trait Topping
  case object Cheese    extends Topping
  case object Mushrooms extends Topping
  case object Onions    extends Topping
  case object Olives    extends Topping
  case object Pepperoni extends Topping
  case object Sausage   extends Topping

  sealed trait PizzaSize
  case object PizzaSizeSmall  extends PizzaSize
  case object PizzaSizeMedium extends PizzaSize
  case object PizzaSizeLarge  extends PizzaSize

  sealed trait CrustType
  case object CrustTypeRegular extends CrustType
  case object CrustTypeThin    extends CrustType
  case object CrustTypeThick   extends CrustType

  case class Address (street1: String,
                      street2: Option[String],
                      city: String,
                      state: String,
                      zipCode: String)
  {
    override def toString = s"Address($street1, $street2, $city, $state, $zipCode)"
  }

  case class Pizza(pizzaSize: PizzaSize,
                   crustType: CrustType,
                   toppings:  Seq[Topping])
  {
    override def toString = s"Pizza($pizzaSize, $crustType, $toppings)"
    def addTopping(t:Topping):Pizza         = { copy(toppings = toppings :+ t) }
    def removeTopping(t:Topping):Pizza      = { copy(toppings = dropFirstMatch(toppings, t)) }
    def removeAllToppings():Pizza           = { copy(toppings = Seq[Topping]()) } // NOTE: Seq[Topping]() = Nil
    def updatePizzaSize(ps:PizzaSize):Pizza = { copy(pizzaSize = ps) }
    def updateCrustType(ct:CrustType):Pizza = { copy(crustType = ct) }
    //def getPrice(crustSize:PizzaSize, crustType:CrustType, toppings:Seq[Topping]):Money =
    def getPrice():Money =
    {
      val pizzaSizePrice:Money = MockPizzaDao.getCrustSizePrices().getOrElse(pizzaSize, Price.zeroDollars)
      val crustTypePrice:Money = MockPizzaDao.getCrustTypePrices().getOrElse(crustType, Price.zeroDollars)

      // Assign moneySeq the price of each topping on the pizza.
      val moneySeq:Seq[Money] = for { top <- toppings } yield MockPizzaDao.getToppingPrices.getOrElse(top, Price.zeroDollars)
      println("XXX moneySeq = " + moneySeq)
      val toppingsPrice:Money = moneySeq.sum // Obtain the total price of all toppings on the pizza.

      // Return the total price of the pizza.
      Price.pizzaBasePrice + crustTypePrice + pizzaSizePrice + toppingsPrice
    }
  }

  case class Customer(name:String, phone:String, address:Address)
  {
    override def toString = s"Customer($name, $phone, $address)"
  }

  case class Order(pizzas:Seq[Pizza], customer:Customer)
  {
    override def toString = s"Order($customer, $pizzas)"
  }

  trait PizzaDaoInterface // NOTE: Dao = Data Access Object
  {
    def getToppingPrices():Map[Topping, Money]
    def getCrustSizePrices():Map[PizzaSize, Money]
    def getCrustTypePrices():Map[CrustType, Money]
  }

  object MockPizzaDao extends PizzaDaoInterface // NOTE: Dao = Data Access Object
  {
    def getToppingPrices(): Map[Topping, Money] =
    {
      Map(Cheese    -> Price.pizzaTopping,
          Pepperoni -> Price.pizzaTopping,
          Onions    -> Price.pizzaTopping,
          Olives    -> Price.pizzaTopping,
          Mushrooms -> Price.pizzaTopping,
          Sausage   -> Price.pizzaTopping)
    }

    def getCrustSizePrices(): Map[PizzaSize, Money] =
    {
      Map(PizzaSizeSmall -> Price.pizzaSizeSmall,
          PizzaSizeMedium-> Price.pizzaSizeMedium,
          PizzaSizeLarge -> Price.pizzaSizeLarge)
    }

    def getCrustTypePrices(): Map[CrustType, Money] =
    {
      Map(CrustTypeRegular -> Price.crustTypeRegular,
          CrustTypeThick   -> Price.crustTypeThick,
          CrustTypeThin    -> Price.crustTypeThin)
    }
  }

  /************************************************************************
   * main() function
   *
   * This function creates a single pizza order for a customer.
   * This order contains two pizzas.
   ************************************************************************/
  def main(args: Array[String])
  {
    val address:Address = Address("1717 Philippen St.", None, "Manitowoc", "Wisconsin", "54220")
    val customer:Customer = Customer("Joe Blow", "920-682-1882", address)

    // Create the first pizza (named pizza_1) and print its contents.
    val pizza_1:Pizza = Pizza(PizzaSizeSmall, CrustTypeRegular, Seq(Pepperoni))
    println(s"pizza_1 = $pizza_1")
    var pizzaPrice = pizza_1.getPrice()
    println("pizza_1 Price = $" + pizzaPrice + "\n")

    // Create the second pizza (named pizza_2).
    val pizza_2:Pizza = Pizza(PizzaSizeMedium, CrustTypeThin, Seq(Onions, Olives, Pepperoni))
    println(s"pizza_2 = $pizza_2")

    // Here we decide to change the pizzaSize, crustType, and toppings
    // of pizza_2.  But pizza_2 is a val so it can't be changed.  So
    // "var pizzaUpdated" is declared to accommodate changes made to a pizza.
    var pizzaUpdated = pizza_2.removeAllToppings()
    pizzaUpdated = pizzaUpdated.addTopping(Sausage)
    pizzaUpdated = pizzaUpdated.addTopping(Olives)
    pizzaUpdated = pizzaUpdated.removeTopping(Olives) // Remove the Olives topping just added above.
    pizzaUpdated = pizzaUpdated.addTopping(Mushrooms)
    pizzaUpdated = pizzaUpdated.addTopping(Cheese)
    pizzaUpdated = pizzaUpdated.addTopping(Pepperoni)
    pizzaUpdated = pizzaUpdated.addTopping(Onions)
    pizzaUpdated = pizzaUpdated.updatePizzaSize(PizzaSizeLarge)
    pizzaUpdated = pizzaUpdated.updateCrustType(CrustTypeThick)
    println(s"pizzaUpdated = $pizzaUpdated")
    pizzaPrice = pizzaUpdated.getPrice()
    println("pizzaUpdated Price = $" + pizzaPrice + "\n")

    val order = Order(Seq(pizza_1, pizzaUpdated), customer)
    println(s"order = $order\n")
  }

  /**
   * This function gets passed a Seq containing values, and a single value.
   * The first occurrence of the value passed to this function is removed
   * from that Seq, and then the Seq is returned.
   */
  def dropFirstMatch[A](seq:Seq[A], value:A): Seq[A] =
  {
    val index:Int = seq.indexOf(value)
    if (index < 0) { seq }  // index = -1 if there is no match.
    else if (index == 0) { seq.tail }
    else
    {
      // splitAt() splits a Seq into a prefix and suffix.
      // The prefix contains Seq elements 0 through index.
      // The suffix contains the remaining Seq, beginning
      // with element index+1, which is the matching element.
      val (a:Seq[A], b:Seq[A]) = seq.splitAt(index)
      a ++ b.tail // The returned Seq drops the head of Seq b.
    }
  }
}
