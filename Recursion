THREE (3) STEPS FOR WRITING SCALA RECURSIVE FUNCTIONS
====================================================
When you write a recursive functions, your job may
be easier if you ask the following 3 questions...

STEP 1) What is the recursive function's signature?
        In other words, what do you pass to it, and
        what does it return?

STEP 2) What is the exit condition of the function?
        In other words, what's the expression required
        for the if() statement to make the function
        return a value and therefore terminate?
        
        FYI, a recursive function's if() statement will
        determine if the function will return a value,
        or if the function will make a recursive call.

STEP 3) What is the algorithm of the function?  Write
        down the problem, and think of how it could
        best be solved.


========================================================
The 3 functions defined in the sample code below
(sum1(), sum2(), and sum3()) are all functionally
equivalent.  Each function gets passed a List[Int]
type, and returns the sum of all Ints contained in
the List.  The sum2() and sum3() functions below
use the "match" Scala keyword.

object Demo
{
  def main(args: Array[String])
  {
    val myList:List[Int] = List (215, 683, 9673, 8436, 420, 815)
    println("sum1 = " + sum1(myList)) // PRINTS: sum1 = 20242
    println("sum2 = " + sum2(myList)) // PRINTS: sum2 = 20242
    println("sum3 = " + sum3(myList)) // PRINTS: sum3 = 20242
  }

  /**
    * THIS IS A RECURSIVE FUNCTION, which returns the sum of
    * all Ints contained in the List passed to this function.
    */
  def sum1(list:List[Int]):Int =
  {
    if (list == Nil) { 0 }
    else { list.head + sum1(list.tail) }
  }

  /**
    * THIS IS A RECURSIVE FUNCTION, which returns the sum of
    * all Ints contained in the List passed to this function.
    */
  def sum2(list:List[Int]):Int = list match
  {
    // NOTE: Don't confuse the "=>" symbol below with the "=>"
    //       symbol used by function literals.  Scala case
    //       statements always require the "=>" symbol.
    case Nil => 0
    case _   => list.head + sum2(list.tail)
  }

  /**
    * THIS IS A RECURSIVE FUNCTION, which returns the sum of
    * all Ints contained in the List passed to this function.
    */
  def sum3(list:List[Int]):Int = list match
  {
    // NOTE: Don't confuse the "=>" symbol below with the "=>"
    //       symbol used by function literals.  Scala case
    //       statements always require the "=>" symbol.
    case Nil        => 0
    case head::tail => head + sum3(tail)
  }
}
========================================================
object Demo
{
  def main(args: Array[String])
  {
    val list:List[Int] = List.range(1, 10) // range(1, 10) creates a List of 9 Ints:  1 through 9
    val listSum:Int    = sum(list)
    println("listSum = " + listSum) // PRINTS: listSum = 45
  }

  def sum(list:List[Int]):Int =
  {
    import scala.annotation.tailrec
    @tailrec  // NOTE: The @tailrec annotation informs the compiler to enforce
              //       tail recursion on the function immediately below.
    def sumWithAccumulator(currentSum:Int, list:List[Int]):Int =
    {
      list match
      {
        case Nil        => currentSum
        case head::tail => sumWithAccumulator(head+currentSum, tail)
      }
    }
    sumWithAccumulator(0, list)
  }
}
