LOOPING CONSTRUCTS
To understand more about how for() loops and yield work, SEE:
https://alvinalexander.com/scala/scala-for-loops-foreach-how-to-translated-by-compiler

NOTE: Any class that implements BOTH the map() and flatMap() methods can be used in a
for-expression.  See Chapter 61 in Functional Programming Simplified (Scala Edition)
================================================================================

NOTE: When a while() loop is entered, it will loop forever
      until the value of some var changes.  Therefore, some
      data (a var) must change its state, thus making it
      IMPOSSIBLE to use a while() loop (or a do/while() loop)
      in a fully functional way.  In other words, if you use
      a while() loop, your code is NOT pure functional code.

do
{
   Some code here.
} while(condition);

================================================================================
To iterate through a data type that inherits from sequence
(such as List, Array, ArrayBuffer, Vector, Seq, etc.),
use the foreach() method...

val x = List(1,2,3)
x.foreach { println }


val names = Vector("Bob", "Fred", "Joe", "Julia", "Kim")
// The following 3 lines print the same result...
for (name <- names) println(name)
names.foreach(println)
names.foreach {println}
// The following for() loop prints only names beginning with 'J'...
for (name <- names if name.startsWith("J")) { println(name) }


var sum = 0
val x = List(7,8,9)
x.foreach(sum += _) // This line of code is equivalent to: x.map(sum += _)
println(sum) // Prints the sum of 7 + 8 + 9 = 24

================================================================================
The sample code below shows more for() loop examples...

object Demo
{
  def main(args: Array[String])
  {
    type Point = (Double, Double)

    var points:Array[Point]  = Array((-0.3, 0.6), (1.2, 2.3), (3.4, 5.6))
    var result:Array[Double] = for ((x, y) <- points; if magnitude(x, y) < 1.0) yield magnitude(x, y)
    result.foreach(println) // Prints: 0.6708203932499369
    println()
    result = for ((x, y) <- points; if magnitude(x, y) > 1.0) yield magnitude(x, y)
    result.foreach(println) // Prints: 2.5942243542145693, 6.55133574166368
    println()
    // NOTE: The ONLY DIFFERENCE between the following for() loop and the above for()
    //       loop is that below for() loop contains a "distance" value that stores
    //       the value returned by the magnitude() function--so we need to call the
    //       magnitude() function ONLY ONCE every time the for() loop executes.
    result = for ((x, y) <- points; distance = magnitude(x, y); if distance > 1.0) yield distance
    result.foreach(println) // Prints: 2.5942243542145693, 6.55133574166368
    println()
    // Use Multiple Generators here.  (A loop embedded within a loop.)
    for (idx <- 1 to 4; char <-'a' to 'b') println("idx = " + idx +",  char = " + char)
    // PRINTS: idx = 1,  char = a
    //         idx = 1,  char = b
    //         idx = 2,  char = a
    //         idx = 2,  char = b
    //         idx = 3,  char = a
    //         idx = 3,  char = b
    //         idx = 4,  char = a
    //         idx = 4,  char = b
  }

  // This magnitude function calculates the distance between the origin point
  // (x = 0.0, y = 0.0) and the (x, y) coordinate passed to this function.
  def magnitude(x:Double, y:Double):Double = math.sqrt(x*x+y*y)
}

================================================================================
More sample code demonstrating for() loop examples...

import scala.util.control.Breaks

object Demo
{
  def main(args: Array[String])
  {
    // Create a 2-dimensional Array, where the top-level Array contains 100 elements.
    // Each of those 100 Array elements is then populated with a "child" Array having a
    // random number of elements from 3 to 9 (indicies of 0 to 8).  Each element of the
    // "child Array" stores a random number (from 0.0 to 0.999...) generated by math.random
    //
    // util.Random.nextInt(7)   = a value from 0 to 6
    // util.Random.nextInt(7)+3 = a value from 3 to 9
    // NOTE: If an Array has 9 elements, its indicies will be 0 to 8.
    val twoD:Array[Array[Double]] = Array.fill(100) { Array.fill(util.Random.nextInt(7)+3)(math.random) }
    var count:Int = 0;

    // Loop through every element in the twoD Array, and print its contents...
    for (idx <- 0 until twoD.length)
      for (jdx <- 0 until twoD(idx).length)
      {
        count += 1
        println(count + ") twoD(" + idx + ")(" + jdx + ") = " + twoD(idx)(jdx))
      }
    // NOTE: The double for() loop immediately above could be rewritten as follows:
    //       for (idx <- 0 until twoD.length; jdx <- 0 until twoD(idx).length)


    var array:Array[Int] = (0 to 9).toArray // Creates: array(0) = 0, array(1) = 1, array(2) = 2 ... array(9) = 9
    println(array.mkString) // PRINTS: 0123456789

    var list_1:List[Range]  = List(0 to 10 by 5)
    println(list_1) // PRINTS: List(Range 0 to 10 by 5)

    var list_2:List[Int]  = List(0 to 10 by 5: _*)
    println(list_2) // PRINTS: List(0, 5, 10)

    var vect_1:Vector[Range.Inclusive]  = Vector(4 to 7)
    println(vect_1) // PRINTS: Vector(Range 4 to 7)

    var vect_2:Vector[Int]  = Vector(4 to 7: _*)
    println(vect_2) // PRINTS: Vector(4, 5, 6, 7)

    var evenNumbers:Range = new Range(0, 10, 2)
    println(evenNumbers) // PRINTS: Range 0 until 10 by 2
    for (number <- evenNumbers)
    { print(number + " ") } // PRINTS: 0 2 4 6 8
    println

    var oddNumbers:Range  = new Range(1, 9, 2)
    println(oddNumbers) // PRINTS: Range 1 until 9 by 2
    for (number <- oddNumbers)
    { print(number + " ") } // PRINTS: 1 3 5 7
    println

    var intSeq:IndexedSeq[Int] = for (jdx <- 0 to 9) yield jdx*jdx
    intSeq.foreach(println) // PRINTS:  0, 1, 2, 4, 9, 16, 25, 36, 49, 64, 81

    var tomsList:List[Int] = List(95, 96, 97, 98, 99, 100)
    for (number <- tomsList.reverse)
    { println(number) } // PRINTS: 100 99 98 97 96 95

    // if() statements embedded within a for() loop as shown
    // below are known as GUARDS.  When the if() statement is
    // true, the for() loop terminates (exits).  The following
    // FOUR for() loops have identical behavior...
    for ( idx <- 0 to 10  if (idx % 2 == 0  &&  idx > 5) ) println(idx) // PRINTS: 6 8 10
    for { idx <- 0 to 10  if (idx % 2 == 0  &&  idx > 5) } println(idx) // PRINTS: 6 8 10
    for { idx <- 0 to 10  if idx % 2 == 0  if idx > 5 }    println(idx) // PRINTS: 6 8 10
    for ( idx <- 0 to 10  if idx % 2 == 0  if idx > 5 )    println(idx) // PRINTS: 6 8 10

    // How to exit a for loop.  How to break out of a for loop.
    val numList = List(1,2,3,4,5,6,7,8,9,10);
    val loop    = new Breaks; // Obtained via: import scala.util.control.Breaks
    loop.breakable
    {
      for (number <- numList)
      {
        println("number = " + number ); // PRINTS: number = 1  number = 2  number = 3  number = 4

        if (number == 4)
        {
          println("Here, we 'break' out of the for() loop when number = " + number);
          loop.break;
        }
      }
    }
  }
}

================================================================================
HOW TO LOOP THROUGH A MAP

object Demo
{
  def main(args: Array[String])
  {
    val names:Map[String, String] = Map("fname" -> "Robert", "lname" -> "Goren")
    for ((k,v) <- names)
    {
      println(s"key = $k, value = $v")
    }
  }
}

================================================================================
================================================================================
================================================================================

