Functions in Scala can contain multiple parameters within a single
parameter list, as virtually all languages do.  But functions in
Scala can also contain MULTIPLE PARAMETER LISTS.  For example, the
myWhileLoop()() function from the code sample below contains two
separate parameter lists, like this...

def myWhileLoop(testCondition: => Boolean)(codeBlock: => Unit):Unit = { ... }

   1st parameter list: (testCondition: => Boolean)
   2nd parameter list: (codeBlock: => Unit)

Obviously, the "=> Boolean" designates a function that returns a Boolean.
And the "=> Unit" designates a function that returns nothing.  But the
following question arises...

QUESTION: Why is there no data type specified between the
          colon (:) and the rocket (=>) as you may expect?...
          (testCondition: => Boolean)
          (codeBlock: => Unit)

ANSWER:  Because both those arguments do NOT get passed a value (i.e., Int,
         String, Boolean, List[Float], etc.), they actually get passed Scala code.
         Lines of Scala code never represent a data type.  Therefore, no data type
         is specified for the testCondition and codeBlock arguments.

         The testCondition argument literally accepts this expression: (idx < 5),
         which has no data type but evaluates to a Boolean.  So testCondition
         returns Boolean.

         The codeBlock argument literally accepts a block (several lines) of
         Scala code, which of course has no data type.  The last line executed
         in codeBlock doesn't evaluate to anything.  So codeBlock returns Unit.
         
NOTE: It's possible for a block of code to evaluate to a value, and thus have a
      return data type.  For example, if the last line executed in codeBlock
      evaluates to a String, then codeBlock returns a String.  If that were
      the case, the function defined in the sample code below would...
      look like this:   def myWhileLoop(testCondition: => Boolean)(codeBlock: => String):Unit
      instead of this:  def myWhileLoop(testCondition: => Boolean)(codeBlock: => Unit):Unit

object Demo
{
  def main(args: Array[String])
  {
    var idx:Int = 0
    myWhileLoop(idx < 5) // The "idx < 5" expression gets passed to the testCondition
    {                    // parameter of the myWhileLoop()() function.
      // The following 2 lines of code get passed to the codeBlock
      // parameter of the myWhileLoop()() function.
      print("idx = " + idx + ", ") // PRINTS: idx = 0, idx = 1, idx = 2, idx = 3, idx = 4,
      idx += 1
    }
  }

  def myWhileLoop(testCondition: => Boolean)(codeBlock: => Unit):Unit =
  {
    // NOTE: The following line of code can be written using any of these 3 variations:
    //       1) while(testCondition)(codeBlock)
    //       2) while(testCondition){codeBlock}
    //       3) while(testCondition) codeBlock
    while(testCondition)(codeBlock)
  }
}
============================================================
Here's another code example similar to the one above...

object Demo
{
  def main(args: Array[String])
  {
    val age:Int = 19
    val numberOfAccidents:Int = 0

    ifBothTrue(age > 18)(numberOfAccidents == 0) { println("You get to purchase our overpriced insurance!") }

    // Instead of using braces to surrond the second parameter, we can use parenthesis instead...
    ifBothTrue(age > 18)(numberOfAccidents == 0) ( println("You get to purchase our overpriced insurance!") )
  }

  def ifBothTrue(test1: => Boolean)(test2: => Boolean)(codeBlock: => Unit):Unit =
  {
    // NOTE: The following line of code can be written using any of these 3 variations:
    //       1) (test1 && test2){codeBlock}
    //       2) (test1 && test2)(codeBlock)
    //       3) (test1 && test2) codeBlock
    if (test1 && test2){codeBlock}
  }
}
============================================================
This code example demonstrates how a function with multiple
parameter lists can use an implicit parameter.  If a function
gets called numerous times, you may want to use an implicit
parameter so you don't have to keep passing that same parameter
to the function, over and over again.

NOTE: A method/function/constructor can have ONLY ONE implicit parameter
      (regardles of how many parameters or parameter lists exist), and
      and it MUST occur in the LAST parameter list.

object Demo
{
  def main(args: Array[String])
  {
    printIntIfTrue(123)(false) // PRINTS: nothing because the second param is false
    printIntIfTrue(456)(true)  // PRINTS: 456 because the second param is true

    // Because the printIntIfTrue()() function below takes an implicit parameter
    // of type Boolean, and because an implicit Boolean val/var is declared before
    // printIntIfTrue() gets called, printIntIfTrue()() will execute when calling
    // it WITHOUT a second parameter!
    //
    // NOTE: If multiple implicit Boolean vals/vars exist before printIntIfTrue()()
    // gets called without a second parameter, a runtime error occurs.  Multiple
    // implicit vals/vars can exist (without causing an error) as long as they
    // are of different types, as shown below.
    implicit val string_1:String   = "BEER"  // Because printIntIfTrue()() has no String param, this implicit declaration has no effect.
    implicit val boolean_1:Boolean = true
    printIntIfTrue(420) // PRINTS: 420 because the boolean_1 val is true
  }

  def printIntIfTrue(a:Int)(implicit b:Boolean):Unit =
  {
    if (b) { println(a) }
  }
}
