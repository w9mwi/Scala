How to use pattern matching via the Scala keyword "match".
=============================================================
=============================================================
import scala.annotation.switch

object Demo
{
  def main(args: Array[String]): Unit =
  {
    var monthNumber = 7;
    // NOTE:  Use @switch to issue possible warning at compile time AND to improve performance.
    (monthNumber: @switch) match
    {
      case 1  => println("January")
      case 2  => println("February")
      case 3  => println("March")
      case 4  => println("April")
      case 5  => println("May")
      case 6  => println("June")
      case 7  => println("July")
      case 8  => println("August")
      case 9  => println("September")
      case 10 => println("October")
      case 11 => println("November")
      case 12 => println("December")
      // If monthNumber is invalid, catch it and print it...
      case error => println("Invalid month number: " + error.toString)
    }

    monthNumber = 77

    // NOTE:  Use @switch to issue possible warning at compile time AND to improve performance.
    val monthName:String = (monthNumber: @switch) match
    {
      case 1  => "January"
      case 2  => "February"
      case 3  => "March"
      case 4  => "April"
      case 5  => "May"
      case 6  => "June"
      case 7  => "July"
      case 8  => "August"
      case 9  => "September"
      case 10 => "October"
      case 11 => "November"
      case 12 => "December"
      case _  => "Invalid Month"  // the default, catch-all
    }
    println(s"monthNumber = $monthNumber,  monthName = $monthName")
  }
}
=============================================================
=============================================================
object Demo
{
  // Create a case class here, which is used for pattern matching.  When
  // a case class's parameters are NOT specified as val or var, they are
  // val (immutable) by default.
  case class Person(name:String, age:Int)

  def main(args: Array[String])
  {
    // NOTE: Because Person is a case class type, you do NOT need to
    //       use the "new" keyword when creating a new Person object.
    val alice   = Person("Alice",   25)
    val bob     = Person("Bob",     32)
    val charlie = Person("Charlie", 44)
    val tom     = Person("Tom",    999)

    // Here, we create a List holding the 4 Person objects we instantiated
    // above.  Then we loop through each Person in the List.  If the Person
    // in the list matches the name + age params  specified below, we print
    // a greeting.  The last case statement below gets executed when none
    // of the other Person objects match.
    for (person <- List(alice, bob, charlie, tom))
    {
      person match
      {
        case Person("Alice",   25) => println("Hi Alice!")
        case Person("Bob",     32) => println("Hi Bob!")
        case Person("Charlie", 44) => println("Hi Charlie!")
        case Person(name,   age)   => println("Hi " + name + "!" + "  Age = " + age)
      }
    }

    // Print the data for each instantiated class of type Person...
    println()
    println("alice.name = "   + alice.name   + ", alice.age = "   + alice.age)
    println("bob.name = "     + bob.name     + ", bob.age = "     + bob.age)
    println("charlie.name = " + charlie.name + ", charlie.age = " + charlie.age)
    println("tom.name = "     + tom.name +     ", tom.age = "     + tom.age)
  }
}
=============================================================
=============================================================
// The following is a pattern matching example that
// can determine the data type of a val or var.
object Demo
{
  def main(args: Array[String])
  {
    val fruits:Vector[_] = Vector("apple", "banana", "lime", "orange")
    val inches:Float     = 7.89F
    val miles:Double     = 123.45
    val people:Array[_]  = Array("Jack", "Jill", "Joe")
    val screws:Int       = 3
    val veggies:List[_]  = List("beets", "carrots", "spinach")

    println(getClassAsString(fruits))
    println(getClassAsString(inches))
    println(getClassAsString(miles))
    println(getClassAsString(people))
    println(getClassAsString(screws))
    println(getClassAsString(veggies))
  }

  def getClassAsString(x: Any):String = x match
  {
    // NOTE: You can use "case z:" multiple times and all works fine.
    case z: Double    => "Double"
    case z: Float     => "Float"
    case z: Int       => "Int"
    case z: List[_]   => "List"
    case z: String    => "String"
    case z: Vector[_] => "Vector"
    case _            => "Unknown"
  }
}
=============================================================
=============================================================
// Read the comments in the purchaseFood() function
// to understand how this "match" sample code works.
object Demo
{
  type FoodAndPrice = (String, Float)

  val mealA:FoodAndPrice = ("spinach",         1.23F)
  val mealB:FoodAndPrice = ("brusselSprouts",  2.45F)
  val mealC:FoodAndPrice = ("hamburger",       6.16F)
  val mealD:FoodAndPrice = ("sturgeonEggs",   24.30F)
  val mealE:FoodAndPrice = ("potBrownies",     4.20F)
  val mealF:FoodAndPrice = ("pondScum",        0.39F)

  def main(args: Array[String]):Unit =
  {
    println("purchaseFood(mealA) = " +  purchaseFood(mealA))
    println("purchaseFood(mealB) = " +  purchaseFood(mealB))
    println("purchaseFood(mealC) = " +  purchaseFood(mealC))
    println("purchaseFood(mealD) = " +  purchaseFood(mealD))
    println("purchaseFood(mealE) = " +  purchaseFood(mealE))
    println("purchaseFood(mealF) = " +  purchaseFood(mealF))
  }

  def purchaseFood(meal:FoodAndPrice):Boolean =
    meal match
    {
      // If the meal is hamburger, purchase it ONLY if the cost < 6.00.
      case ("hamburger", cost) if cost < 6.00 =>  true
      // If the meal is spinach, purchase it regardless of price.
      case ("spinach", _) => true
      // If the meal is potBrownies, AND the cost < 20.00, purchase the meal.
      case ("potBrownies", cost) if cost < 20.00 =>  true
      // Purchase any  meal that costs less than 5.50.
      case (_, cost) if cost < 5.50 => true
      // If any other criteria, do NOT purchase the meal.
      case _ => false
    }
}
=============================================================
object Demo
{
  // By default, a case class's parameters are val types (when you don't specify
  // a val/var type), so they can NOT be changed.  In the following CaseClassDemo
  // class has its params declared as var types, so they CAN be changed--even
  // if the instance of CaseClassDemo is declared a val.
  case class CaseClassDemo(var str:String, var integer:Int, var float:Float)

  // NOTE: The Email, SMS, VoiceRecording, and TrashNotify case classes declarations
  //       below all extend the Notification class, which is an abstract class.
  //       Therefore, these 4 case classes can be treated as a Notification class.
  abstract class Notification
  case class Email(sender:String, title:String, body:String) extends Notification
  case class SMS(caller:String, message:String) extends Notification
  case class VoiceRecording(contactName:String, link:String) extends Notification
  case class TrashNotify() extends Notification

  def main(args: Array[String])
  {
    val myClass1 = CaseClassDemo("Tom", 321, 56.789F)
    println("myClass1.str = "        + myClass1.str +
            ",  myClass1.integer = " + myClass1.integer +
            ",  myClass1.float = "   + myClass1.float)

    // NOTE: Even though myClass1 is a val type, notice that we can alter its member
    //       values here cuz the parameters of CaseClassDemo are declared as var.
    myClass1.str     = "Jim"
    myClass1.integer = 666
    myClass1.float   = 345.67F
    println("myClass1.str = "        + myClass1.str +
            ",  myClass1.integer = " + myClass1.integer +
            ",  myClass1.float = "   + myClass1.float)

    // We now show how case classes are used for pattern matching.  The following
    // 4 classes were all defined (above) as subclasses of the Notification class.
    // Therefore, all 4 of these classes can be considered a Notification class,
    // and therefore can be used to match on the Notification class in the
    // showNotification function below.
    val someEmail:Email = Email("Sender Bender", "Titletown, USA", "Hi.  See you later.")
    val someSms:SMS = SMS("12345", "Are you there?")
    val someVoiceRecording:VoiceRecording = VoiceRecording("Tom", "www.420.com")
    val someTrash:TrashNotify = TrashNotify()

    println()
    println(showNotification(someTrash))
    println(showNotification(someVoiceRecording))
    println(showNotification(someEmail))
    println(showNotification(someSms))
  }

  def showNotification(notification:Notification):String =
  {
    notification match
    {
      case Email(email, title, _) => s"You have an email from $email with title: $title"
      case SMS(number, message) =>  s"You have an SMS from $number! Message: $message"
      case VoiceRecording(name, link) =>  s"You received a Voice Recording from $name!  To hear it, click: $link"
      case _ => s"This is some other type of Notification message--trash it!"
    }
  }
}
=============================================================
=============================================================
=============================================================
=============================================================
=============================================================
