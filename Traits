You might think that traits are like Java interfaces with concrete methods,
but they can actually do much more.  Traits can, for example, declare fields
and maintain state.  In fact, you can do anything in a trait definition that
you can do in a class definition, and the syntax looks exactly the same,
with only two (2) exceptions...

1) A trait cannot have any "class" parameters, i.e., parameters passed to the
   primary constructor of a class.  In other words, although you could define
   a class like this:
   class Point(x: Int, y: Int)

   The following attempt to define a trait would not compile:
   trait NoPoint(x: Int, y: Int) // Does not compile

2) The difference between classes and traits is that a call to super() in
   a class is statically bound, but in traits a call to super() is
   dynamically bound.

If you write "super.toString" in a class, you know exactly which method
implementation will be invoked.  When you write the same thing in a trait,
however, the method implementation to invoke for the super call is undefined
when you define the trait. Rather, the implementation to invoke will be
determined anew each time the trait is mixed into a concrete class.

===================================================================

A trait is similar to an abstract class in many ways.  The two primary differences are:

1) A Trait cannot take arguments, as an abstract class can.
2) A Trait cannot have constructor parameters.
3) A class can be defined as inheriting from from multiple traits,
   but when the code is executed, behavior from only one trait
   will be implemented.

A trait can only inherit from another trait.  For a trait to inherit
from another trait, the "extends" keyword is used, just as the "extends"
keyword is used for a class to inherit from another class.  However,
a trait can NOT inherit from a class.

Classes do NOT allow multiple inheritance.
Traits DO allow multiple inheritance.

Scala will NOT allow a class to have multiple inheritance, so you can NOT list
multiple classes after the extends keyword.  However, Scala allows a class to
use multiple traits, which is done using the "with" keyword.  Here's an example...

Assume you want to represent a Person, but there are multiple categories
of a Person...  Parent, Child, GeneralAdult, Father, Mother, Male, Female

Since a Father is a Person + Parent + Male, a Father class could NOT inherit
from Person + Parent + Male, because that would be inheriting from multiple
classes, which isn't allowed.  Here is how you could use traits to do this...

trait Person {...}
trait Parent extends Person {...}
trait Male   extends Person {...}
class Father extends Parent with Male {...}

An alternative to constructing a Father class would be to use traits
as mix-in types, like this...

trait Person {...}
trait Parent {...}
trait Male {...}
class Father extends Person with Parent with Male {...}

In this example, Parent and Male are traits that do NOT inherit from the
Person.  Instead, they are MIXED IN with the Person to create Father.
This approach is perhaps a bit more advanced, and if the Parent and Male
types involve code that requires them to know they will be used with a Person,
you will need to use SELF-TYPES, which are discussed in Appendix B of the book.

When coding an abstract type that will be used with inheritance, should
a trait be used, or an abstract class?...  The rule of thumb is to use
a trait because it allows the flexibility of multiple inheritance.  While
a trait cannot take arguments (as can an abstract class), any values that
you'd want to provide as arguments can be put into a trait and left
undefined, so the class that implements the trait will have to provide
those values.

===========================================================================
object Demo
{
  // THIS CODE DEMONSTRATES HOW TO USE A SCALA TRAIT
  trait Iterator[A]
  {
    def hasNext: Boolean
    def next(): A
  }

  class IntIterator(to: Int) extends Iterator[Int]
  {
    private var current = 0
    override def hasNext: Boolean = { current < to }
    override def next(): Int =
    {
      if (hasNext)
      {
        val total = current
        current += 1
        total
      }
      else { 0 } // Once the Iterator is "spent", this "else" statement (which returns zero) always executes.
    }
  }

  /**
    * @param args Arguments passed from the command line.
    */
  def main(args: Array[String])
  {
    val iterator = new IntIterator(10)
    // The 13 print statements below collectively print the following:
    // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 0, 0
    print(iterator.next() + ", ") // PRINTS: 0
    print(iterator.next() + ", ") // PRINTS: 1
    print(iterator.next() + ", ") // PRINTS: 2
    print(iterator.next() + ", ") // PRINTS: 3
    print(iterator.next() + ", ") // PRINTS: 4
    print(iterator.next() + ", ") // PRINTS: 5
    print(iterator.next() + ", ") // PRINTS: 6
    print(iterator.next() + ", ") // PRINTS: 7
    print(iterator.next() + ", ") // PRINTS: 8
    print(iterator.next() + ", ") // PRINTS: 9
    print(iterator.next() + ", ") // PRINTS: 0
    print(iterator.next() + ", ") // PRINTS: 0
    println(iterator.next())      // PRINTS: 0
  }
}
===========================================================================
// SEE: For more details about the following code, read:
//      https://www.safaribooksonline.com/blog/2013/05/30/traits-how-scala-tames-multiple-inheritance/
object Demo
{
  trait Drawable
  {
    def draw() { }
  }

  trait Cowboy extends Drawable
  {
    override def draw() { println("A bang!") }
  }

  trait Artist extends Drawable
  {
    override def draw() { println("A picture painting.") }
  }

  // NOTE: The "with" keyword goes between type names for multiple inheritance.
  //       You can chain on multiple "with X" clauses to mix in more traits.  If
  //       a class is to be part of the extended type, it must be specified BEFORE
  //       the first "with X" clause.  READ ALL IN-LINE COMMENTS BELOW...

  class ArtistCowboy extends Artist with Cowboy // Inherits from trait Artist and trait Cowboy.  (Multiple inheritance.)
  class CowboyArtist extends Cowboy with Artist // Inherits from trait Cowboy and trait Artist.  (Multiple inheritance.)

  def main(args: Array[String])
  {
    val artCow = new ArtistCowboy()
    val cowArt = new CowboyArtist()

    // The artCow and cowArt classes both implement multiple inheritance.  So how does Scala know
    // which draw() method to use, the Cowboy.draw() method or the Artist.draw() method?
    // The answer is the draw() method contained in the LAST class/trait appearing AFTER
    // the "extends" keyword.  So artCow.draw() calls the Cowboy.draw() method, and cowArt.draw()
    // calls the Artist.draw() method...
    artCow.draw() // PRINTS: "A bang!"
    cowArt.draw() // PRINTS: "A picture painting."
  }
}
=======================================================================================
Rich Interface - A rich interface has many methods, which makes it convenient to use
                 because the caller is likely to find a method that exactly matches the
                 functionality she needs.

Thin Interface - A thin interface has fewer methods than a rich interface, so it's easier
                 for the programmer to write a thin interface than a rich interface.
                 However, the programmer who uses a thin interface will likely require
                 her to write more code because the thin interface supplies fewer methods
                 than the rich interface.

Traits can be used to enrich a thin interface, transforming it into a rich interface,
as is shown in the following example...

Look at the Point, Rectangle, and Component classes defined here.  Continue reading below.

class Point(val x: Int, val y: Int)
class Rectangle(val topLeft: Point, val bottomRight: Point)
{
  def left = topLeft.x
  def right = bottomRight.x
  def width = right - left
  // Assume more methods belong to this Rectangle class.
}
abstract class Component
{
  def topLeft: Point
  def bottomRight: Point

  def left = topLeft.x
  def right = bottomRight.x
  def width = right - left
  // Assume more methods belong to this abstract class Component.
}

Notice the left, right, and width methods defined above in the Rectangle class
are identical to the ones defined above in the abstract class Component.
These 3 methods will also likely reside in any other classes representing
rectangular objects.

This repetition can be eliminated with an enrichment trait shown immediately
below that's named Rectangular.  This Rectangular trait has two abstract
methods: one that returns the top-left coordinate of the object, and another
that returns the bottom-right coordinate.  It can then supply concrete
implementations of all the other geometric queries.

trait Rectangular
{
  def topLeft: Point
  def bottomRight: Point

  def left = topLeft.x
  def right = bottomRight.x
  def width = right - left
  // Assume more methods belong to this trait named Rectangular.
}

We can now redefine the above class Rectangle, and abstract class Component,
as follows.  This time, both classes are defined by extending the Rectangular
trait.  In other words, bith these classes "mix in" the Rectangular trait...

abstract class Component extends Rectangular
{
  // Assume more methods belong to this abstract class Component.
}
class Rectangle(val topLeft: Point, val bottomRight: Point) extends Rectangular
{
  // Assume more methods belong to this Rectangle class.
}
=======================================================================================
For more info on Scala Traits SEE P.463 of book, or the following web pages:
https://www.artima.com/pins1ed/traits.html
http://docs.scala-lang.org/tour/traits.html

