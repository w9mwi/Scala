For more info on Scala Traits SEE P.463 of book, or:
http://docs.scala-lang.org/tour/traits.html

A trait is similar to an abstract class in many ways.  The two primary differences are:

1) A Trait cannot take arguments, as an abstract class can.
2) A Trait cannot have constructor parameters.
2) You cannot inherit from more than one trait.

A trait can only inherit from another trait.  For a trait to inherit
from another trait, the "extends" keyword is used, just as the "extends"
keyword is used for a class to inherit from another class.  However,
a trait can NOT inherit from a class.

Classes do NOT allow multiple inheritance.
Traits DO allow multiple inheritance.

Scala will NOT allow a class to have multiple inheritance, so you can NOT list
multiple classes after the extends keyword.  However, Scala allows a class to
use multiple traits, which is done using the "with" keyword.  Here's an example...

Assume you want to represent a Person, but there are multiple categories
of a Person...  Parent, Child, GeneralAdult, Father, Mother, Male, Female

Since a Father is a Person + Parent + Male, a Father class could NOT inherit
from Person + Parent + Male, because that would be inheriting from multiple
classes, which isn't allowed.  Here is how you could use traits to do this...

trait Person {...}
trait Parent extends Person {...}
trait Male   extends Person {...}
class Father extends Parent with Male {...}

An alternative to constructing a Father class would be to use traits
as mix-in types, like this...

trait Person {...}
trait Parent {...}
trait Male {...}
class Father extends Person with Parent with Male {...}

In this example, Parent and Male are traits that do NOT inherit from the
Person.  Instead, they are MIXED IN with the Person to create Father.
This approach is perhaps a bit more advanced, and if the Parent and Male
types involve code that requires them to know they will be used with a Person,
you will need to use SELF-TYPES, which are discussed in Appendix B of the book.

When coding an abstract type that will be used with inheritance, should
a trait be used, or an abstract class?...  The rule of thumb is to use
a trait because it allows the flexibility of multiple inheritance.  While
a trait cannot take arguments (as can an abstract class), any values that
you'd want to provide as arguments can be put into a trait and left
undefined, so the class that implements the trait will have to provide
those values.

===========================================================================
object Demo
{
  // THIS CODE DEMONSTRATES HOW TO USE A SCALA TRAIT
  trait Iterator[A]
  {
    def hasNext: Boolean
    def next(): A
  }

  class IntIterator(to: Int) extends Iterator[Int]
  {
    private var current = 0
    override def hasNext: Boolean = { current < to }
    override def next(): Int =
    {
      if (hasNext)
      {
        val total = current
        current += 1
        total
      }
      else { 0 } // Once the Iterartor is "spent", this "else" statement (which returns zero) always executes
    }
  }

  /**
    * @param args Arguments passed from the command line.
    */
  def main(args: Array[String])
  {
    val iterator = new IntIterator(10)
    // The 13 print statements below collectively print the following:
    // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 0, 0
    print(iterator.next() + ", ") // PRINTS: 0
    print(iterator.next() + ", ") // PRINTS: 1
    print(iterator.next() + ", ") // PRINTS: 2
    print(iterator.next() + ", ") // PRINTS: 3
    print(iterator.next() + ", ") // PRINTS: 4
    print(iterator.next() + ", ") // PRINTS: 5
    print(iterator.next() + ", ") // PRINTS: 6
    print(iterator.next() + ", ") // PRINTS: 7
    print(iterator.next() + ", ") // PRINTS: 8
    print(iterator.next() + ", ") // PRINTS: 9
    print(iterator.next() + ", ") // PRINTS: 0
    print(iterator.next() + ", ") // PRINTS: 0
    println(iterator.next())      // PRINTS: 0
  }
}
