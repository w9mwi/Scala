You might think that traits are like Java interfaces with concrete methods,
but they can actually do much more.  Traits can, for example, declare fields
and maintain state.  In fact, you can do anything in a trait definition that
you can do in a class definition, and the syntax looks exactly the same,
with only two (2) exceptions...

1) A trait cannot have any "class" parameters, i.e., parameters passed to the
   primary constructor of a class.  In other words, although you could define
   a class like this:
   class Point(x: Int, y: Int)

   The following attempt to define a trait would not compile:
   trait NoPoint(x: Int, y: Int) // Does not compile

2) The difference between classes and traits is that a call to super() in
   a class is statically bound, but in traits a call to super() is
   dynamically bound.

If you write "super.toString" in a class, you know exactly which method
implementation will be invoked.  When you write the same thing in a trait,
however, the method implementation to invoke for the super call is undefined
when you define the trait. Rather, the implementation to invoke will be
determined anew each time the trait is mixed into a concrete class.

This curious behavior of super is key to allowing traits to work as stackable
modifications, which will be described in Section 12.5. The rules for resolving
super calls will be given in Section 12.6.

SEE --> http://www.artima.com/pins1ed/traits.html

===================================================================

For more info on Scala Traits SEE P.463 of book, or:
http://docs.scala-lang.org/tour/traits.html

A trait is similar to an abstract class in many ways.  The two primary differences are:

1) A Trait cannot take arguments, as an abstract class can.
2) A Trait cannot have constructor parameters.
3) A class can be defined as inheriting from from multiple traits,
   but when the code is executed, behavior from only one trait
   will be implemented.

A trait can only inherit from another trait.  For a trait to inherit
from another trait, the "extends" keyword is used, just as the "extends"
keyword is used for a class to inherit from another class.  However,
a trait can NOT inherit from a class.

Classes do NOT allow multiple inheritance.
Traits DO allow multiple inheritance.

Scala will NOT allow a class to have multiple inheritance, so you can NOT list
multiple classes after the extends keyword.  However, Scala allows a class to
use multiple traits, which is done using the "with" keyword.  Here's an example...

Assume you want to represent a Person, but there are multiple categories
of a Person...  Parent, Child, GeneralAdult, Father, Mother, Male, Female

Since a Father is a Person + Parent + Male, a Father class could NOT inherit
from Person + Parent + Male, because that would be inheriting from multiple
classes, which isn't allowed.  Here is how you could use traits to do this...

trait Person {...}
trait Parent extends Person {...}
trait Male   extends Person {...}
class Father extends Parent with Male {...}

An alternative to constructing a Father class would be to use traits
as mix-in types, like this...

trait Person {...}
trait Parent {...}
trait Male {...}
class Father extends Person with Parent with Male {...}

In this example, Parent and Male are traits that do NOT inherit from the
Person.  Instead, they are MIXED IN with the Person to create Father.
This approach is perhaps a bit more advanced, and if the Parent and Male
types involve code that requires them to know they will be used with a Person,
you will need to use SELF-TYPES, which are discussed in Appendix B of the book.

When coding an abstract type that will be used with inheritance, should
a trait be used, or an abstract class?...  The rule of thumb is to use
a trait because it allows the flexibility of multiple inheritance.  While
a trait cannot take arguments (as can an abstract class), any values that
you'd want to provide as arguments can be put into a trait and left
undefined, so the class that implements the trait will have to provide
those values.

===========================================================================
object Demo
{
  // THIS CODE DEMONSTRATES HOW TO USE A SCALA TRAIT
  trait Iterator[A]
  {
    def hasNext: Boolean
    def next(): A
  }

  class IntIterator(to: Int) extends Iterator[Int]
  {
    private var current = 0
    override def hasNext: Boolean = { current < to }
    override def next(): Int =
    {
      if (hasNext)
      {
        val total = current
        current += 1
        total
      }
      else { 0 } // Once the Iterartor is "spent", this "else" statement (which returns zero) always executes
    }
  }

  /**
    * @param args Arguments passed from the command line.
    */
  def main(args: Array[String])
  {
    val iterator = new IntIterator(10)
    // The 13 print statements below collectively print the following:
    // 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 0, 0
    print(iterator.next() + ", ") // PRINTS: 0
    print(iterator.next() + ", ") // PRINTS: 1
    print(iterator.next() + ", ") // PRINTS: 2
    print(iterator.next() + ", ") // PRINTS: 3
    print(iterator.next() + ", ") // PRINTS: 4
    print(iterator.next() + ", ") // PRINTS: 5
    print(iterator.next() + ", ") // PRINTS: 6
    print(iterator.next() + ", ") // PRINTS: 7
    print(iterator.next() + ", ") // PRINTS: 8
    print(iterator.next() + ", ") // PRINTS: 9
    print(iterator.next() + ", ") // PRINTS: 0
    print(iterator.next() + ", ") // PRINTS: 0
    println(iterator.next())      // PRINTS: 0
  }
}
===========================================================================
// SEE: For more details about the following code, read:
//      https://www.safaribooksonline.com/blog/2013/05/30/traits-how-scala-tames-multiple-inheritance/
object Demo
{
  trait Drawable
  {
    def draw() { }
  }

  trait Cowboy extends Drawable
  {
    override def draw() { println("A bang!") }
  }

  trait Artist extends Drawable
  {
    override def draw() { println("A picture painting.") }
  }

  // NOTE: The "with" keyword goes between type names for multiple inheritance.
  //       You can chain on multiple "with X" clauses to mix in more traits.  If
  //       a class is to be part of the extended type, it must be specified BEFORE
  //       the first "with X" clause.  READ ALL IN-LINE COMMENTS BELOW...

  class ArtistCowboy extends Artist with Cowboy // Inherits from trait Artist and trait Cowboy.  (Multiple inheritance.)
  class CowboyArtist extends Cowboy with Artist // Inherits from trait Cowboy and trait Artist.  (Multiple inheritance.)

  def main(args: Array[String])
  {
    val artCow = new ArtistCowboy()
    val cowArt = new CowboyArtist()

    // The artCow and cowArt classes both implement multiple inheritance.  So how does Scala know
    // which draw() method to use, the Cowboy.draw() method or the Artist.draw() method?
    // The answer is the draw() method contained in the LAST class/trait appearing AFTER
    // the "extends" keyword.  So artCow.draw() calls the Cowboy.draw() method, and cowArt.draw()
    // calls the Artist.draw() method...
    artCow.draw() // PRINTS: "A bang!"
    cowArt.draw() // PRINTS: "A picture painting."
  }
}
=======================================================================================
Rich Interface - A rich interface has many methods, which makes it convenient because
                 the caller is likely to find a method that exactly matches the
                 functionality she needs.

Thin Interface - A thin interface has fewer methods than a rich interface, so it's easier
                 for the programmer to write a thin interface than a rich interface.
                 However, using a thin interface will likely result in the programmer having
                 to write more code because the thin interface supplies fewer methods
                 than the rich interface.

Traits can be used to enrich a thin interface, transforming it into a rich interface,
as is shown in the following example.
