Scala provides three constructs for creating user-defined types:

1) trait
2) object (Scala has two kinds of object: "case object" and "object")
3) class  (Scala has two kinds of class:  "case class" and "class")

You should use a Scala class (or a Scala object) to represent a "thing"
or an "object", such as Person, Automobile, Aircraft, Animal, etc.

You should use a Scala trait to represent a "behavior", such as
communicate, learn, transport, work, etc.  (Traits aren't covered
here, but in the section titled "Trait".)

CASE CLASS - A Scala "case class" is generally defind in one line of code, like this:

             case class Person(name:String, id:Int) // A case class definition
             val jim = Person("Jim", 98765)         // A case class instantiation

             All values passed to a case class become public members of the case class
             (meaning they can be accessed outside the class) by default.  By default,
             they are vals.  In the case class definition you can precede any argument
             with the "val" or "var" keyword.

             A Scala "case class" is different from a regular Scala class in the following 8 ways...

             1) A regular Scala class generally requires multiple lines of
                code to define it.  But a case class definition (as shown
                above) usually requires just one line of code.

             2) A case class MUST contain one or more args/params in its definition.

             3) Constructor arguments of case classes are treated as public values,
                and can be accessed from outside the case class.

             4) When a case class is instantiated, the following 6 methods become
                available by default, so you never need to write them yourself.

                apply()   - Explained further below
                unapply() - Explained further below
                copy()    - Creates a new "case class" instance that's a copy of the
                            existing case class.  If you pass this copy() method any
                            arguments, those arguments specify the case class member
                            values you want changed in the copied instance.  Calling
                            copy() on a case class does NOT make any changes to the existing
                            case class.  Only the newly-created case class will contain the
                            changes that you specify to its member values.
                equals()  - Determines if two Scala objects are equal.  Read the hashCode()
                            description below.
                hashCode() - Returns an Int value.  If calling hashCode() on two Scala objects
                             return the same Int value, they are equal.  You can use the equals()
                             method or the '==' operator in place of calling hashCode() to
                             determine equivalency.
                toString() - Renders the case class’s name and fields to a String.

             5) A case class is Serializable.

             6) A case class CAN be abstract, like this:   abstract case class Card(id:Int)

             7) A case class CAN'T extend another case class.  But a case class CAN extend
                a regular class OR an abstract class.  The following example will work
                with or without the "abstract" keyword:

                abstract class Card(id:Int)
                case class DebitCard(id:Int, name:String, number:Int) extends Card(id)

             8) A case class can extend a trait, like the following example shows:

                trait Event
                case class ComplexEvent() extends Event


A Scala object always represents a "singleton."  A Scala object
wouldn't be used to represent a person because you'd probably want
the capability to generate multiple persons.  So you'd use a Scala
class (or case class) to represent a person.  A Scala object would
be used to represent planet Earth because only one exists (it's a
singleton).  It wouldn't make sense to create multiple planet
Earth objects or classes.

An object can extend another class, but a class CAN'T extend an object.

Unlike Scala classes, Scala objects can't be instantiated, and can't
be defined to accept arguments.  This means a Scala object can't have
a parameter list.  But a Scala object can contain member values, which
get initialized when an object is referenced for the first time.

Quite often a Scala object is used as a "companion object" to a
regular Scala class.  Companion objects are companions to ONLY
regular Scala classes, not case classes.  If you choose to write
your own apply() or unapply() method for a class, you place them
inside the companion object.  (To understand apply() and unapply()
methods keep reading.)  You wouldn't create a companion object for
a Scala "case class" because Scala automatically generates both an
apply() and unapply() method for a "case class".

There are three reasons for a regular Scala class to have a companion object:

1) So you can define your own apply() method for the class, instead of using
   Scala's default apply() method.  However, there's usually no reason to
   write your own apply() method for a class, so it's rarely done.
2) To perform pattern matching on the class.  To accomplish that requires
   you to define an unapply() method in the companion object.
3) A companion object can be used to contain values (vals, vars) or methods
   that are singletons.  Singletons are values or methods in the companion
   object that apply to all instances of the companion class.  The vals/vars
   contained in an object get initialized only once--the first time the object
   is referenced.

A companion object must always meet the following 3 criteria:

1) The companion object MUST have the identical name as the class.
2) The companion object MUST be contained in the same file as the class.
3) The companion object MUST contain an ONLY singleton values (vals/vars)
   and singleton methods, which means they apply to, and can be invoked on,
   all instances of the companion class.

Two of the most common methods contained in a companion object are:

1) apply() - This method gets invoked whenever a class is instantiated, and it
             literally performs the class's instantiation.  Scala provides an
             apply() method for all classes by default, so you don't have to write
             your own.  Rarely is there a good reason to write your own apply()
             method, but that option is available if you need it.
2) unapply()    - The unapply() method gets invoked automatically whenever pattern
                  matching is performed on a class.  Scala doesn't provide a default
                  unapply() method for regular classes (only for case classes).
                  So you must write your own unapply() method (inside the companion
                  object) if you want to perform pattern matching on a regular class.
   unapplySeq() - An unapplySeq() method takes the place of unapply() when you want
                  to deconstruct an unknown (variable number) of arguments for pattern
                  matching.  That variable number of arguments gets passed to the
                  companion class when the companion class gets instantiated.

CASE OBJECT - Just as you can create a "case class" in Scala, you can also create
              a "case object."  A "case object" differs from a regular object in
              these ways.
              1) A case object is serializable.
              2) A case object has a default hashCode() implementation.
              3) A case object has an improved toString implementation.

              The use of case objects is not so common, but they are used
              for enumerations.  Like this, for example:

              sealed trait Topping
              case object Cheese    extends Topping
              case object Pepperoni extends Topping
              case object Sausage   extends Topping
              case object Mushrooms extends Topping
              case object Onions    extends Topping
               

Scala also has the following type of classes.  This page
doesn't discuss these class types.

* Anonymous class
* Generic class
* Implicit class
* Inner class

===============================================================================
There are three (3) main levels of visibility in Scala, they are:

1) public (default) - There does NOT exist a public keyword in Scala.  If you want
                      something public, it's public BY DEFAULT, which means you
                      wouldn't use the private or protected keyword.  If the
                      visibility level is public, a class's val/var member or
                      method is accessible by code inside, or outside, the class.
2) private - A "private" declaration means a class's val/var member or method
             can be accessed only inside the class.  If you prefix a declaration
             inside a class with the private keyword, that member will be visible
             to that class only.  This means a private method is NOT made avaiable
             to subclasses.
3) protected - A protected declaration is much like private, except protected class
               members are also accessible in subtypes (children) of the class.
               This means a protected method IS made available to subclasses.

===============================================================================

Below are some code samples demonstrating how to use:

* Scala classes
* Scala objects
* companion objects
* apply() method
* unapply() method
* pattern matching

The following are some differences and similarities betweeen a Scala
"case class" and a regular Scala class.

1) By default, arguments in a case class definition parameter list automatically
   become member values of the case class when the case class is instantiated.
   By default, those members are vals.  If you want an argument to be a var,
   you must precede the argument (in the case class definition parameter list)
   with the keyword "var".

2) In a regular class, arguments contained in the class definition DON'T become
   members of the class by default--they are just values passed to the class that
   can be referenced inside the class (they can't be referenced outside the class).
   If you want arguments passed to a regular class to become member values (so
   they can be referenced outside the class), you must precede the argument
   (in the class definition parameter list) with the keyword "val" or "var".

3) For a "case class" Scala provides both an apply() and an unapply() method
   by default.  So for a Scala case class you NEVER write your own apply()
   or unapply() methods.

4) A regular Scala class provides an apply() method by default, which gets
   called automatically when you instantiate a class.  If you want to write
   your own apply() method, you can do so by putting it inside a "companion
   object".
   
5) A regular Scala class doesn't provide an unapply() method, which is used
   for pattern matching on the class.  If you want to perform pattern matching
   on a regular Scala class, you can write your own unapply() method and put
   it inside a "companion object".

=============================================================================
OBJECT TYPES - Read in-line comments in the sample code below to understand
               the difference between an "object type" and a "class type."

object Demo
{
  class Kid(name:String, age:Int) {
    def greeting():String = s"My name is $name, I am $age years old."
  }
  object Kid {
    val IS_ADULT:Boolean            = false
    val IS_COLLEGE_GRADUATE:Boolean = false
  }

  def main(args: Array[String]):Unit = {
    val kidClass:Kid = new Kid("Jane Train", 13)
    println(s"${kidClass.greeting}") // PRINTS: My name is Jane Train, I am 13 years old.

    // IMPORTANT: A Kid class has the type:  Kid
    //            A Kid object has the type: Kid.type
    //
    // If you uncomment the following commented-out line, it WON'T COMPILE!
    // It won't compile because kid_1 is defined as type Kid, which
    // is the type of the Kid CLASS.  And we're trying to assign Kid
    // (which is the OBJECT Kid) to a CLASS of type Kid.
    // val kid_1:Kid = Kid

    // The following line of code WILL COMPILE because kid_2 is defined
    // as type Kid.type.  Kid.type is the type of a Kid OBJECT.  Therefore,
    // Kid (which is a Kid OBJECT) can be assigned to kid_2.
    val kid_2:Kid.type = Kid
  }
}

===============================================================================

The following code sample demonstrates how to use a "case class."

object Demo
{
  // This is a case class definition.  A case class
  // differs in some ways from a regular class.
  case class Person(firstName:String, lastName:String)

  /**************************************************
   * main()
   **************************************************/
  def main(args: Array[String]): Unit = {
    val joe:Person = Person("Joe", "Blow")
    println(s"1) joe.firstName = ${joe.firstName},  joe.lastName = ${joe.lastName}")
    // PRINTS: 1) joe.firstName = Joe,  joe.lastName = Blow

    joe match {
      case x => println(s"2) x.firstName = ${x.firstName},  x.lastName = ${x.lastName}")
      // PRINTS: 2) x.firstName = Joe,  x.lastName = Blow
      case _ => println("NO PATTERN MATCH")
    }

    joe match {
      case Person(fn, ln) => println(s"3) fn = $fn,  ln = $ln") // PRINTS: 3) fn = Joe,  ln = Blow
      case _ => println("NO PATTERN MATCH")
    }

    // The following line of code doesn't seem to make sense because it's NOT
    // very intuitive.  The following line of code is an assignment statement
    // which performs a pattern match on "val joe" by automatically invoking
    // the Person.unapply() method.  The Person.unapply() method extracts
    // joe.firstName and joe.lastName from val joe, then assigns them to the
    // vals "first" and "last" respectively.
    // NOTE: If the following line contained the keyword var instead of val,
    //       then first and last would become vars instead of vals.
    val Person(first, last) = joe
    println(s"4) first = $first,  last = $last") // PRINTS: 4) first = Joe,  last = Blow
  }
}

===============================================================================

The following code sample demonstrates how to use a regular class,
its companion object, the apply() and unapply() methods, and some
pattern matching.

object Demo
{
  // The line of code below defines a Person class.  (NOTE: Person is defined
  // here as a regular class, not a "case class.")  In a regular class, an
  // argument that's not preceded with the "val" or "var" keyword remains only
  // an argument, and doesn't become a member of the class.  (FYI, in a case class
  // all arguments become members of the case class automatically, even if they're
  // not preceded with the "val" or "var" keyword--by default, they're vals.)
  //
  // Because the firstName and lastName arguments passed to Person in the line
  // below are preceded by the val keyword, firstName and lastName become
  // members of the Person class.  So when a Person class is instantiated,
  // its members (firstName and lastName) get initialized.
  class Person(val firstName: String, val lastName: String)

  /**************************************************
   *  When you define a regular class (not a case class) that accepts
   *  constructor argument(s), you can also define a companion object,
   *  but it's not required.  In this example the object Person defined
   *  below becomes the companion object to the Person class defined above.
   **************************************************/
  object Person {
    // Scala automatically invokes this apply() method
    // when a Person class is instantiated.
    def apply(firstName:String, lastName:String): Person = {
      new Person(firstName, lastName) // Don't forget to include the "new" keyword!
    }
    // Scala automatically invokes this unapply() method when
    // pattern matching is performed on a Person class.
    def unapply(person:Person):Some[(String, String)] = {
      Some(person.firstName, person.lastName)
    }
  }

  /**************************************************
   * main()
   **************************************************/
  def main(args: Array[String]): Unit = {
    val joe:Person = Person("Joe", "Blow") // Person.apply() automatically gets called.
    println(s"1) joe.firstName = ${joe.firstName},  joe.lastName = ${joe.lastName}")
    // PRINTS: 1) joe.firstName = Joe,  joe.lastName = Blow

    // The following match statement DOESN'T require the Person.unapply() method!
    joe match {
      case x => println(s"2) x.firstName = ${x.firstName},  x.lastName = ${x.lastName}")
      // PRINTS: 2) x.firstName = Joe,  x.lastName = Blow
      case _ => println("NO PATTERN MATCH")
    }

    // The following line of code WON'T COMPILE without the Person.unapply() method.
    // The following match statement automatically invokes the Person.unapply() method.
    joe match {
      case Person(fn, ln) => println(s"3) fn = $fn,  ln = $ln") // PRINTS: 3) fn = Joe,  ln = Blow
      case _ => println("NO PATTERN MATCH")
    }

    // The following line of code WON'T COMPILE without the Person.unapply() method.
    // The following line of code doesn't seem to make sense because it's NOT
    // very intuitive.  The following line of code is an assignment statement
    // which performs a pattern match on "val joe" by automatically invoking
    // the Person.unapply() method.  The Person.unapply() method extracts
    // joe.firstName and joe.lastName from val joe, then assigns them to the
    // vals "first" and "last" respectively.
    // NOTE: If the following line contained the keyword var instead of val,
    //       then first and last would become vars instead of vals.
    val Person(first, last) = joe
    println(s"4) first = $first,  last = $last") // PRINTS: 4) first = Joe,  last = Blow
  }
}


===============================================================================

The following code sample contains no Scala classes, and therefore no companion objects.
All of the objects are pure singleton objects, not associated with any companion class.
This code demonstrates more complex examples of how to use pattern matching, including
using the unapplySeq() method for dealing with an unknown (variable) number of arguments.

import java.time.{LocalDate, LocalDateTime, LocalTime}
object Demo
{
  object DateTime {  // A pure singleton object, not associated with a companion class.
    def unapply(dt: LocalDateTime): Some[(LocalDate, LocalTime)] =
      Some((dt.toLocalDate, dt.toLocalTime))
  }

  object Date {  // A pure singleton object, not associated with a companion class.
    def unapply(date: LocalDate): Some[(Int, Int, Int)] =
      Some((date.getYear, date.getMonthValue, date.getDayOfMonth))
  }

  object Time {  // A pure singleton object, not associated with a companion class.
    def unapply(time: LocalTime): Some[(Int, Int, Int)] =
      Some((time.getHour, time.getMinute, time.getSecond))
  }

  // When an unknown (variable) number of arguments must be
  // extracted from a class, the unapply() method won't work.
  // When you need to extract an unknown (variable) number of
  // arguments from a class, you must write an unapplySeq()
  // method.  Just as Scala automatically invokes the unapply()
  // method in a companion object, Scala automatically invokes
  // the unapplySeq() method when it's called for.
  object DateTimeSeq {  // A pure singleton object, not associated with a companion class.
    def unapplySeq(dt: LocalDateTime):Some[Seq[Int]] = {
      Some(Seq(dt.getYear, dt.getMonthValue, dt.getDayOfMonth,
               dt.getHour, dt.getMinute,     dt.getSecond))
    }
  }

  // Notice the if() statement embedded within the match/case statement,
  // which allows more flexibility.  When the if() statement is true,
  // the match is successful.  When it's false, the match fails.
  object AM {  // A pure singleton object, not associated with a companion class.
    def unapply(time: LocalTime):Option[(Int, Int, Int)] = {
      time match {
        case Time(hour, minute, second) if (hour < 12) => Some((hour, minute, second))
        case _ => None  // No match above is successful.
      }
    }
  }

  // Notice the if() statement embedded within the match/case statement,
  // which allows more flexibility.  When the if() statement is true,
  // the match is successful.  When it's false, the match fails.
  object PM { // A pure singleton object, not associated with a companion class.
    def unapply(time: LocalTime):Option[(Int, Int, Int)] = {
      time match {
        case Time(12, minute, second) => Some(12, minute, second)
        case Time(hour, minute, second) if (hour > 12) => Some(hour-12, minute, second)
        case _ => None  // No match above is successful.
      }
    }
  }

  /**************************************************
   * main()
   *************************************************/
  def main(args: Array[String]): Unit = {
    // The pattern match performed on the following line of code will succeed
    // because it's written properly.  When it succeeds, year, month, and date
    // become Int vars, which are used in the following println statement.
    var Date(year, month, date) = LocalDate.now
    println(s"Date_1 = ${getMonthName(month)} $date, $year")

    // The pattern match performed on the following line of code will succeed
    // because it's written properly.  When it succeeds, hour, minute, and date
    // become Int vars, which are used in the following println statement.
    var Time(hour, minute, second) = LocalTime.now
    println(s"Time_1 = $hour:$minute:$second")

    Thread.sleep(2000) // Wait 2 seconds.

    // The following line of code obtains the same Date and Time information
    // as the above examples,  but in a single line of code.  Hovever the
    // following pattern match format is different than the one above.
    // NOTE: Even though year, hour, etc. are declared above as vars,
    //       they CAN'T be reused again in the following pattern match.
    //       This is because they've already been declared, and the
    //       following line of code would try to declare them a second
    //       time.  That's is why year2, hour2, etc. are used instead.
    var DateTime(Date(year2, month2, date2), Time(hour2, minute2, second2)) = LocalDateTime.now
    println(s"Date_2 = ${getMonthName(month2)} $date2, $year2")
    println(s"Time_2 = $hour2:$minute2:$second2")

    Thread.sleep(2000) // Wait 2 seconds.
    // To understand the following line of code, read comments in the getTimeString() method.
    println(s"Time_3 = ${getTimeString(LocalTime.now)}")

    // The following line of code obtains a subset of the information returned
    // by the call to LocalDateTime.now.  We're not interested in obtaining
    // the minutes or seconds from LocalDateTime.now.  So instead of supplying
    // var names of minutes and seconds, we specify "_*", which accepts a
    // variable number of arguments that we ignore.
    var DateTimeSeq(year3, month3, date3, hour3, _*) = LocalDateTime.now
    println(s"Date_4 = ${getMonthName(month3)} $date3, $year3")
    println(s"Time_4 = $hour3:??:??")
  }

  /************************************************
   * This getMonthName() method performs standard,
   * easy-to-understand pattern matching.
   ***********************************************/
  def getMonthName(monthNumber: Int):String = {
    monthNumber match {
      case 1 => "January";   case  2 => "February"; case  3 => "March";    case  4 => "April";
      case 5 => "May";       case  6 => "June";     case  7 => "July";     case  8 => "August";
      case 9 => "September"; case 10 => "October";  case 11 => "November"; case 12 => "December";
      case _ => "NO MATCH"
    }
  }

  /************************************************
   * This getTimeString() method gets passed an argument
   * of type Time.  It converts that Time value into a
   * String by performing the following 3 transfomations
   * then returns that String.
   *
   * 1) Zero-fills the minute and second values when they're < 10.
   * 2) Converts 24-hour time into 12-hour time with AM or PM appended.
   * 3) Appends to that String the exact value of Time passed to this method.
   *
   * This method performs a pattern match on localTime, which is passed
   * to this method.  The "match" keyword automatically invokes a call
   * to AM.unapply().  If localTime passed to this method matches the
   * AM(h, m, s) pattern, AM.unapply() returns a Time value, meaning the
   * pattern match succeeded.  If the pattern match succeeded, the syntax
   * "time @ AM(h, m, s)" binds localTime to "time" which, is a val.  The
   * formatted String after the rocket (=>) is then returned by this method.
   *
   * If AM.unapply() returns None, that pattern match failed.  So the
   * next line of code is executed, which works the same as the first
   * line of code.// The following 2 lines of code explained...
   * A pattern match is performed on localTime, which is passed to this method.
   * The "match" keyword automatically invokes a call to AM.unapply().  If
   * localTime passed to this method matches the AM(h, m, s) pattern,
   * AM.unapply() returns a Time value, meaning the pattern match succeeded.
   * If the pattern match succeeded, the syntax  "time @ AM(h, m, s)"  binds
   * localTime to "time" which, is a val.  The formatted String after the
   *  rocket (=>) is then returned by this method.
   *
   * If AM.unapply() returns None, that pattern match failed.  So the
   * next line of code is executed, which works the same as the first
   * line of code.
   ***********************************************/
   def getTimeString(localTime:LocalTime):String = {
     localTime match {
       case time @ AM(h, m, s) => f"$h%2d:$m%02d:$s%02d AM ($time precisely)"
       case time @ PM(h, m, s) => f"$h%2d:$m%02d:$s%02d PM ($time precisely)"
    }
  }
}

===============================================================================
===============================================================================

The syntax used for defining getter and setter methods for regular Scala
classes is rather strange.  The following code demonstrates how to use
getter and setter methods for standard Scala classes.  Read the comments
for details.  For more info on Scala classes see:
http://docs.scala-lang.org/tour/classes.html

object Demo
{
  class Point
  {
    private var _x = 0
    private var _y = 0
    private val bound = 100

    def x = { _x } // This is a getter method.
    // The method below is a setter method.  There must be no whitespace before or after the _ character for x_=
    def x_= (newValue: Int): Unit =
    {
      if (newValue < bound) _x = newValue
      else printWarning
    }

    def y = { _y } // This is a getter method.
    // The method below is a setter method.  There must be no whitespace before or after the _ character for y_=
    def y_= (newValue: Int): Unit =
    {
      if (newValue < bound) _y = newValue
      else printWarning
    }

    private def printWarning = println("WARNING: Out of bounds!")
  }

  def main(args: Array[String]) =
  {
    val point1 = new Point

    // The following 2 lines call the above setter methods x_= and y_=
    point1.x = 99  // This line calls the x_= setter method.
    point1.y = 101 // This line calls the y_= setter method.

    // The following 2 lines call the above getter methods x and y
    println("point1.x = " + point1.x) // This line calls the x getter method.
    println("point1.y = " + point1.y) // This line calls the y getter method.
  }
}

==========================================================================
The following sample code shows a difference between a regular class and
a case class.  If the class Student_2 doesn't contain a "val" or "var"
keyword before the name and id arguments, then john_2.name and john_2.id
references in the println() statement will fail to compile.

Without a "val" or "var" preceding an argument in a regular class,
the argument remains only an argument, and doesn't become a member
of the class (as it does in a case class).  Often, you do NOT want
a member of a class visible outside the class.  So when you do NOT
want an argument passed to a class constructor visible outside the
class, you will use a regular class instead of a case class.

You can reference john_1.name john_1.id in case class Student_1 when the
class Student_2 does NOT contain a "val" or "var" keyword!  Because all
arguments passed to a case class become members of the case class, and
are therefore VISIBLE to code outside the case class.
===============================================================================
object Demo
{
  def main(args: Array[String]):Unit =
  {
    val john_1 = new Student_1("John Doe", "0123456")
    val john_2 = new Student_2("John Doe", "0123456")

    println("john_1.name = " + john_1.name + ", john_1.id = " + john_1.id)
    println("john_2.name = " + john_2.name + ", john_2.id = " + john_2.id)
  }

  // All arguments passed to a case class become members of the case class.
  case class Student_1(var name:String, var id:String)

  // If the name and id arguments below are NOT preceded with a "val"
  // or "var" keyword, the above println will fail to compile!  This
  // is because arguments passed to a regular class do NOT become
  // members of the class unless those arguments are preceded with
  the "val" or "var" keyword.
  class Student_2(var name:String, var id:String)
  {
  }
}
===============================================================================

SOME ADVANCED VISIBILITY OPTIONS
================================
In addition to the above-mentioned modifiers, Scala has other visibility modifiers.
The keywords 'private' and 'protected' can be followed by square brackets [], and
the name of an enclosing scope of one of the following...
1) package
2) class
3) trait
4) object
If you want to a make a method available to all members of the current package
(aka, “package scope”), mark the method as being private to the current package,
with the private[packageName] syntax as in this example:

package com.acme.coolapp.model
{
    class Foo
    {
        private[model] def doX {}
        private def doY {}
    }
    class Bar
    {
        val f = new Foo
        f.doX  // compiles
        f.doY  // won't compile
    }
}

These advanced modifiers will make class members publicly visible for everything
at that scope and closer to the declaration.  The benefit of this is that special
access can be attained for closely-related code without making a member public
to the entire world.  For more details regarding scope, go to this URL...
--> https://alvinalexander.com/scala/how-to-control-scala-method-scope-object-private-package

The following code shows how private[this] differs from the standard private declaration.
Read the comments at the top of the Account class definition...

object Demo
{
  def main(args: Array[String]):Unit =
  {
    val myAccount = new Account

    myAccount.deposit(111)
    println("myAccount.bal = " + myAccount.balance) // PRINTS: myAccount.bal = 111

    myAccount.modifyBalDirectly(222)
    println("myAccount.bal = " + myAccount.balance) // PRINTS: myAccount.bal = 222

    myAccount.modifyBalViaArgument(myAccount, 333)  // Read the Account class comments below.
    println("myAccount.bal = " + myAccount.balance) // PRINTS: myAccount.bal = 333
  }

  /**
    * NOTE: If you replace this line of code:  private var bal = 0
    *       with this line of code:            private[this] var bal = 0
    *       the modifyBalViaArgument() function WILL NOT COMPILE cuz it's
    *       attempting to modify bal via an externally-declared class,
    *       which isn't allowed when it's a private[this] declaration.
    */
  class Account
  {
    private var bal = 0
    // private[this] var bal = 0

    def deposit(amount:Int):Boolean =
    {
      if (amount > 0) { bal += amount; true } else false
    }
    def withdraw(amount:Int):Boolean =
    {
      if (amount > 0 && amount < balance) { bal -= amount; true } else false
    }
    def modifyBalDirectly(value:Int):Unit = { bal = value }
    def modifyBalViaArgument(accountA:Account, value:Int):Unit = { accountA.bal = value }
    def balance = bal
  }
}

====================================================================================
AUXILIARY CLASS CONSTRUCTORS
----------------------------
A Scala Class can have multiple constructors.  The "default" constructor
is known as the "primary constructor".  The programmer can create additional
class constructors known as "auxiliary constructors" by defining them inside
the class, using the "this" keyword as the following example shows.
NOTE: The equal sign (=) in the constructor is optional--it's NOT required.

def this(arg1:datatype, arg2:datatype) = { Constructor code here. }

The following code contains TWO (2) auxiliary constructors defined
by the programmer.  The programmer never defines the primary
constructor because Scala defines it by default.


object Demo
{
  class Company
  {
    private var companyName:String = ""
    private var noOfEmployees:Int  = 0

    def show()
    {
      println("Company Name: " + companyName + " - Number of Employees: " + noOfEmployees)
    }

    // This Auxiliary Constructor contains one argument...
    def this(companyName: String)
    {
      this() // Calls the primary constructor, which is always available by default.
      this.companyName = companyName
    }

    // This Auxiliary Constructor contains two arguments...
    def this(companyName:String, noOfEmployees:Int)
    {
      this(companyName) // Calls the Auxiliary Constructor that has one argument.
      this.noOfEmployees = noOfEmployees
    }
  }


  def main(args: Array[String])
  {
    // Calls the Primary Constructor, which contains zero arguments...
    val company1 = new Company()
    company1.show() // PRINTS: Company Name:  - Number of Employees: 0

    // Calls the auxiliary constructor containing one argument...
    val company2 = new Company("Joe's Pipes, Inc.")
    company2.show() // PRINTS: Company Name: Joe's Pipes, Inc. - Number of Employees: 0

    // Calls the auxiliary constructor containing two arguments...
    val company3= new Company("Hard-Rock Cement Company", 42)
    company3.show() // PRINTS: Company Name: Hard-Rock Cement Company - Number of Employees: 42
  }
}
====================================================================================
