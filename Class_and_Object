Scala provides three constructs for creating user-defined types:

1) trait
2) object (Scala has two kinds of object: "case object" and "object")
3) class  (Scala has two kinds of class:  "case class" and "class")

Use a Scala trait to represent a "behavior", such as communicate, learn,
transport, work, etc.  (Traits aren't covered here, but in the section
titled "Trait".)

Use a Scala class, or Scala object, to represent a thing/object.

When there can exist ONLY ONE of a thing/object (for example, planet
Earth), use a Scala object.  A Scala object must always represent
a singleton (a single entity), which means you CAN'T instantiate a
Scala object.

When there can exist MULTIPLE things/objects (for example, a Person),
use a Scala class.  A Scala class can be instantiated any number of
times to represent any number of classes of the same type (such as Person).

DIFFERNCES BETWEEN A SCALA "case class" AND A SCALA "class"
===========================================================
A Scala "case class" is different from a regular Scala class in the following 9 ways...

1) A regular Scala class generally requires multiple lines of code
   to define it.  But a case class definition usually requires just
   one line of code, like this:

   case class Person(name:String, id:Int) // A case class definition
   val jim = Person("Jim", 98765)         // A case class instantiation

2) A case class MUST contain one or more args/params in its definition,
   while a regular class can contain zero (or multiple) args/params.

3) The args/params passed to a case class automatically become PUBLIC values
   by default--so they can be accessed repeatedly, from outside the case class,
   after the case class is instantiated.

   The args/params passed to a regular class become PRIVATE values by default.
   So its args/params can be accessed only within the body of the class, when
   the class is instantiated.

4) When the definition of a regular class, or a case class, doesn't precede
   its args/params with the "val" or "var" keyword, the args/params become
   "val" by default.  If you want an arg/param to become a "var", you must
   precede it with the "var" keyword.

5) When a case class is instantiated, the following 6 methods become
   available by default, so you never need to write them yourself.

   apply()   - Explained further below
   unapply() - Explained further below
   copy()    - Creates a new "case class" instance that's a copy of the
               existing case class.  If you pass this copy() method any
               args/params, those args/params specify the case class member
               values you want changed in the copied instance.  Only the
               newly-created case class will contain the changes you specify
               via the args/params.  (Calling copy() on a case class DOESN'T
               make any changes to the copied-from case class.)
   equals()  - Determines if two Scala objects are equal.  Read the hashCode() description below.
   hashCode() - Returns an Int value.  If calling hashCode() on two Scala objects
                return the same Int value, they are equal.  You can use the equals()
                method or the '==' operator in place of calling hashCode() to
                determine equivalency.
   toString() - Renders the case class’s name and fields to a String.

6) A case class is Serializable.

7) A case class CAN be abstract, like this:   abstract case class Card(id:Int)

8) A case class CAN'T extend another case class.  But a case class CAN extend
   a regular class OR an abstract class.  The following example will work
   with or without the "abstract" keyword:

   abstract class Card(id:Int)
   case class DebitCard(id:Int, name:String, number:Int) extends Card(id)

9) A case class can extend a trait, like the following example shows:

   trait Event
   case class ComplexEvent() extends Event


EXPLANATION OF A SCALA "object"
===============================
A Scala object always represents a singleton, which means the
object always represents a single entity.  Because an object
is a singleton, you CAN'T instantiate a Scala object.  So a
Scala object would be used to represent something like planet
Earth, because there is only one Earth.

You wouldn't use a Scala object to represent a Person because there
can be multiple people.  Instead, you would use a Scala class to
represent a Person.  For each Person, you would instantiate a new
Person class.

An object can extend a class, but a class CAN'T extend an object.

Unlike Scala classes, Scala objects CAN'T be instantiated and CAN'T
contain args/params!  Instead of args/params, a Scala object can
contain member values, which get initialized within the object the
the first time the object is referenced.

Quite often a Scala object is used as a "companion object" to a
regular Scala class.  Companion objects are companions ONLY to
regular Scala classes, not case classes.  If you choose to write
your own apply() or unapply() method for a class, you must place them
inside a corresponding companion object.  (To understand apply() and
unapply() methods keep reading.)  You wouldn't create a companion
object for a Scala "case class" because Scala automatically generates
both an apply() and unapply() method for a "case class".

There are three reasons for a regular Scala class to have a companion object:

1) So you can define your own apply() method for the class, instead of using
   Scala's default apply() method.  However, there's usually no reason to
   write your own apply() method for a class, so it's rarely done.
2) To perform pattern matching on the class.  To accomplish that requires
   you to define an unapply() method in the companion object.
3) A companion object can be used to contain values (vals, vars) or methods
   that are singletons.  Singletons are values or methods in the companion
   object that apply to all instances of the companion class.  The vals/vars
   contained in an object get initialized only once--the first time the object
   is referenced.

A companion object always meets these 4 criteria:

1) The companion object MUST have the identical name as the class.
2) The companion object MUST be contained in the same file as the class.
3) All vars/vals within the companion object are singleton values, and
   can be accessed by all instances of the companion class.
4) All methods within the companion object can be invoked on all
   instances of the companion class.

Two of the most common methods contained in a companion object are:

1) apply() - This method gets invoked whenever a class is instantiated, and it
             literally performs the class's instantiation.  Scala provides an
             apply() method for all classes by default, so you don't have to write
             your own.  Rarely is there a good reason to write your own apply()
             method, but that option is available if you need it.

2) unapply() OR unapplySeq()...

   unapply() - The unapply() method gets invoked automatically whenever pattern
               matching is performed on a class.  Scala doesn't provide a default
               unapply() method for regular classes (only for case classes).
               If you want to perform pattern matching on a regular class, you
               must write your own unapply() method inside the companion object.
   unapplySeq() - An unapplySeq() method takes the place of unapply() when you want
                  to deconstruct an unknown (variable number) of arguments for pattern
                  matching.  That variable number of arguments gets passed to the
                  companion class when the companion class gets instantiated.


EXPLANATION OF A SCALA "case object"
====================================
Just as you can create a "case class" in Scala, you can also create
a "case object."  A "case object" differs from a regular object in
these ways.
1) A case object is serializable.
2) A case object has a default hashCode() implementation.
3) A case object has an improved toString implementation.

The use of case objects is NOT common, but they are used for enumerations.
Like this, for example:

sealed trait Topping
case object Cheese    extends Topping
case object Pepperoni extends Topping
case object Sausage   extends Topping
case object Mushrooms extends Topping
case object Onions    extends Topping

Scala also has the following type of classes.
This page doesn't discuss these class types.

* Anonymous class
* Generic class
* Implicit class
* Inner class

Below are some code samples demonstrating:

* When an object and a class have identical names, how can the
  code determine if it's referencing the object or the class?
* Scala classes
* Scala objects
* Scala companion objects
* apply() method
* unapply() method
* pattern matching

=============================================================================
When a piece of code contains both an object and a class with identical
names, the object is usually a "companion object" to the class.  In the
following code example, that is NOT the case.

In this example, we show how to assign an object to a val, where the name
of the object (Kid) is identical to the class's name.  For the compiler to
determine you want to assign the Kid object (not the Kid class) to the
val, you must call ".type" on Kid, as is shown in the code below.

object Demo
{
  class Kid(name:String, age:Int) {
    def greeting():String = s"My name is $name, I am $age years old."
  }
  object Kid {
    val IS_ADULT:Boolean            = false
    val IS_COLLEGE_GRADUATE:Boolean = true
  }

  def main(args: Array[String]):Unit = {
    val kidClass:Kid = new Kid("Jane Train", 13)
    println(s"${kidClass.greeting}") // PRINTS: My name is Jane Train, I am 13 years old.

    // IMPORTANT: The Kid class has the type:  Kid
    //            The Kid object has the type: Kid.type
    //
    // If you uncomment the following commented-out line, it WON'T COMPILE!
    // It won't compile because kid_1 is defined as type Kid, which
    // is the type of the Kid CLASS.  And we're trying to assign Kid
    // (which is the OBJECT Kid) to a CLASS of type Kid.
    // val kid_1:Kid = Kid

    // The following line of code WILL COMPILE because kid_2 is defined
    // as type Kid.type.  Kid.type references the object Kid, so
    // the Kid object (not the Kid class) gets assigned to kid_2.
    val kid_2:Kid.type = Kid
    println(s"kid_2.IS_ADULT = ${kid_2.IS_ADULT},  kid_2.IS_COLLEGE_GRADUATE = ${kid_2.IS_COLLEGE_GRADUATE}")
    // PRINTS:  kid_2.IS_ADULT = false,  kid_2.IS_COLLEGE_GRADUATE = true
  }
}

===============================================================================

The following code sample demonstrates how to use a "case class."

object Demo
{
  // This is a case class definition.  A case class
  // differs in some ways from a regular class.
  case class Person(firstName:String, lastName:String)

  /**************************************************
   * main()
   **************************************************/
  def main(args: Array[String]): Unit = {
    val joe:Person = Person("Joe", "Blow")
    println(s"1) joe.firstName = ${joe.firstName},  joe.lastName = ${joe.lastName}")
    // PRINTS: 1) joe.firstName = Joe,  joe.lastName = Blow

    joe match {
      case x => println(s"2) x.firstName = ${x.firstName},  x.lastName = ${x.lastName}")
      // PRINTS: 2) x.firstName = Joe,  x.lastName = Blow
      case _ => println("NO PATTERN MATCH")
    }

    joe match {
      case Person(fn, ln) => println(s"3) fn = $fn,  ln = $ln") // PRINTS: 3) fn = Joe,  ln = Blow
      case _ => println("NO PATTERN MATCH")
    }

    // The following line of code doesn't seem to make sense because it's NOT
    // very intuitive.  The following line of code is an assignment statement
    // which performs a pattern match on "val joe" by automatically invoking
    // the Person.unapply() method.  The Person.unapply() method extracts
    // joe.firstName and joe.lastName from val joe, then assigns them to the
    // vals "first" and "last" respectively.
    // NOTE: If the following line contained the keyword var instead of val,
    //       then first and last would become vars instead of vals.
    val Person(first, last) = joe
    println(s"4) first = $first,  last = $last") // PRINTS: 4) first = Joe,  last = Blow
  }
}

===============================================================================

The following code sample demonstrates how to use a regular class,
its companion object, the apply() and unapply() methods, and some
pattern matching.

object Demo
{
  // The line of code below defines a Person class.  (NOTE: Person is defined
  // here as a regular class, not a "case class.")  In a regular class, an
  // argument that's not preceded with the "val" or "var" keyword remains only
  // an argument, and doesn't become a member of the class.  (FYI, in a case class
  // all arguments become members of the case class automatically, even if they're
  // not preceded with the "val" or "var" keyword--by default, they're vals.)
  //
  // Because the firstName and lastName arguments passed to Person in the line
  // below are preceded by the val keyword, firstName and lastName become
  // members of the Person class.  So when a Person class is instantiated,
  // its members (firstName and lastName) get initialized.
  class Person(val firstName: String, val lastName: String)

  /**************************************************
   *  When you define a regular class (not a case class) that accepts
   *  constructor argument(s), you can also define a companion object,
   *  but it's not required.  In this example the object Person defined
   *  below becomes the companion object to the Person class defined above.
   **************************************************/
  object Person {
    // Scala automatically invokes this apply() method
    // when a Person class is instantiated.
    def apply(firstName:String, lastName:String): Person = {
      new Person(firstName, lastName) // Don't forget to include the "new" keyword!
    }
    // Scala automatically invokes this unapply() method when
    // pattern matching is performed on a Person class.
    def unapply(person:Person):Some[(String, String)] = {
      Some(person.firstName, person.lastName)
    }
  }

  /**************************************************
   * main()
   **************************************************/
  def main(args: Array[String]): Unit = {
    val joe:Person = Person("Joe", "Blow") // Person.apply() automatically gets called.
    println(s"1) joe.firstName = ${joe.firstName},  joe.lastName = ${joe.lastName}")
    // PRINTS: 1) joe.firstName = Joe,  joe.lastName = Blow

    // The following match statement DOESN'T require the Person.unapply() method!
    joe match {
      case x => println(s"2) x.firstName = ${x.firstName},  x.lastName = ${x.lastName}")
      // PRINTS: 2) x.firstName = Joe,  x.lastName = Blow
      case _ => println("NO PATTERN MATCH")
    }

    // The following line of code WON'T COMPILE without the Person.unapply() method.
    // The following match statement automatically invokes the Person.unapply() method.
    joe match {
      case Person(fn, ln) => println(s"3) fn = $fn,  ln = $ln") // PRINTS: 3) fn = Joe,  ln = Blow
      case _ => println("NO PATTERN MATCH")
    }

    // The following line of code WON'T COMPILE without the Person.unapply() method.
    // The following line of code doesn't seem to make sense because it's NOT
    // very intuitive.  The following line of code is an assignment statement
    // which performs a pattern match on "val joe" by automatically invoking
    // the Person.unapply() method.  The Person.unapply() method extracts
    // joe.firstName and joe.lastName from val joe, then assigns them to the
    // vals "first" and "last" respectively.
    // NOTE: If the following line contained the keyword var instead of val,
    //       then first and last would become vars instead of vals.
    val Person(first, last) = joe
    println(s"4) first = $first,  last = $last") // PRINTS: 4) first = Joe,  last = Blow
  }
}


===============================================================================

The following code sample contains no Scala classes, and therefore no companion objects.
All of the objects are pure singleton objects, not associated with any companion class.
This code demonstrates more complex examples of how to use pattern matching, including
using the unapplySeq() method for dealing with an unknown (variable) number of arguments.

import java.time.{LocalDate, LocalDateTime, LocalTime}
object Demo
{
  object DateTime {  // A pure singleton object, not associated with a companion class.
    def unapply(dt: LocalDateTime): Some[(LocalDate, LocalTime)] =
      Some((dt.toLocalDate, dt.toLocalTime))
  }

  object Date {  // A pure singleton object, not associated with a companion class.
    def unapply(date: LocalDate): Some[(Int, Int, Int)] =
      Some((date.getYear, date.getMonthValue, date.getDayOfMonth))
  }

  object Time {  // A pure singleton object, not associated with a companion class.
    def unapply(time: LocalTime): Some[(Int, Int, Int)] =
      Some((time.getHour, time.getMinute, time.getSecond))
  }

  // When an unknown (variable) number of arguments must be
  // extracted from a class, the unapply() method won't work.
  // When you need to extract an unknown (variable) number of
  // arguments from a class, you must write an unapplySeq()
  // method.  Just as Scala automatically invokes the unapply()
  // method in a companion object, Scala automatically invokes
  // the unapplySeq() method when it's called for.
  object DateTimeSeq {  // A pure singleton object, not associated with a companion class.
    def unapplySeq(dt: LocalDateTime):Some[Seq[Int]] = {
      Some(Seq(dt.getYear, dt.getMonthValue, dt.getDayOfMonth,
               dt.getHour, dt.getMinute,     dt.getSecond))
    }
  }

  // Notice the if() statement embedded within the match/case statement,
  // which allows more flexibility.  When the if() statement is true,
  // the match is successful.  When it's false, the match fails.
  object AM {  // A pure singleton object, not associated with a companion class.
    def unapply(time: LocalTime):Option[(Int, Int, Int)] = {
      time match {
        case Time(hour, minute, second) if (hour < 12) => Some((hour, minute, second))
        case _ => None  // No match above is successful.
      }
    }
  }

  // Notice the if() statement embedded within the match/case statement,
  // which allows more flexibility.  When the if() statement is true,
  // the match is successful.  When it's false, the match fails.
  object PM { // A pure singleton object, not associated with a companion class.
    def unapply(time: LocalTime):Option[(Int, Int, Int)] = {
      time match {
        case Time(12, minute, second) => Some(12, minute, second)
        case Time(hour, minute, second) if (hour > 12) => Some(hour-12, minute, second)
        case _ => None  // No match above is successful.
      }
    }
  }

  /**************************************************
   * main()
   *************************************************/
  def main(args: Array[String]): Unit = {
    // The pattern match performed on the following line of code will succeed
    // because it's written properly.  When it succeeds, year, month, and date
    // become Int vars, which are used in the following println statement.
    var Date(year, month, date) = LocalDate.now
    println(s"Date_1 = ${getMonthName(month)} $date, $year")

    // The pattern match performed on the following line of code will succeed
    // because it's written properly.  When it succeeds, hour, minute, and date
    // become Int vars, which are used in the following println statement.
    var Time(hour, minute, second) = LocalTime.now
    println(s"Time_1 = $hour:$minute:$second")

    Thread.sleep(2000) // Wait 2 seconds.

    // The following line of code obtains the same Date and Time information
    // as the above examples,  but in a single line of code.  Hovever the
    // following pattern match format is different than the one above.
    // NOTE: Even though year, hour, etc. are declared above as vars,
    //       they CAN'T be reused again in the following pattern match.
    //       This is because they've already been declared, and the
    //       following line of code would try to declare them a second
    //       time.  That's is why year2, hour2, etc. are used instead.
    var DateTime(Date(year2, month2, date2), Time(hour2, minute2, second2)) = LocalDateTime.now
    println(s"Date_2 = ${getMonthName(month2)} $date2, $year2")
    println(s"Time_2 = $hour2:$minute2:$second2")

    Thread.sleep(2000) // Wait 2 seconds.
    // To understand the following line of code, read comments in the getTimeString() method.
    println(s"Time_3 = ${getTimeString(LocalTime.now)}")

    // The following line of code obtains a subset of the information returned
    // by the call to LocalDateTime.now.  We're not interested in obtaining
    // the minutes or seconds from LocalDateTime.now.  So instead of supplying
    // var names of minutes and seconds, we specify "_*", which accepts a
    // variable number of arguments that we ignore.
    var DateTimeSeq(year3, month3, date3, hour3, _*) = LocalDateTime.now
    println(s"Date_4 = ${getMonthName(month3)} $date3, $year3")
    println(s"Time_4 = $hour3:??:??")
  }

  /************************************************
   * This getMonthName() method performs standard,
   * easy-to-understand pattern matching.
   ***********************************************/
  def getMonthName(monthNumber: Int):String = {
    monthNumber match {
      case 1 => "January";   case  2 => "February"; case  3 => "March";    case  4 => "April";
      case 5 => "May";       case  6 => "June";     case  7 => "July";     case  8 => "August";
      case 9 => "September"; case 10 => "October";  case 11 => "November"; case 12 => "December";
      case _ => "NO MATCH"
    }
  }

  /************************************************
   * This getTimeString() method gets passed an argument
   * of type Time.  It converts that Time value into a
   * String by performing the following 3 transfomations
   * then returns that String.
   *
   * 1) Zero-fills the minute and second values when they're < 10.
   * 2) Converts 24-hour time into 12-hour time with AM or PM appended.
   * 3) Appends to that String the exact value of Time passed to this method.
   *
   * This method performs a pattern match on localTime, which is passed
   * to this method.  The "match" keyword automatically invokes a call
   * to AM.unapply().  If localTime passed to this method matches the
   * AM(h, m, s) pattern, AM.unapply() returns a Time value, meaning the
   * pattern match succeeded.  If the pattern match succeeded, the syntax
   * "time @ AM(h, m, s)" binds localTime to "time" which, is a val.  The
   * formatted String after the rocket (=>) is then returned by this method.
   *
   * If AM.unapply() returns None, that pattern match failed.  So the
   * next line of code is executed, which works the same as the first
   * line of code.// The following 2 lines of code explained...
   * A pattern match is performed on localTime, which is passed to this method.
   * The "match" keyword automatically invokes a call to AM.unapply().  If
   * localTime passed to this method matches the AM(h, m, s) pattern,
   * AM.unapply() returns a Time value, meaning the pattern match succeeded.
   * If the pattern match succeeded, the syntax  "time @ AM(h, m, s)"  binds
   * localTime to "time" which, is a val.  The formatted String after the
   *  rocket (=>) is then returned by this method.
   *
   * If AM.unapply() returns None, that pattern match failed.  So the
   * next line of code is executed, which works the same as the first
   * line of code.
   ***********************************************/
   def getTimeString(localTime:LocalTime):String = {
     localTime match {
       case time @ AM(h, m, s) => f"$h%2d:$m%02d:$s%02d AM ($time precisely)"
       case time @ PM(h, m, s) => f"$h%2d:$m%02d:$s%02d PM ($time precisely)"
    }
  }
}

===============================================================================
Here's another example of how to perform pattern matching using the "match" keyword.

object Demo
{
  // NOTICE: The Email, SMS, VoiceRecording, and MorseCodeNotify case classes declarations
  //         below all extend the Notification class, which is an abstract class.
  //         Therefore, these 4 case classes can be treated as a Notification class.
  abstract class Notification
  case class Email(sender:String, title:String, body:String) extends Notification
  case class SMS(caller:String, message:String)              extends Notification
  case class VoiceRecording(contactName:String, link:String) extends Notification
  case class MorseCodeNotify()                               extends Notification

  def main(args: Array[String])
  {
    // We now demonstrate how to pattern match on the 4 case classes defined above.
    // Because all 4 of those case classes extend the Notification abstract class,
    // we can pass these classes as an argument to the showNotification() method
    // below, as type Notification.
    val emailNotify:Email               = Email("Sender Bender", "Titletown, USA", "Hi.  See you later.")
    val smsNotify:SMS                   = SMS("12345", "Are you there?")
    val voiceNotify:VoiceRecording      = VoiceRecording("Jack", "www.420.com")
    val morseCodeNotify:MorseCodeNotify = MorseCodeNotify()

    println

    println(showNotification(morseCodeNotify))
    // PRINTS: This is an unknown Notification message.

    println(showNotification(voiceNotify))
    // PRINTS: You received a Voice Recording from Jack.  To hear it, click on: www.420.com

    println(showNotification(emailNotify))
    // PRINTS: You have an email from Sender Bender with title: Titletown, USA

    println(showNotification(smsNotify))
    //PRINTS: You have an SMS from 12345! Message: Are you there?
  }

  def showNotification(notification:Notification):String =
  {
    notification match
    {
      case Email(email, title, _)     => s"You have an email from $email with title: $title"
      case SMS(number, message)       =>  s"You have an SMS from $number! Message: $message"
      case VoiceRecording(name, link) =>  s"You received a Voice Recording from $name!  To hear it, click on: $link"
      case _                          => "This is an unknown Notification message."
    }
  }
}

===============================================================================

AUXILIARY CLASS CONSTRUCTORS
----------------------------
A Scala Class can have multiple constructors.  The "default" constructor
is known as the "primary constructor".  The programmer can create additional
class constructors known as "auxiliary constructors" by defining them inside
the class, using the "this" keyword as the following example shows.
NOTE: The equal sign (=) in the constructor is optional--it's NOT required.

def this(arg1:datatype, arg2:datatype) = { Constructor code here. }

The following code contains TWO (2) auxiliary constructors defined
by the programmer.  The programmer never defines the primary
constructor because Scala defines it by default.

object Demo
{
  class Company
  {
    private var companyName:String = ""
    private var noOfEmployees:Int  = 0

    def show()
    {
      println("Company Name: " + companyName + " - Number of Employees: " + noOfEmployees)
    }

    // This Auxiliary Constructor contains one argument...
    def this(companyName: String)
    {
      this() // Calls the primary constructor, which is always available by default.
      this.companyName = companyName
    }

    // This Auxiliary Constructor contains two arguments...
    def this(companyName:String, noOfEmployees:Int)
    {
      this(companyName) // Calls the Auxiliary Constructor that has one argument.
      this.noOfEmployees = noOfEmployees
    }
  }

  def main(args: Array[String])
  {
    // Calls the Primary Constructor, which contains zero arguments...
    val company1 = new Company()
    company1.show() // PRINTS: Company Name:  - Number of Employees: 0

    // Calls the auxiliary constructor containing one argument...
    val company2 = new Company("Joe's Pipes, Inc.")
    company2.show() // PRINTS: Company Name: Joe's Pipes, Inc. - Number of Employees: 0

    // Calls the auxiliary constructor containing two arguments...
    val company3= new Company("Hard-Rock Cement Company", 42)
    company3.show() // PRINTS: Company Name: Hard-Rock Cement Company - Number of Employees: 42
  }
}


===============================================================================

GETTER AND SETTER METHODS
=========================

The syntax used for defining getter and setter methods for regular Scala
classes is rather strange.  The following code demonstrates how to use
getter and setter methods for standard Scala classes.  Read the comments
for details.  For more info on Scala classes see:
http://docs.scala-lang.org/tour/classes.html

object Demo
{
  class Point
  {
    private var _x = 0
    private var _y = 0
    private val bound = 100

    def x = { _x } // This is a getter method.
    // The method below is a setter method.  There must be no whitespace before or after the _ character for x_=
    def x_= (newValue: Int): Unit =
    {
      if (newValue < bound) _x = newValue
      else printWarning
    }

    def y = { _y } // This is a getter method.
    // The method below is a setter method.  There must be no whitespace before or after the _ character for y_=
    def y_= (newValue: Int): Unit =
    {
      if (newValue < bound) _y = newValue
      else printWarning
    }

    private def printWarning = println("WARNING: Out of bounds!")
  }

  def main(args: Array[String]) =
  {
    val point1 = new Point

    // The following 2 lines call the above setter methods x_= and y_=
    point1.x = 99  // This line calls the x_= setter method.
    point1.y = 101 // This line calls the y_= setter method.

    // The following 2 lines call the above getter methods x and y
    println("point1.x = " + point1.x) // This line calls the x getter method.
    println("point1.y = " + point1.y) // This line calls the y getter method.
  }
}

===============================================================================

ADVANCED VISIBILITY MODIFIERS
=============================
Scala has keywords 'private' and 'protected' that visibility modifiers.  Those
keywords  can be followed by square brackets [], and the name of an enclosing
scope of one of the following...

1) package
2) class
3) trait
4) object

If you want to a make a method available to all members of the current package
(aka, “package scope”), mark the method as being private to the current package,
with the private[packageName] syntax as in this example:

There are three (3) main levels of visibility in Scala, they are:

1) public (default) - There does NOT exist a public keyword in Scala.  If you want
                      something public, it's public BY DEFAULT, which means you
                      wouldn't use the private or protected keyword.  If the
                      visibility level is public, a class's val/var member or
                      method is accessible by code inside, or outside, the class.
2) private - A "private" declaration means a class's val/var member or method
             can be accessed only inside the class.  If you prefix a declaration
             inside a class with the private keyword, that member will be visible
             to that class only.  This means a private method is NOT made avaiable
             to subclasses.
3) protected - A protected declaration is much like private, except protected class
               members are also accessible in subtypes (children) of the class.
               This means a protected method IS made available to subclasses.

===============================================================================

package com.acme.coolapp.model
{
    class Foo
    {
        private[model] def doX {}
        private def doY {}
    }
    class Bar
    {
        val f = new Foo
        f.doX  // compiles
        f.doY  // won't compile
    }
}

These advanced modifiers will make class members publicly visible for everything
at that scope and closer to the declaration.  The benefit of this is that special
access can be attained for closely-related code without making a member public
to the entire world.  For more details regarding scope, go to this URL:

https://alvinalexander.com/scala/how-to-control-scala-method-scope-object-private-package

The following code shows how private[this] differs from the standard private declaration.
Read the comments at the top of the Account class definition...

object Demo
{
  def main(args: Array[String]):Unit =
  {
    val myAccount = new Account

    myAccount.deposit(111)
    println("myAccount.bal = " + myAccount.balance) // PRINTS: myAccount.bal = 111

    myAccount.modifyBalDirectly(222)
    println("myAccount.bal = " + myAccount.balance) // PRINTS: myAccount.bal = 222

    myAccount.modifyBalViaArgument(myAccount, 333)  // Read the Account class comments below.
    println("myAccount.bal = " + myAccount.balance) // PRINTS: myAccount.bal = 333
  }

  /**
    * NOTE: If you replace this line of code:  private var bal = 0
    *       with this line of code:            private[this] var bal = 0
    *       the modifyBalViaArgument() function WILL NOT COMPILE cuz it's
    *       attempting to modify bal via an externally-declared class,
    *       which isn't allowed when it's a private[this] declaration.
    */
  class Account
  {
    private var bal = 0
    // private[this] var bal = 0

    def deposit(amount:Int):Boolean =
    {
      if (amount > 0) { bal += amount; true } else false
    }
    def withdraw(amount:Int):Boolean =
    {
      if (amount > 0 && amount < balance) { bal -= amount; true } else false
    }
    def modifyBalDirectly(value:Int):Unit = { bal = value }
    def modifyBalViaArgument(accountA:Account, value:Int):Unit = { accountA.bal = value }
    def balance = bal
  }
}

====================================================================================
