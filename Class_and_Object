Scala provides three constructs for creating user-defined types:

1) class  (Scala has two types of class:  A "case class" and a regular "class")
2) object (Scala has two kinds of object: A "case object" and a regular "object")
3) trait

Use a Scala trait to represent a "behavior", such as communicate, learn,
transport, work, etc.  (Traits are NOT covered in this section.  See the
section titled "Trait" instead.)

Use a Scala class, or a Scala object, to represent a thing/object.

When there can exist MULTIPLE things/objects (for example, a person),
use a Scala class.  A Person class would be defined to store data
about the person; i.e., Name, Address, Social Security Number, etc.
After you write the definition of a class (whether it's a "case class"
or a regular "class"), you then need to instantiate (create) a new
Person class for each person.

When there can exist ONLY ONE of something (for example, planet Earth),
use a Scala object to represent it.  A Scala object always represents
a singleton (a single entity).  A Scala object CAN'T contain args/params,
and CAN'T be instantiated.  So once you write an object's definition,
it's available for use without doing anything else.  The vals/vars
contained within a Scala object get initialized only once--the first
time the object is referenced.  An object can extend a class, but a
class CAN'T extend an object.

DIFFERENCES BETWEEN A SCALA "case class" AND A SCALA "class"
============================================================
A Scala "case class" is different from a regular Scala class in the following 7 ways.

1) A regular Scala class generally requires multiple lines of code
   to define it.  But a case class definition is usually very short,
   often times requiring only one line of code, like this:

   case class Person(name:String, id:Int) // A case class definition
   val jim = Person("Jim", 98765)         // The case class being instantiated.

2) A case class MUST contain one or more args/params in its definition,
   while a plainn Scala class can contain zero, or multiple, args/params.

3) All args/params passed to a Scala case class become public class members by
   default, regardless if they're preceded with keywords val/var, or nothing.

   The args/params passed to a plain Scala class become public class members
   ONLY when they're preceded with the val/var keyword.  If those args/params
   aren't preceded with val/var, they don't become class members--they
   exist only as args/params when the class is instantiated.
   
   The following code sample demonstrates this behavior. Read in-line comments
   for details.
   ===========================================================================
   object Demo
   {
     // Both args/params passed to PersonClass_1 become public
     // members by default, because they're preceded with
     // keywords val or var.
     class PersonClass_1(val name: String, var age: Int) {
       def printArgs(): Unit = {
         println(s"PersonClass_1.name = $name,  PersonClass_1.age = $age")
       }
     }

     // Both args/params passed to PersonClass_2 never become class
     // members, because they're NOT preceded with keywords val or var.
     class PersonClass_2(name:String, age:Int) {
       def printArgs():Unit = {
         println(s"PersonClass_2.name = $name,  PersonClass_2.age = $age")
       }
     }

     // All args/params passed to PersonCaseClass become public
     // members by default, regardless if they're preceded with
     // val, var, or no keywords.
     case class PersonCaseClass(name:String, val age:Int) {
       def printArgs(): Unit = {
         println(s"PersonCaseClass.name = $name,  PersonCaseClass.age = $age")
       }
     }

     def main(args: Array[String]):Unit = {
       // **********************************
       // Test PersonClass_1 behavior:
       val person_1 = new PersonClass_1("Joe", 15)
       person_1.printArgs() // PRINTS: PersonClass_1.name = Joe,  PersonClass_1.age = 15

       // The following 2 lines compile because person_1.name and person_1.age
       // are public class members.
       var name = person_1.name
       var age  = person_1.age

       // **********************************
       // Test PersonClass_2 behavior:
       val person_2 = new PersonClass_2("Jack", 23)
       person_2.printArgs() // PRINTS: PersonClass_2.name = Jack,  PersonClass_2.age = 23

       // If you uncomment the following 2 lines, they won't compile because
       // person_2.name and person_2.age are private class members.
       // name = person_2.name  // WON'T COMPILE!
       // age  = person_2.age   // WON'T COMPILE!

       // **********************************
       // Test PersonCaseClass behavior:
       val person_3 = new PersonCaseClass("Sally", 47)
       person_3.printArgs() // PRINTS: PersonCaseClass.name = Sally,  PersonCaseClass.age = 47

       // The following 2 lines compile because ALL args/params passed
       // to a case class are ALWAYS public class members.
       name = person_3.name
       age  = person_3.age
     }
   }
   ===========================================================================

4) When a case class is instantiated, the following 6 methods become
   available by default, so you never need to write them yourself.

   apply()   - This method gets called automatically whenever a Scala class
               (or case class) is instantiated.
   unapply() - This method gets called automatically whenever pattern matching
               is performed on a Scala class (or case class).
   copy()    - Creates, and returns, a new "case class" instance that's a copy
               of the existing case class.  If you pass this copy() method any
               args/params, those args/params specify the case class member
               values that will be changed in the copied-to (returned) instance.
               Only the newly-created case class will contain the changes you
               specify via the args/params.  Calling copy() on a case class DOESN'T
               make any changes to the copied-from case class.
   equals()  - Determines if two Scala objects are equal.  Read the hashCode() description below.
   hashCode() - Returns an Int value.  If calling hashCode() on two Scala objects
                return the same Int value, they are equal.  You can use the equals()
                method or the '==' operator in place of calling hashCode() to
                determine equivalency.
   toString() - Renders the case class’s name and fields to a String.

5) A case class is Serializable.

6) A case class CAN be abstract, like this:   abstract case class Card(id:Int)

7) A regular class can extend a trait.  But a case class CAN'T extend a trait,
   or another case class.  However, a case class CAN extend a regular class OR
   an abstract class.  The following example will work with or without the
   "abstract" keyword:

   abstract class Card(id:Int)
   case class DebitCard(id:Int, name:String, number:Int) extends Card(id)

=============================================================================
This sample program demonstrates the use of:
1) A Scala case class
2) A plain Scala class
3) A Scala object

import java.time.LocalDate
import java.time.format.DateTimeFormatter

object Demo
{
  // args/params passed to a "case class" are always PUBLIC members,
  // which means they can be accessed from outside the "case class".
  // Members declared inside a "case class" are also PUBLIC.
  case class PersonCaseClass(name: String, dob: LocalDate, ssn: String) {
    val publicName = name // This val is a PUBLIC member.
  }

  // args/params passed to a regular "class" are always PRIVATE members,
  // which means they can be accessed only from inside the class.
  // Members declared inside a regular "class" are PUBLIC.
  class PersonClass(name: String, dob: LocalDate, ssn: String) {
    val publicName = name // This val is a PUBLIC member.

    // This method is PUBLIC by default.  If you declare it private,
    // it can't be called outside the PersonClass.
    def printPersonClassMembers() = {
      println(s"3) name = $name,  dob = $dob,  ssn = $ssn")
    }
  }

  object Earth {
    val DIAMETER_MILES:Float          = 7926.0F;
    val CIRCUMFERENCE_MILES:Float     = 24901.0F;
    var AVERAGE_TEMP_FAHRENHEIT:Float = 57.0F
  }

  /********************************************************
   *  main()
   *******************************************************/
  def main(args: Array[String]):Unit = {
    // ******************************************************
    // Demonstrate that args/params passed to a "case class", ARE PUBLIC,
    // as they CAN be referenced here in main(), outside of PersonCaseClass.
    // Demonstrate that internally-declared "case class" members are also PUBLIC,
    // as they CAN be referenced here in main(), outside of PersonCaseClass.
    val larry = PersonCaseClass("Larry Hairy", convertStringToDate("1963-11-22"), "987-65-4321")
    println(s"1) larry.name = ${larry.name},  larry.dob = ${larry.dob.toString},  larry.ssn = ${larry.ssn},  larry.publicName = ${larry.publicName}")
    // PRINTS: 1) larry.name = Larry Hairy,  larry.dob = 1963-11-22,  larry.ssn = 987-65-4321,  larry.publicName = Larry Hairy

    // ******************************************************
    // Demonstrate that args/params passed to a "case", are PRIVATE,
    // as they CAN'T be referenced here in main(), outside of PersonClass.
    // Demonstrate that internally-declared "class" members ARE PUBLIC,
    // as they CAN be referenced here in main(), outside of PersonClass.
    val jack = new PersonClass("Jack Hack", convertStringToDate("1941-12-07"), "123-45-6789")
    // If you uncomment the following 3 lines of commented-out code, they WON'T COMPILE!
    // Because these 3 members of PersonClass are PRIVATE.
    // println(s"jack.name = ${jack.name}") // WON'T COMPILE!
    // println(s"jack.dob = ${jack.dob}")   // WON'T COMPILE!
    // println(s"jack.ssn = ${jack.ssn}")   // WON'T COMPILE!
    println(s"2) jack.publicName = ${jack.publicName}") // PRINTS: 2) jack.publicName = Jack Hack

    // ******************************************************
    // Demonstrate that you can view/obtain PersonClass members
    // from main() via a PersonClass PUBLIC method...
    jack.printPersonClassMembers()
    // PRINTS: 3) name = Jack Hack,  dob = 1941-12-07,  ssn = 123-45-6789

    // ******************************************************
    // Demonstrate that a Scala object is always used/referenced directly,
    // without instantiating the object.
    println(s"4) Earth.AVERAGE_TEMP_FAHRENHEIT = ${Earth.AVERAGE_TEMP_FAHRENHEIT}")
    // PRINTS: 4) Earth.AVERAGE_TEMP_FAHRENHEIT = 57.0
    // Demonstrate you can alter an object's var member...
    Earth.AVERAGE_TEMP_FAHRENHEIT = 123.0F
    println(s"5) Earth.AVERAGE_TEMP_FAHRENHEIT = ${Earth.AVERAGE_TEMP_FAHRENHEIT}")
    // PRINTS: 5) Earth.AVERAGE_TEMP_FAHRENHEIT = 123.0
    println(s"6) Earth.DIAMETER_MILES = ${Earth.DIAMETER_MILES}")
    // PRINTS: 6) Earth.DIAMETER_MILES = 7926.0
    println(s"7) Earth.CIRCUMFERENCE_MILES = ${Earth.CIRCUMFERENCE_MILES}")
    // PRINTS: 7) Earth.CIRCUMFERENCE_MILES = 24901.0
  }

  /********************************************************
   convertStringToDate() - Convert a String to a Date.
  ********************************************************/
  def convertStringToDate(strDate:String) = {
    val formatter:DateTimeFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd")
    val date:LocalDate = LocalDate.parse(strDate, formatter)
    date
  }
}
=============================================================================

SCALA COMPANION OBJECTS
=======================
Before a Scala "companion object is explained, review these facts about
a Scala object...

When there can exist ONLY ONE of something (for example, planet Earth),
use a Scala object to represent it.  A Scala object always represents
a singleton (a single entity).  A Scala object CAN'T contain args/params,
and CAN'T be instantiated.  So once you write an object's definition,
it's available for use without doing anything else.  The vals/vars
contained within a Scala object get initialized only once--the first
time the object is referenced.  An object can extend a class, but a
class CAN'T extend an object.

Whenever pattern matching is performed on a class, the class's unapply()
method is automatically invoked.

If you want to perform pattern matching on a "case class", you would NOT
write your own unapply() method, because a "case class" automatically
supplies the unapply() method.

However, a plain Scala class doesn't supply the unapply() method.  If
you want to perform pattern matching on a plain Scala class, you must
write your own unapply() method, and it MUST be contained inside a
companion object.  So if you want to perform pattern matching on a
plain Scala class, you must create a companion object to that class,
and the companion object must contain an unapply() method which you
also must define

There are three reasons for a plain Scala class to have a companion object:

1) To perform pattern matching on a plain Scala class.  To accomplish that
   requires you to define an unapply() method, which must be contained
   within the class's companion object.

2) A companion object can be used to contain vals, vars, or methods that
   are singletons.  Singletons are values or methods in the companion
   object that apply to all instances of the corresponding companion class.
   The vals/vars contained within a Scala object get initialized only
   once--the first time the object is referenced.

3) NOTE: A class's apply() method automatically gets invoked whenever
         a plain Scala class, or a "case class", in instantiated.
   You can define your own apply() method for a plain Scala class
   (but not for a "case class") in place of the default apply() method.
   However, there's usually no reason to write your own apply() method
   for a plain class, so it's rarely done.

A companion object always meets these 4 criteria:

1) The companion object MUST have the identical name as the class.
2) The companion object MUST be contained in the same file as the class.
3) All vars/vals within the companion object are singleton values, and
   can be accessed by all instances of the companion class.
4) All methods within the companion object can be invoked on all
   instances of the companion class.

Two of the most common methods contained in a companion object are:

1) apply() - This method gets invoked whenever a class is instantiated, and it
             literally performs the class's instantiation.  Scala provides an
             apply() method for all classes by default, so you don't have to write
             your own.  Rarely is there a good reason to write your own apply()
             method, but that option is available if you need it.

2) unapply() OR unapplySeq()...

   unapply() - The unapply() method gets invoked automatically whenever pattern
               matching is performed on a class.  Scala doesn't provide a default
               unapply() method for regular classes (only for case classes).
               If you want to perform pattern matching on a regular class, you
               must write your own unapply() method inside the companion object.
   unapplySeq() - An unapplySeq() method takes the place of unapply() when you want
                  to deconstruct an unknown (variable number) of arguments for pattern
                  matching.  That variable number of arguments gets passed to the
                  companion class when the companion class gets instantiated.


EXPLANATION OF A SCALA "case object"
====================================
Just as you can create a "case class" in Scala, you can also create
a "case object."  A "case object" differs from a regular object in
these ways.
1) A case object is serializable.
2) A case object has a default hashCode() implementation.
3) A case object has an improved toString implementation.

The use of case objects is NOT common, but they are used for enumerations.
Like this, for example:

sealed trait Topping
case object Cheese    extends Topping
case object Pepperoni extends Topping
case object Sausage   extends Topping
case object Mushrooms extends Topping
case object Onions    extends Topping

Scala also has the following type of classes.
This page doesn't discuss these class types.

* Anonymous class
* Generic class
* Implicit class
* Inner class

Below are some code samples demonstrating:

* When an object and a class have identical names, how can the
  code determine if it's referencing the object or the class?
* Scala classes
* Scala objects
* Scala companion objects
* apply() method
* unapply() method
* pattern matching

=============================================================================
When a piece of code contains both an object and a class with identical
names, the object is usually a "companion object" to the class.  In the
following code example, the object Kid is NOT a companion object to
the class Kid.

Read the in-line comments below to understand that when an object and
a class have identical names, they have DIFFERENT types.

object Demo
{
  class Kid(name:String, age:Int) {
    def greeting():String = s"My name is $name.  I am $age years old."
  }

  object Kid {
    val IS_ADULT:Boolean            = false
    val IS_COLLEGE_GRADUATE:Boolean = true
  }

  def main(args: Array[String]):Unit = {
    val kidClass:Kid = new Kid("Jane Train", 13)
    println(s"${kidClass.greeting}") // PRINTS: My name is Jane Train.  I am 13 years old.

    // IMPORTANT: The class Kid has the type:  Kid
    //            The object Kid has the type: Kid.type
    //
    // If you uncomment the following commented-out line, it WON'T COMPILE.
    // It won't compile because KidObject is declared to have the type of Kid,
    // which references the class Kid.  But Kid on the right side of the
    // '=' sign references the object Kid, which causes a type mismatch.
    // val kidObject:Kid = Kid  // WON'T COMPILE!

    // The following line successfully compiles because kidObject is declared
    // to have the type of Kid.type, which is the type of the object Kid.  The
    // Kid on the right-side of the '=' sign is an object Kid (not a class Kid).
    val kidObject:Kid.type = Kid  // Assigns the object Kid (defined above) to kidObject.

    // Because the val kid below isn't declared to have a type, it references whatever
    // gets assigned to it.  So in this example, the val kid references the object Kid,
    // because Kid is an object, not a class.
    val kid = Kid

    println(s"kid.IS_ADULT = ${kid.IS_ADULT},  kid.IS_COLLEGE_GRADUATE = ${kid.IS_COLLEGE_GRADUATE}")
    // PRINTS:  kid.IS_ADULT = false,  kid.IS_COLLEGE_GRADUATE = true
  }
}

===============================================================================

The following code sample demonstrates how to use a "case class."

object Demo
{
  // This is a case class definition.  A case class
  // differs in some ways from a regular class.
  case class Person(firstName:String, lastName:String)

  /**************************************************
   * main()
   **************************************************/
  def main(args: Array[String]): Unit = {
    val joe:Person = Person("Joe", "Blow")
    println(s"1) joe.firstName = ${joe.firstName},  joe.lastName = ${joe.lastName}")
    // PRINTS: 1) joe.firstName = Joe,  joe.lastName = Blow

    joe match {
      case x => println(s"2) x.firstName = ${x.firstName},  x.lastName = ${x.lastName}")
      // PRINTS: 2) x.firstName = Joe,  x.lastName = Blow
      case _ => println("NO PATTERN MATCH")
    }

    joe match {
      case Person(fn, ln) => println(s"3) fn = $fn,  ln = $ln") // PRINTS: 3) fn = Joe,  ln = Blow
      case _ => println("NO PATTERN MATCH")
    }

    // The following line of code doesn't seem to make sense because it's NOT
    // very intuitive.  The following line of code is an assignment statement
    // which performs a pattern match on "val joe" by automatically invoking
    // the Person.unapply() method.  The Person.unapply() method extracts
    // joe.firstName and joe.lastName from val joe, then assigns them to the
    // vals "first" and "last" respectively.
    // NOTE: If the following line contained the keyword var instead of val,
    //       then first and last would become vars instead of vals.
    val Person(first, last) = joe
    println(s"4) first = $first,  last = $last") // PRINTS: 4) first = Joe,  last = Blow
  }
}

===============================================================================

The following code sample demonstrates how to use a regular class,
its companion object, the apply() and unapply() methods, and some
pattern matching.

object Demo
{
  // The line of code below defines a Person class.  (NOTE: Person is defined
  // here as a regular class, not a "case class.")  In a regular class, an
  // argument that's not preceded with the "val" or "var" keyword remains only
  // an argument, and doesn't become a member of the class.  (FYI, in a case class
  // all arguments become members of the case class automatically, even if they're
  // not preceded with the "val" or "var" keyword--by default, they're vals.)
  //
  // Because the firstName and lastName arguments passed to Person in the line
  // below are preceded by the val keyword, firstName and lastName become
  // members of the Person class.  So when a Person class is instantiated,
  // its members (firstName and lastName) get initialized.
  class Person(val firstName: String, val lastName: String)

  /**************************************************
   *  When you define a regular class (not a case class) that accepts
   *  constructor argument(s), you can also define a companion object,
   *  but it's not required.  In this example the object Person defined
   *  below becomes the companion object to the Person class defined above.
   **************************************************/
  object Person {
    // Scala automatically invokes this apply() method
    // when a Person class is instantiated.
    def apply(firstName:String, lastName:String): Person = {
      new Person(firstName, lastName) // Don't forget to include the "new" keyword!
    }
    // Scala automatically invokes this unapply() method when
    // pattern matching is performed on a Person class.
    def unapply(person:Person):Some[(String, String)] = {
      Some(person.firstName, person.lastName)
    }
  }

  /**************************************************
   * main()
   **************************************************/
  def main(args: Array[String]): Unit = {
    val joe:Person = Person("Joe", "Blow") // Person.apply() automatically gets called.
    println(s"1) joe.firstName = ${joe.firstName},  joe.lastName = ${joe.lastName}")
    // PRINTS: 1) joe.firstName = Joe,  joe.lastName = Blow

    // The following match statement DOESN'T require the Person.unapply() method!
    joe match {
      case x => println(s"2) x.firstName = ${x.firstName},  x.lastName = ${x.lastName}")
      // PRINTS: 2) x.firstName = Joe,  x.lastName = Blow
      case _ => println("NO PATTERN MATCH")
    }

    // The following line of code WON'T COMPILE without the Person.unapply() method.
    // The following match statement automatically invokes the Person.unapply() method.
    joe match {
      case Person(fn, ln) => println(s"3) fn = $fn,  ln = $ln") // PRINTS: 3) fn = Joe,  ln = Blow
      case _ => println("NO PATTERN MATCH")
    }

    // The following line of code WON'T COMPILE without the Person.unapply() method.
    // The following line of code doesn't seem to make sense because it's NOT
    // very intuitive.  The following line of code is an assignment statement
    // which performs a pattern match on "val joe" by automatically invoking
    // the Person.unapply() method.  The Person.unapply() method extracts
    // joe.firstName and joe.lastName from val joe, then assigns them to the
    // vals "first" and "last" respectively.
    // NOTE: If the following line contained the keyword var instead of val,
    //       then first and last would become vars instead of vals.
    val Person(first, last) = joe
    println(s"4) first = $first,  last = $last") // PRINTS: 4) first = Joe,  last = Blow
  }
}


===============================================================================

The following code sample contains no Scala classes, and therefore no companion objects.
All of the objects are pure singleton objects, not associated with any companion class.
This code demonstrates more complex examples of how to use pattern matching, including
using the unapplySeq() method for dealing with an unknown (variable) number of arguments.

import java.time.{LocalDate, LocalDateTime, LocalTime}
object Demo
{
  object DateTime {  // A pure singleton object, not associated with a companion class.
    def unapply(dt: LocalDateTime): Some[(LocalDate, LocalTime)] =
      Some((dt.toLocalDate, dt.toLocalTime))
  }

  object Date {  // A pure singleton object, not associated with a companion class.
    def unapply(date: LocalDate): Some[(Int, Int, Int)] =
      Some((date.getYear, date.getMonthValue, date.getDayOfMonth))
  }

  object Time {  // A pure singleton object, not associated with a companion class.
    def unapply(time: LocalTime): Some[(Int, Int, Int)] =
      Some((time.getHour, time.getMinute, time.getSecond))
  }

  // When an unknown (variable) number of arguments must be
  // extracted from a class, the unapply() method won't work.
  // When you need to extract an unknown (variable) number of
  // arguments from a class, you must write an unapplySeq()
  // method.  Just as Scala automatically invokes the unapply()
  // method in a companion object, Scala automatically invokes
  // the unapplySeq() method when it's called for.
  object DateTimeSeq {  // A pure singleton object, not associated with a companion class.
    def unapplySeq(dt: LocalDateTime):Some[Seq[Int]] = {
      Some(Seq(dt.getYear, dt.getMonthValue, dt.getDayOfMonth,
               dt.getHour, dt.getMinute,     dt.getSecond))
    }
  }

  // Notice the if() statement embedded within the match/case statement,
  // which allows more flexibility.  When the if() statement is true,
  // the match is successful.  When it's false, the match fails.
  object AM {  // A pure singleton object, not associated with a companion class.
    def unapply(time: LocalTime):Option[(Int, Int, Int)] = {
      time match {
        case Time(hour, minute, second) if (hour < 12) => Some((hour, minute, second))
        case _ => None  // No match above is successful.
      }
    }
  }

  // Notice the if() statement embedded within the match/case statement,
  // which allows more flexibility.  When the if() statement is true,
  // the match is successful.  When it's false, the match fails.
  object PM { // A pure singleton object, not associated with a companion class.
    def unapply(time: LocalTime):Option[(Int, Int, Int)] = {
      time match {
        case Time(12, minute, second) => Some(12, minute, second)
        case Time(hour, minute, second) if (hour > 12) => Some(hour-12, minute, second)
        case _ => None  // No match above is successful.
      }
    }
  }

  /**************************************************
   * main()
   *************************************************/
  def main(args: Array[String]): Unit = {
    // The pattern match performed on the following line of code will succeed
    // because it's written properly.  When it succeeds, year, month, and date
    // become Int vars, which are used in the following println statement.
    var Date(year, month, date) = LocalDate.now
    println(s"Date_1 = ${getMonthName(month)} $date, $year")

    // The pattern match performed on the following line of code will succeed
    // because it's written properly.  When it succeeds, hour, minute, and date
    // become Int vars, which are used in the following println statement.
    var Time(hour, minute, second) = LocalTime.now
    println(s"Time_1 = $hour:$minute:$second")

    Thread.sleep(2000) // Wait 2 seconds.

    // The following line of code obtains the same Date and Time information
    // as the above examples,  but in a single line of code.  Hovever the
    // following pattern match format is different than the one above.
    // NOTE: Even though year, hour, etc. are declared above as vars,
    //       they CAN'T be reused again in the following pattern match.
    //       This is because they've already been declared, and the
    //       following line of code would try to declare them a second
    //       time.  That's is why year2, hour2, etc. are used instead.
    var DateTime(Date(year2, month2, date2), Time(hour2, minute2, second2)) = LocalDateTime.now
    println(s"Date_2 = ${getMonthName(month2)} $date2, $year2")
    println(s"Time_2 = $hour2:$minute2:$second2")

    Thread.sleep(2000) // Wait 2 seconds.
    // To understand the following line of code, read comments in the getTimeString() method.
    println(s"Time_3 = ${getTimeString(LocalTime.now)}")

    // The following line of code obtains a subset of the information returned
    // by the call to LocalDateTime.now.  We're not interested in obtaining
    // the minutes or seconds from LocalDateTime.now.  So instead of supplying
    // var names of minutes and seconds, we specify "_*", which accepts a
    // variable number of arguments that we ignore.
    var DateTimeSeq(year3, month3, date3, hour3, _*) = LocalDateTime.now
    println(s"Date_4 = ${getMonthName(month3)} $date3, $year3")
    println(s"Time_4 = $hour3:??:??")
  }

  /************************************************
   * This getMonthName() method performs standard,
   * easy-to-understand pattern matching.
   ***********************************************/
  def getMonthName(monthNumber: Int):String = {
    monthNumber match {
      case 1 => "January";   case  2 => "February"; case  3 => "March";    case  4 => "April";
      case 5 => "May";       case  6 => "June";     case  7 => "July";     case  8 => "August";
      case 9 => "September"; case 10 => "October";  case 11 => "November"; case 12 => "December";
      case _ => "NO MATCH"
    }
  }

  /************************************************
   * This getTimeString() method gets passed an argument
   * of type Time.  It converts that Time value into a
   * String by performing the following 3 transfomations
   * then returns that String.
   *
   * 1) Zero-fills the minute and second values when they're < 10.
   * 2) Converts 24-hour time into 12-hour time with AM or PM appended.
   * 3) Appends to that String the exact value of Time passed to this method.
   *
   * This method performs a pattern match on localTime, which is passed
   * to this method.  The "match" keyword automatically invokes a call
   * to AM.unapply().  If localTime passed to this method matches the
   * AM(h, m, s) pattern, AM.unapply() returns a Time value, meaning the
   * pattern match succeeded.  If the pattern match succeeded, the syntax
   * "time @ AM(h, m, s)" binds localTime to "time" which, is a val.  The
   * formatted String after the rocket (=>) is then returned by this method.
   *
   * If AM.unapply() returns None, that pattern match failed.  So the
   * next line of code is executed, which works the same as the first
   * line of code.// The following 2 lines of code explained...
   * A pattern match is performed on localTime, which is passed to this method.
   * The "match" keyword automatically invokes a call to AM.unapply().  If
   * localTime passed to this method matches the AM(h, m, s) pattern,
   * AM.unapply() returns a Time value, meaning the pattern match succeeded.
   * If the pattern match succeeded, the syntax  "time @ AM(h, m, s)"  binds
   * localTime to "time" which, is a val.  The formatted String after the
   *  rocket (=>) is then returned by this method.
   *
   * If AM.unapply() returns None, that pattern match failed.  So the
   * next line of code is executed, which works the same as the first
   * line of code.
   ***********************************************/
   def getTimeString(localTime:LocalTime):String = {
     localTime match {
       case time @ AM(h, m, s) => f"$h%2d:$m%02d:$s%02d AM ($time precisely)"
       case time @ PM(h, m, s) => f"$h%2d:$m%02d:$s%02d PM ($time precisely)"
    }
  }
}

===============================================================================
Here's another example of how to perform pattern matching using the "match" keyword.

object Demo
{
  // NOTICE: The Email, SMS, VoiceRecording, and MorseCodeNotify case classes declarations
  //         below all extend the Notification class, which is an abstract class.
  //         Therefore, these 4 case classes can be treated as a Notification class.
  abstract class Notification
  case class Email(sender:String, title:String, body:String) extends Notification
  case class SMS(caller:String, message:String)              extends Notification
  case class VoiceRecording(contactName:String, link:String) extends Notification
  case class MorseCodeNotify()                               extends Notification

  def main(args: Array[String])
  {
    // We now demonstrate how to pattern match on the 4 case classes defined above.
    // Because all 4 of those case classes extend the Notification abstract class,
    // we can pass these classes as an argument to the showNotification() method
    // below, as type Notification.
    val emailNotify:Email               = Email("Sender Bender", "Titletown, USA", "Hi.  See you later.")
    val smsNotify:SMS                   = SMS("12345", "Are you there?")
    val voiceNotify:VoiceRecording      = VoiceRecording("Jack", "www.420.com")
    val morseCodeNotify:MorseCodeNotify = MorseCodeNotify()

    println

    println(showNotification(morseCodeNotify))
    // PRINTS: This is an unknown Notification message.

    println(showNotification(voiceNotify))
    // PRINTS: You received a Voice Recording from Jack.  To hear it, click on: www.420.com

    println(showNotification(emailNotify))
    // PRINTS: You have an email from Sender Bender with title: Titletown, USA

    println(showNotification(smsNotify))
    //PRINTS: You have an SMS from 12345! Message: Are you there?
  }

  def showNotification(notification:Notification):String =
  {
    notification match
    {
      case Email(email, title, _)     => s"You have an email from $email with title: $title"
      case SMS(number, message)       =>  s"You have an SMS from $number! Message: $message"
      case VoiceRecording(name, link) =>  s"You received a Voice Recording from $name!  To hear it, click on: $link"
      case _                          => "This is an unknown Notification message."
    }
  }
}

===============================================================================

AUXILIARY CLASS CONSTRUCTORS
----------------------------
A Scala Class can have multiple constructors.  The "default" constructor
is known as the "primary constructor".  The programmer can create additional
class constructors known as "auxiliary constructors" by defining them inside
the class, using the "this" keyword as the following example shows.
NOTE: The equal sign (=) in the constructor is optional--it's NOT required.

def this(arg1:datatype, arg2:datatype) = { Constructor code here. }

The following code contains TWO (2) auxiliary constructors defined
by the programmer.  The programmer never defines the primary
constructor because Scala defines it by default.

object Demo
{
  class Company
  {
    private var companyName:String = ""
    private var noOfEmployees:Int  = 0

    def show()
    {
      println("Company Name: " + companyName + " - Number of Employees: " + noOfEmployees)
    }

    // This Auxiliary Constructor contains one argument...
    def this(companyName: String)
    {
      this() // Calls the primary constructor, which is always available by default.
      this.companyName = companyName
    }

    // This Auxiliary Constructor contains two arguments...
    def this(companyName:String, noOfEmployees:Int)
    {
      this(companyName) // Calls the Auxiliary Constructor that has one argument.
      this.noOfEmployees = noOfEmployees
    }
  }

  def main(args: Array[String])
  {
    // Calls the Primary Constructor, which contains zero arguments...
    val company1 = new Company()
    company1.show() // PRINTS: Company Name:  - Number of Employees: 0

    // Calls the auxiliary constructor containing one argument...
    val company2 = new Company("Joe's Pipes, Inc.")
    company2.show() // PRINTS: Company Name: Joe's Pipes, Inc. - Number of Employees: 0

    // Calls the auxiliary constructor containing two arguments...
    val company3= new Company("Hard-Rock Cement Company", 42)
    company3.show() // PRINTS: Company Name: Hard-Rock Cement Company - Number of Employees: 42
  }
}


===============================================================================

GETTER AND SETTER METHODS
=========================

The syntax used for defining getter and setter methods for regular Scala
classes is rather strange.  The following code demonstrates how to use
getter and setter methods for standard Scala classes.  Read the comments
for details.  For more info on Scala classes see:
http://docs.scala-lang.org/tour/classes.html

object Demo
{
  class Point
  {
    private var _x = 0
    private var _y = 0
    private val bound = 100

    def x = { _x } // This is a getter method.
    // The method below is a setter method.  There must be no whitespace before or after the _ character for x_=
    def x_= (newValue: Int): Unit =
    {
      if (newValue < bound) _x = newValue
      else printWarning
    }

    def y = { _y } // This is a getter method.
    // The method below is a setter method.  There must be no whitespace before or after the _ character for y_=
    def y_= (newValue: Int): Unit =
    {
      if (newValue < bound) _y = newValue
      else printWarning
    }

    private def printWarning = println("WARNING: Out of bounds!")
  }

  def main(args: Array[String]) =
  {
    val point1 = new Point

    // The following 2 lines call the above setter methods x_= and y_=
    point1.x = 99  // This line calls the x_= setter method.
    point1.y = 101 // This line calls the y_= setter method.

    // The following 2 lines call the above getter methods x and y
    println("point1.x = " + point1.x) // This line calls the x getter method.
    println("point1.y = " + point1.y) // This line calls the y getter method.
  }
}

===============================================================================

ADVANCED VISIBILITY MODIFIERS
=============================
Scala has keywords 'private' and 'protected' that visibility modifiers.  Those
keywords  can be followed by square brackets [], and the name of an enclosing
scope of one of the following...

1) package
2) class
3) trait
4) object

If you want to a make a method available to all members of the current package
(aka, “package scope”), mark the method as being private to the current package,
with the private[packageName] syntax as in this example:

There are three (3) main levels of visibility in Scala, they are:

1) public (default) - There does NOT exist a public keyword in Scala.  If you want
                      something public, it's public BY DEFAULT, which means you
                      wouldn't use the private or protected keyword.  If the
                      visibility level is public, a class's val/var member or
                      method is accessible by code inside, or outside, the class.
2) private - A "private" declaration means a class's val/var member or method
             can be accessed only inside the class.  If you prefix a declaration
             inside a class with the private keyword, that member will be visible
             to that class only.  This means a private method is NOT made avaiable
             to subclasses.
3) protected - A protected declaration is much like private, except protected class
               members are also accessible in subtypes (children) of the class.
               This means a protected method IS made available to subclasses.

===============================================================================

package com.acme.coolapp.model
{
    class Foo
    {
        private[model] def doX {}
        private def doY {}
    }
    class Bar
    {
        val f = new Foo
        f.doX  // compiles
        f.doY  // won't compile
    }
}

These advanced modifiers will make class members publicly visible for everything
at that scope and closer to the declaration.  The benefit of this is that special
access can be attained for closely-related code without making a member public
to the entire world.  For more details regarding scope, go to this URL:

https://alvinalexander.com/scala/how-to-control-scala-method-scope-object-private-package

The following code shows how private[this] differs from the standard private declaration.
Read the comments at the top of the Account class definition...

object Demo
{
  def main(args: Array[String]):Unit =
  {
    val myAccount = new Account

    myAccount.deposit(111)
    println("myAccount.bal = " + myAccount.balance) // PRINTS: myAccount.bal = 111

    myAccount.modifyBalDirectly(222)
    println("myAccount.bal = " + myAccount.balance) // PRINTS: myAccount.bal = 222

    myAccount.modifyBalViaArgument(myAccount, 333)  // Read the Account class comments below.
    println("myAccount.bal = " + myAccount.balance) // PRINTS: myAccount.bal = 333
  }

  /**
    * NOTE: If you replace this line of code:  private var bal = 0
    *       with this line of code:            private[this] var bal = 0
    *       the modifyBalViaArgument() function WILL NOT COMPILE cuz it's
    *       attempting to modify bal via an externally-declared class,
    *       which isn't allowed when it's a private[this] declaration.
    */
  class Account
  {
    private var bal = 0
    // private[this] var bal = 0

    def deposit(amount:Int):Boolean =
    {
      if (amount > 0) { bal += amount; true } else false
    }
    def withdraw(amount:Int):Boolean =
    {
      if (amount > 0 && amount < balance) { bal -= amount; true } else false
    }
    def modifyBalDirectly(value:Int):Unit = { bal = value }
    def modifyBalViaArgument(accountA:Account, value:Int):Unit = { accountA.bal = value }
    def balance = bal
  }
}

====================================================================================
