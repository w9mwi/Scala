Scala provides three constructs for creating user-defined types:

1) class  (Scala has two types of class:  A "case class" and a regular "class")
2) object (Scala has two kinds of object: A "case object" and a regular "object")
3) trait

Use a Scala trait to represent a "behavior", such as communicate, learn,
transport, work, etc.  (Traits are NOT covered in this section.  See the
section titled "Trait" instead.)

Use a Scala class, or a Scala object, to represent a thing/object.

When there can exist MULTIPLE things/objects (for example, a person),
use a Scala class.  A Person class would be defined to store data
about the person; i.e., Name, Address, Social Security Number, etc.
After you write the definition of a class (whether it's a "case class"
or a regular "class"), you then need to instantiate (create) a new
Person class for each person.

When there can exist ONLY ONE of something (for example, planet Earth),
use a Scala object to represent it.  A Scala object always represents
a singleton (a single entity).  A Scala object CAN'T contain args/params,
and CAN'T be instantiated.  So once you write an object's definition,
it's available for use without having to instantiate it.  A Scala object
is "lazy", which means it gets created the first time it's referenced.
An object can extend a class or a trait, but a class CAN'T extend an object.


DIFFERENCES BETWEEN A SCALA "case class" AND A SCALA "class"
============================================================
Here's an example of how to create a simple class, and a simple case class.
Both of these classes store a "name" and "Id" as a val--so they are basically
equivalent classes.  However, a regular class (the PersonClass) REQUIRES its
args/params to be preceded with the keyword "val" or "var", or it won't compile.
The args/params passed to a case class (the PersonCaseClass) become "val" by
default when they're not specified.  However, you can explicitly precede the
args/params passed to a case class with the keyword "val" or "var" if you choose.

   class PersonClass(val name:String, val Id:Int)  // A class definition.
   val joe = new PersonClass("Jim", 12345)         // The class being instantiated.

   case class PersonCaseClass(name:String, id:Int) // A case class definition.
   val jim = PersonCaseClass("Joe", 98765)         // The case class being instantiated.

A Scala "case class" is different from a regular Scala class in the following 6 ways.

1) A case class MUST contain one or more args/params in its definition,
   while a plain Scala class can contain zero, or multiple, args/params.

2) The args/params passed to a plain Scala class become PUBLIC class members
   ONLY when they're preceded with the val or var keyword.  If its args/params
   aren't preceded with val/var, they become PRIVATE members, accessible only
   from within the body of the class.

   All args/params passed to a Scala case class become PUBLIC class members by
   default, regardless if they're preceded with keywords val/var, or nothing.
   If the args/params passed to a case class are preceded with nothing, they
   become val by default.

   Within the body of a plain class, or a case class, you can declare additional
   val/var class members, and define them to be "private" or "protected" members.
   If you don't define them as "private" or "protected", they are PUBLIC class
   members by default.  (In Scala, there is no keyword named "public".)
   
   The following code sample demonstrates this behavior.  Read in-line comments
   for details.
   ===========================================================================
   object Demo
   {
     // Both args/params passed to PersonClass_1 become public
     // members by default, because they're preceded with
     // keywords val or var.
     class PersonClass_1(val name: String, var age: Int) {
       def printArgs(): Unit = {
         println(s"PersonClass_1.name = $name,  PersonClass_1.age = $age")
       }
     }

     // Both args/params passed to PersonClass_2 become private class
     // members because they're NOT preceded with keywords val or var.
     // The private members "name" and "age" are accessed and printed
     // after the PersonClass_2 is instantiated, by calling the method
     // printArgs().
     class PersonClass_2(name:String, age:Int) {
       def printArgs():Unit = {
         println(s"PersonClass_2.name = $name,  PersonClass_2.age = $age")
       }
     }

     // All args/params passed to PersonCaseClass become public
     // members by default, regardless if they're preceded with
     // val, var, or nothing.
     case class PersonCaseClass(name:String, val age:Int) {
       def printArgs(): Unit = {
         println(s"PersonCaseClass.name = $name,  PersonCaseClass.age = $age")
       }
     }

     def main(args: Array[String]):Unit = {
       // **********************************
       // Test PersonClass_1 behavior:
       val person_1 = new PersonClass_1("Joe", 15)
       person_1.printArgs() // PRINTS: PersonClass_1.name = Joe,  PersonClass_1.age = 15

       // The following 2 lines compile because person_1.name and person_1.age
       // are public class members.
       var name = person_1.name
       var age  = person_1.age

       // **********************************
       // Test PersonClass_2 behavior:
       val person_2 = new PersonClass_2("Jack", 23)
       person_2.printArgs() // PRINTS: PersonClass_2.name = Jack,  PersonClass_2.age = 23

       // If you uncomment the following 2 lines, they won't compile because
       // person_2.name and person_2.age are private class members.
       // name = person_2.name  // WON'T COMPILE!
       // age  = person_2.age   // WON'T COMPILE!

       // **********************************
       // Test PersonCaseClass behavior:
       val person_3 = new PersonCaseClass("Sally", 47)
       person_3.printArgs() // PRINTS: PersonCaseClass.name = Sally,  PersonCaseClass.age = 47

       // The following 2 lines compile because ALL args/params passed
       // to a case class are ALWAYS public class members.
       name = person_3.name
       age  = person_3.age
     }
   }
   ===========================================================================

3) When a "case class" is instantiated, the following 6 methods become
   available by default, so you never need to write them yourself.

   apply()   - This method gets called automatically whenever a Scala class
               (or case class) is instantiated.  Both a regular class also
               supplies the apply() method by default, but you can replace
               it by writing your own apply() method if you choose.
   unapply() - This method gets called automatically whenever pattern matching
               is performed on a Scala class (or case class).  If you want
               to perform pattern matching on a regular class, you must write
               your own unapply() method because it's not provided by default.
   copy()    - Creates, and returns, a new "case class" instance that's a copy
               of the existing case class.  If you pass this copy() method any
               args/params, those args/params specify the case class member
               values that will be changed in the copied-to (returned) instance.
               Only the newly-created case class will contain the changes you
               specify via the args/params.  Calling copy() on a case class DOESN'T
               make any changes to the copied-from case class.
   equals()  - Determines if two Scala objects are equal.  Read the hashCode() description below.
   hashCode() - Returns an Int value.  If calling hashCode() on two Scala objects
                return the same Int value, they are equal.  You can use the equals()
                method or the '==' operator in place of calling hashCode() to
                determine equivalency.
   toString() - Renders the case class’s name and fields to a String.

4) A case class is Serializable.

5) A case class CAN be abstract, like this:   abstract case class Card(id:Int)

6) A regular class can extend a trait.  But a case class CAN'T extend a trait,
   or another case class.  However, a case class CAN extend a regular class OR
   an abstract class.  The following example will work with or without the
   "abstract" keyword:

   abstract class Card(id:Int)
   case class DebitCard(id:Int, name:String, number:Int) extends Card(id)


SCALA COMPANION OBJECTS
=======================
Before a Scala "companion object" is explained, let's review these facts
about a Scala object...

When there can exist ONLY ONE of something (for example, planet Earth),
use a Scala object to represent it.  A Scala object always represents
a singleton (a single entity).  A Scala object CAN'T contain args/params,
and CAN'T be instantiated.  So once you write an object's definition,
it's available for use without having to instantiate it.  A Scala object
is "lazy", which means it gets created the first time it's referenced.
An object can extend a class or a trait, but a class CAN'T extend an object.

When both a Scala object and a Scala class (or case class) have identical
names, and they're both contained in the same file, the object is called
a "companion object" to the class.  Conversely, the class is called a
"companion class" to the object.

A companion object can access the private members of its companion class.
AND
A companion class can access the private members of its companion object.

Use a companion object for methods and vals/vars that apply to all instances
of the companion class.  For example, instead of defining a method named
printPersonInfo() inside a class named Person, it'd be better to define
that method inside a companion object named Person.  So instead of creating
1,000 redundant methods named printPersonInfo() for 1,000 Person classes
instantiated, there would exist only one instance of it in the companion
object.  Here is an example...

========================================================================
import Demo.Person.printPersonInfo

object Demo
{
  // IMPORTANT: The class Person and the object Person defined below
  //            can be defined inside the object Demo (as they are
  //            in this example), or they can be moved outside the
  //            object Demo.  They will work in either location,
  //            as long as they are both defined in the same file.
  case class Person(name: String, age: Int)

  // Instead of defining printPersonInfo() inside the class Person,
  // define it here, inside the object Person, which is the
  // COMPANION OBJECT of the class Person.
  object Person {
    def printPersonInfo(person:Person): Unit = {
      println(s"name = ${person.name}, age = ${person.age}")
    }
  }

  def main(args: Array[String]):Unit = {
    val person_1 = Person("Jack", 17)
    printPersonInfo(person_1) // PRINTS: name = Jack, age = 17

    val person_2 = new Person("Jane", 13)
    printPersonInfo(person_2) // PRINTS: name = Jane, age = 13

    val person_3 = new Person("Julie", 23)
    printPersonInfo(person_3) // PRINTS: name = Julie, age = 23
  }
}

========================================================================
Besides containing vals/vars and methods that apply to all instances of
a given class, another use of a companion object is to contain the apply()
and/or unapply() methods for a plain Scala class.  What are a class's
apply() and unapply() methods used for?...

Whenever a class is instantiated, Scala automatically invokes that
class's apply() method.  Whenever pattern matching is performed on
a class, Scala automatically invokes that class's unapply() method.
Scala automatically provides both the apply() and unapply() methods
to a case class, so you never need to write those methods for a
case class.

Scala also provides an apply() method to plain Scala classes, so
it's rare, if ever, that you'd need to write an apply() method
for a plain Scala class.  However, if you want to perform pattern
matching on a plain Scala class, you need to write an unapply()
method for that class, and place it in a companion object for that
class, where it will automatically get invoked by Scala whenever
a pattern match is performed on the class.

If a class's constructor contains a variable number of arguments, and
you want to perform pattern matching on that class, instead of writing
an unapply() method for that class, you must to instead write an
unapplySeq() method, and place it in the class's companion object.

The following code sample shows how to write your own apply()
and unapply() methods for a plain Scala class, and put them
inside a companion object.

========================================================================
import Demo.Person.printPersonInfo
object Demo
{
  class Person(val name:String, val age:Int)

  // *************************************************
  // This is a COMPANION OBJECT to the class Person...
  object Person {
    // This apply() method gets called automatically by Scala
    // when a Person class is instantiated.
    def apply(name: String, age:Int): Person = {
      new Person(name, age)  // Instantiate and return a Person class.
    }

    // This unapply() method gets called automatically by Scala
    // when a pattern match is performed on the Person class.
    // In this unapply(), we return a (String, Int) tuple.  The
    // commented-out unapply() method further below can be used
    // instead, to return only a string.
    def unapply(p: Person):Some[(String, Int)] = {
      print("unapply() #1 called:  ")
      Some(p.name, p.age)
    }

//    def unapply(p: Person):Some[String] = {
//      Some(s"unapply() #2 called:  ${p.name}, ${p.age}")
//    }

    def printPersonInfo(person: Person): Unit = {
      println(s"name = ${person.name}, age = ${person.age}")
    }
  }
  // *************************************************

  def main(args: Array[String]):Unit = {
    // Because we wrote an apply() method for class Person (and
    // placed it in the companion object), we can instantiate the
    // class Person without using the "new" keyword, which is
    // how a case class is instantiated.
   val person_1 = Person("Jack", 17)
    printPersonInfo(person_1) // PRINTS: name = Jack, age = 17

    person_1 match {
      case Person(x, y) => println(x, y) // PRINTS: unapply() #1 called:  (Jack,17)

      // Use the following commented-out line with the commented-out unapply() method.
      // case Person(x) => println(x) // PRINTS: unapply() #2 called:  Jack, 17

      case _ => println("No pattern match.")
    }
  }
}
========================================================================

EXPLANATION OF A SCALA "case object"
====================================
Just as you can create a "case class" in Scala, you can also create
a "case object."  A "case object" differs from a regular object in
these ways.
1) A case object is serializable.
2) A case object has a default hashCode() implementation.
3) A case object has an improved toString implementation.

The use of case objects is NOT common, but they are used for enumerations.
Like this, for example:

sealed trait Topping
case object Cheese    extends Topping
case object Pepperoni extends Topping
case object Sausage   extends Topping
case object Mushrooms extends Topping
case object Onions    extends Topping

Scala also has the following type of classes.
This page doesn't discuss these class types.

* Anonymous class
* Generic class
* Implicit class
* Inner class

Below are some code samples demonstrating:

* When an object and a class have identical names, how can the
  code determine if it's referencing the object or the class?
* Scala classes
* Scala objects
* Scala companion objects
* apply() method
* unapply() method
* pattern matching

=============================================================================
When a piece of code contains both an object and a class with identical
names, the object is usually a "companion object" to the class.  In the
following code example, the object Kid is NOT a companion object to
the class Kid.

Read the in-line comments below to understand that when an object and
a class have identical names, they have DIFFERENT types.

object Demo
{
  class Kid(name:String, age:Int) {
    def greeting():String = s"My name is $name.  I am $age years old."
  }

  object Kid {
    val IS_ADULT:Boolean            = false
    val IS_COLLEGE_GRADUATE:Boolean = true
  }

  def main(args: Array[String]):Unit = {
    val kidClass:Kid = new Kid("Jane Train", 13)
    println(s"${kidClass.greeting}") // PRINTS: My name is Jane Train.  I am 13 years old.

    // IMPORTANT: The class Kid has the type:  Kid
    //            The object Kid has the type: Kid.type
    //
    // If you uncomment the following commented-out line, it WON'T COMPILE.
    // It won't compile because KidObject is declared to have the type of Kid,
    // which references the class Kid.  But Kid on the right side of the
    // '=' sign references the object Kid, which causes a type mismatch.
    // val kidObject:Kid = Kid  // WON'T COMPILE!

    // The following line successfully compiles because kidObject is declared
    // to have the type of Kid.type, which is the type of the object Kid.  The
    // Kid on the right-side of the '=' sign is an object Kid (not a class Kid).
    val kidObject:Kid.type = Kid  // Assigns the object Kid (defined above) to kidObject.

    // Because the val kid below isn't declared to have a type, it references whatever
    // gets assigned to it.  So in this example, the val kid references the object Kid,
    // because Kid is an object, not a class.
    val kid = Kid

    println(s"kid.IS_ADULT = ${kid.IS_ADULT},  kid.IS_COLLEGE_GRADUATE = ${kid.IS_COLLEGE_GRADUATE}")
    // PRINTS:  kid.IS_ADULT = false,  kid.IS_COLLEGE_GRADUATE = true
  }
}

===============================================================================

The following code sample demonstrates how to use a "case class."

object Demo
{
  // This is a case class definition.  A case class
  // differs in some ways from a regular class.
  case class Person(firstName:String, lastName:String)

  /**************************************************
   * main()
   **************************************************/
  def main(args: Array[String]): Unit = {
    val joe:Person = Person("Joe", "Blow")
    println(s"1) joe.firstName = ${joe.firstName},  joe.lastName = ${joe.lastName}")
    // PRINTS: 1) joe.firstName = Joe,  joe.lastName = Blow

    joe match {
      case x => println(s"2) x.firstName = ${x.firstName},  x.lastName = ${x.lastName}")
      // PRINTS: 2) x.firstName = Joe,  x.lastName = Blow
      case _ => println("NO PATTERN MATCH")
    }

    joe match {
      case Person(fn, ln) => println(s"3) fn = $fn,  ln = $ln") // PRINTS: 3) fn = Joe,  ln = Blow
      case _ => println("NO PATTERN MATCH")
    }

    // The following line of code doesn't seem to make sense because it's NOT
    // very intuitive.  The following line of code is an assignment statement
    // which performs a pattern match on "val joe" by automatically invoking
    // the Person.unapply() method.  The Person.unapply() method extracts
    // joe.firstName and joe.lastName from val joe, then assigns them to the
    // vals "first" and "last" respectively.
    // NOTE: If the following line contained the keyword var instead of val,
    //       then first and last would become vars instead of vals.
    val Person(first, last) = joe
    println(s"4) first = $first,  last = $last") // PRINTS: 4) first = Joe,  last = Blow
  }
}

===============================================================================

The following code sample demonstrates how to use a regular class,
its companion object, the apply() and unapply() methods, and some
pattern matching.

object Demo
{
  // The line of code below defines a Person class.  (NOTE: Person is defined
  // here as a regular class, not a "case class.")  In a regular class, an
  // argument that's not preceded with the "val" or "var" keyword remains only
  // an argument, and doesn't become a member of the class.  (FYI, in a case class
  // all arguments become members of the case class automatically, even if they're
  // not preceded with the "val" or "var" keyword--by default, they're vals.)
  //
  // Because the firstName and lastName arguments passed to Person in the line
  // below are preceded by the val keyword, firstName and lastName become
  // members of the Person class.  So when a Person class is instantiated,
  // its members (firstName and lastName) get initialized.
  class Person(val firstName: String, val lastName: String)

  /**************************************************
   *  When you define a regular class (not a case class) that accepts
   *  constructor argument(s), you can also define a companion object,
   *  but it's not required.  In this example the object Person defined
   *  below becomes the companion object to the Person class defined above.
   **************************************************/
  object Person {
    // Scala automatically invokes this apply() method
    // when a Person class is instantiated.
    def apply(firstName:String, lastName:String): Person = {
      new Person(firstName, lastName) // Don't forget to include the "new" keyword!
    }
    // Scala automatically invokes this unapply() method when
    // pattern matching is performed on a Person class.
    def unapply(person:Person):Some[(String, String)] = {
      Some(person.firstName, person.lastName)
    }
  }

  /**************************************************
   * main()
   **************************************************/
  def main(args: Array[String]): Unit = {
    val joe:Person = Person("Joe", "Blow") // Person.apply() automatically gets called.
    println(s"1) joe.firstName = ${joe.firstName},  joe.lastName = ${joe.lastName}")
    // PRINTS: 1) joe.firstName = Joe,  joe.lastName = Blow

    // The following match statement DOESN'T require the Person.unapply() method!
    joe match {
      case x => println(s"2) x.firstName = ${x.firstName},  x.lastName = ${x.lastName}")
      // PRINTS: 2) x.firstName = Joe,  x.lastName = Blow
      case _ => println("NO PATTERN MATCH")
    }

    // The following line of code WON'T COMPILE without the Person.unapply() method.
    // The following match statement automatically invokes the Person.unapply() method.
    joe match {
      case Person(fn, ln) => println(s"3) fn = $fn,  ln = $ln") // PRINTS: 3) fn = Joe,  ln = Blow
      case _ => println("NO PATTERN MATCH")
    }

    // The following line of code WON'T COMPILE without the Person.unapply() method.
    // The following line of code doesn't seem to make sense because it's NOT
    // very intuitive.  The following line of code is an assignment statement
    // which performs a pattern match on "val joe" by automatically invoking
    // the Person.unapply() method.  The Person.unapply() method extracts
    // joe.firstName and joe.lastName from val joe, then assigns them to the
    // vals "first" and "last" respectively.
    // NOTE: If the following line contained the keyword var instead of val,
    //       then first and last would become vars instead of vals.
    val Person(first, last) = joe
    println(s"4) first = $first,  last = $last") // PRINTS: 4) first = Joe,  last = Blow
  }
}


===============================================================================

The following code sample contains no Scala classes, and therefore no companion objects.
All of the objects are pure singleton objects, not associated with any companion class.
This code demonstrates more complex examples of how to use pattern matching, including
using the unapplySeq() method for dealing with an unknown (variable) number of arguments.

import java.time.{LocalDate, LocalDateTime, LocalTime}
object Demo
{
  object DateTime {  // A pure singleton object, not associated with a companion class.
    def unapply(dt: LocalDateTime): Some[(LocalDate, LocalTime)] =
      Some((dt.toLocalDate, dt.toLocalTime))
  }

  object Date {  // A pure singleton object, not associated with a companion class.
    def unapply(date: LocalDate): Some[(Int, Int, Int)] =
      Some((date.getYear, date.getMonthValue, date.getDayOfMonth))
  }

  object Time {  // A pure singleton object, not associated with a companion class.
    def unapply(time: LocalTime): Some[(Int, Int, Int)] =
      Some((time.getHour, time.getMinute, time.getSecond))
  }

  // When an unknown (variable) number of arguments must be
  // extracted from a class, the unapply() method won't work.
  // When you need to extract an unknown (variable) number of
  // arguments from a class, you must write an unapplySeq()
  // method.  Just as Scala automatically invokes the unapply()
  // method in a companion object, Scala automatically invokes
  // the unapplySeq() method when it's called for.
  object DateTimeSeq {  // A pure singleton object, not associated with a companion class.
    def unapplySeq(dt: LocalDateTime):Some[Seq[Int]] = {
      Some(Seq(dt.getYear, dt.getMonthValue, dt.getDayOfMonth,
               dt.getHour, dt.getMinute,     dt.getSecond))
    }
  }

  // Notice the if() statement embedded within the match/case statement,
  // which allows more flexibility.  When the if() statement is true,
  // the match is successful.  When it's false, the match fails.
  object AM {  // A pure singleton object, not associated with a companion class.
    def unapply(time: LocalTime):Option[(Int, Int, Int)] = {
      time match {
        case Time(hour, minute, second) if (hour < 12) => Some((hour, minute, second))
        case _ => None  // No match above is successful.
      }
    }
  }

  // Notice the if() statement embedded within the match/case statement,
  // which allows more flexibility.  When the if() statement is true,
  // the match is successful.  When it's false, the match fails.
  object PM { // A pure singleton object, not associated with a companion class.
    def unapply(time: LocalTime):Option[(Int, Int, Int)] = {
      time match {
        case Time(12, minute, second) => Some(12, minute, second)
        case Time(hour, minute, second) if (hour > 12) => Some(hour-12, minute, second)
        case _ => None  // No match above is successful.
      }
    }
  }

  /**************************************************
   * main()
   *************************************************/
  def main(args: Array[String]): Unit = {
    // The pattern match performed on the following line of code will succeed
    // because it's written properly.  When it succeeds, year, month, and date
    // become Int vars, which are used in the following println statement.
    var Date(year, month, date) = LocalDate.now
    println(s"Date_1 = ${getMonthName(month)} $date, $year")

    // The pattern match performed on the following line of code will succeed
    // because it's written properly.  When it succeeds, hour, minute, and date
    // become Int vars, which are used in the following println statement.
    var Time(hour, minute, second) = LocalTime.now
    println(s"Time_1 = $hour:$minute:$second")

    Thread.sleep(2000) // Wait 2 seconds.

    // The following line of code obtains the same Date and Time information
    // as the above examples,  but in a single line of code.  Hovever the
    // following pattern match format is different than the one above.
    // NOTE: Even though year, hour, etc. are declared above as vars,
    //       they CAN'T be reused again in the following pattern match.
    //       This is because they've already been declared, and the
    //       following line of code would try to declare them a second
    //       time.  That's is why year2, hour2, etc. are used instead.
    var DateTime(Date(year2, month2, date2), Time(hour2, minute2, second2)) = LocalDateTime.now
    println(s"Date_2 = ${getMonthName(month2)} $date2, $year2")
    println(s"Time_2 = $hour2:$minute2:$second2")

    Thread.sleep(2000) // Wait 2 seconds.
    // To understand the following line of code, read comments in the getTimeString() method.
    println(s"Time_3 = ${getTimeString(LocalTime.now)}")

    // The following line of code obtains a subset of the information returned
    // by the call to LocalDateTime.now.  We're not interested in obtaining
    // the minutes or seconds from LocalDateTime.now.  So instead of supplying
    // var names of minutes and seconds, we specify "_*", which accepts a
    // variable number of arguments that we ignore.
    var DateTimeSeq(year3, month3, date3, hour3, _*) = LocalDateTime.now
    println(s"Date_4 = ${getMonthName(month3)} $date3, $year3")
    println(s"Time_4 = $hour3:??:??")
  }

  /************************************************
   * This getMonthName() method performs standard,
   * easy-to-understand pattern matching.
   ***********************************************/
  def getMonthName(monthNumber: Int):String = {
    monthNumber match {
      case 1 => "January";   case  2 => "February"; case  3 => "March";    case  4 => "April";
      case 5 => "May";       case  6 => "June";     case  7 => "July";     case  8 => "August";
      case 9 => "September"; case 10 => "October";  case 11 => "November"; case 12 => "December";
      case _ => "NO MATCH"
    }
  }

  /************************************************
   * This getTimeString() method gets passed an argument
   * of type Time.  It converts that Time value into a
   * String by performing the following 3 transfomations
   * then returns that String.
   *
   * 1) Zero-fills the minute and second values when they're < 10.
   * 2) Converts 24-hour time into 12-hour time with AM or PM appended.
   * 3) Appends to that String the exact value of Time passed to this method.
   *
   * This method performs a pattern match on localTime, which is passed
   * to this method.  The "match" keyword automatically invokes a call
   * to AM.unapply().  If localTime passed to this method matches the
   * AM(h, m, s) pattern, AM.unapply() returns a Time value, meaning the
   * pattern match succeeded.  If the pattern match succeeded, the syntax
   * "time @ AM(h, m, s)" binds localTime to "time" which, is a val.  The
   * formatted String after the rocket (=>) is then returned by this method.
   *
   * If AM.unapply() returns None, that pattern match failed.  So the
   * next line of code is executed, which works the same as the first
   * line of code.// The following 2 lines of code explained...
   * A pattern match is performed on localTime, which is passed to this method.
   * The "match" keyword automatically invokes a call to AM.unapply().  If
   * localTime passed to this method matches the AM(h, m, s) pattern,
   * AM.unapply() returns a Time value, meaning the pattern match succeeded.
   * If the pattern match succeeded, the syntax  "time @ AM(h, m, s)"  binds
   * localTime to "time" which, is a val.  The formatted String after the
   *  rocket (=>) is then returned by this method.
   *
   * If AM.unapply() returns None, that pattern match failed.  So the
   * next line of code is executed, which works the same as the first
   * line of code.
   ***********************************************/
   def getTimeString(localTime:LocalTime):String = {
     localTime match {
       case time @ AM(h, m, s) => f"$h%2d:$m%02d:$s%02d AM ($time precisely)"
       case time @ PM(h, m, s) => f"$h%2d:$m%02d:$s%02d PM ($time precisely)"
    }
  }
}

===============================================================================
Here's another example of how to perform pattern matching using the "match" keyword.

object Demo
{
  // NOTICE: The Email, SMS, VoiceRecording, and MorseCodeNotify case classes declarations
  //         below all extend the Notification class, which is an abstract class.
  //         Therefore, these 4 case classes can be treated as a Notification class.
  abstract class Notification
  case class Email(sender:String, title:String, body:String) extends Notification
  case class SMS(caller:String, message:String)              extends Notification
  case class VoiceRecording(contactName:String, link:String) extends Notification
  case class MorseCodeNotify()                               extends Notification

  def main(args: Array[String])
  {
    // We now demonstrate how to pattern match on the 4 case classes defined above.
    // Because all 4 of those case classes extend the Notification abstract class,
    // we can pass these classes as an argument to the showNotification() method
    // below, as type Notification.
    val emailNotify:Email               = Email("Sender Bender", "Titletown, USA", "Hi.  See you later.")
    val smsNotify:SMS                   = SMS("12345", "Are you there?")
    val voiceNotify:VoiceRecording      = VoiceRecording("Jack", "www.420.com")
    val morseCodeNotify:MorseCodeNotify = MorseCodeNotify()

    println

    println(showNotification(morseCodeNotify))
    // PRINTS: This is an unknown Notification message.

    println(showNotification(voiceNotify))
    // PRINTS: You received a Voice Recording from Jack.  To hear it, click on: www.420.com

    println(showNotification(emailNotify))
    // PRINTS: You have an email from Sender Bender with title: Titletown, USA

    println(showNotification(smsNotify))
    //PRINTS: You have an SMS from 12345! Message: Are you there?
  }

  def showNotification(notification:Notification):String =
  {
    notification match
    {
      case Email(email, title, _)     => s"You have an email from $email with title: $title"
      case SMS(number, message)       =>  s"You have an SMS from $number! Message: $message"
      case VoiceRecording(name, link) =>  s"You received a Voice Recording from $name!  To hear it, click on: $link"
      case _                          => "This is an unknown Notification message."
    }
  }
}

===============================================================================

AUXILIARY CLASS CONSTRUCTORS
----------------------------
A Scala Class can have multiple constructors.  The "default" constructor
is known as the "primary constructor".  The programmer can create additional
class constructors known as "auxiliary constructors" by defining them inside
the class, using the "this" keyword as the following example shows.
NOTE: The equal sign (=) in the constructor is optional--it's NOT required.

def this(arg1:datatype, arg2:datatype) = { Constructor code here. }

The following code contains TWO (2) auxiliary constructors defined
by the programmer.  The programmer never defines the primary
constructor because Scala defines it by default.

object Demo
{
  class Company
  {
    private var companyName:String = ""
    private var noOfEmployees:Int  = 0

    def show()
    {
      println("Company Name: " + companyName + " - Number of Employees: " + noOfEmployees)
    }

    // This Auxiliary Constructor contains one argument...
    def this(companyName: String)
    {
      this() // Calls the primary constructor, which is always available by default.
      this.companyName = companyName
    }

    // This Auxiliary Constructor contains two arguments...
    def this(companyName:String, noOfEmployees:Int)
    {
      this(companyName) // Calls the Auxiliary Constructor that has one argument.
      this.noOfEmployees = noOfEmployees
    }
  }

  def main(args: Array[String])
  {
    // Calls the Primary Constructor, which contains zero arguments...
    val company1 = new Company()
    company1.show() // PRINTS: Company Name:  - Number of Employees: 0

    // Calls the auxiliary constructor containing one argument...
    val company2 = new Company("Joe's Pipes, Inc.")
    company2.show() // PRINTS: Company Name: Joe's Pipes, Inc. - Number of Employees: 0

    // Calls the auxiliary constructor containing two arguments...
    val company3= new Company("Hard-Rock Cement Company", 42)
    company3.show() // PRINTS: Company Name: Hard-Rock Cement Company - Number of Employees: 42
  }
}


===============================================================================

GETTER AND SETTER METHODS
=========================

The syntax used for defining getter and setter methods for regular Scala
classes is rather strange.  The following code demonstrates how to use
getter and setter methods for standard Scala classes.  Read the comments
for details.  For more info on Scala classes see:
http://docs.scala-lang.org/tour/classes.html

object Demo
{
  class Point
  {
    private var _x = 0
    private var _y = 0
    private val bound = 100

    def x = { _x } // This is a getter method.
    // The method below is a setter method.  There must be no whitespace before or after the _ character for x_=
    def x_= (newValue: Int): Unit =
    {
      if (newValue < bound) _x = newValue
      else printWarning
    }

    def y = { _y } // This is a getter method.
    // The method below is a setter method.  There must be no whitespace before or after the _ character for y_=
    def y_= (newValue: Int): Unit =
    {
      if (newValue < bound) _y = newValue
      else printWarning
    }

    private def printWarning = println("WARNING: Out of bounds!")
  }

  def main(args: Array[String]) =
  {
    val point1 = new Point

    // The following 2 lines call the above setter methods x_= and y_=
    point1.x = 99  // This line calls the x_= setter method.
    point1.y = 101 // This line calls the y_= setter method.

    // The following 2 lines call the above getter methods x and y
    println("point1.x = " + point1.x) // This line calls the x getter method.
    println("point1.y = " + point1.y) // This line calls the y getter method.
  }
}

===============================================================================

ADVANCED VISIBILITY MODIFIERS
=============================
Scala has keywords 'private' and 'protected' that visibility modifiers.  Those
keywords  can be followed by square brackets [], and the name of an enclosing
scope of one of the following...

1) package
2) class
3) trait
4) object

If you want to a make a method available to all members of the current package
(aka, “package scope”), mark the method as being private to the current package,
with the private[packageName] syntax as in this example:

There are three (3) main levels of visibility in Scala, they are:

1) public (default) - There does NOT exist a public keyword in Scala.  If you want
                      something public, it's public BY DEFAULT, which means you
                      wouldn't use the private or protected keyword.  If the
                      visibility level is public, a class's val/var member or
                      method is accessible by code inside, or outside, the class.
2) private - A "private" declaration means a class's val/var member or method
             can be accessed only inside the class.  If you prefix a declaration
             inside a class with the private keyword, that member will be visible
             to that class only.  This means a private method is NOT made avaiable
             to subclasses.
3) protected - A protected declaration is much like private, except protected class
               members are also accessible in subtypes (children) of the class.
               This means a protected method IS made available to subclasses.

===============================================================================

package com.acme.coolapp.model
{
    class Foo
    {
        private[model] def doX {}
        private def doY {}
    }
    class Bar
    {
        val f = new Foo
        f.doX  // compiles
        f.doY  // won't compile
    }
}

These advanced modifiers will make class members publicly visible for everything
at that scope and closer to the declaration.  The benefit of this is that special
access can be attained for closely-related code without making a member public
to the entire world.  For more details regarding scope, go to this URL:

https://alvinalexander.com/scala/how-to-control-scala-method-scope-object-private-package

The following code shows how private[this] differs from the standard private declaration.
Read the comments at the top of the Account class definition...

object Demo
{
  def main(args: Array[String]):Unit =
  {
    val myAccount = new Account

    myAccount.deposit(111)
    println("myAccount.bal = " + myAccount.balance) // PRINTS: myAccount.bal = 111

    myAccount.modifyBalDirectly(222)
    println("myAccount.bal = " + myAccount.balance) // PRINTS: myAccount.bal = 222

    myAccount.modifyBalViaArgument(myAccount, 333)  // Read the Account class comments below.
    println("myAccount.bal = " + myAccount.balance) // PRINTS: myAccount.bal = 333
  }

  /**
    * NOTE: If you replace this line of code:  private var bal = 0
    *       with this line of code:            private[this] var bal = 0
    *       the modifyBalViaArgument() function WILL NOT COMPILE cuz it's
    *       attempting to modify bal via an externally-declared class,
    *       which isn't allowed when it's a private[this] declaration.
    */
  class Account
  {
    private var bal = 0
    // private[this] var bal = 0

    def deposit(amount:Int):Boolean =
    {
      if (amount > 0) { bal += amount; true } else false
    }
    def withdraw(amount:Int):Boolean =
    {
      if (amount > 0 && amount < balance) { bal -= amount; true } else false
    }
    def modifyBalDirectly(value:Int):Unit = { bal = value }
    def modifyBalViaArgument(accountA:Account, value:Int):Unit = { accountA.bal = value }
    def balance = bal
  }
}

====================================================================================
