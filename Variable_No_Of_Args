VARIABLE NUMBER OF ARGUMENTS (VARARGS)
======================================

The code samples below show how to pass a variable number
of arguments to a method.  Read in-line comments for
detailed explanations.

============================================================================

object Demo
{
  def main(args: Array[String])
  {
    // The asterisk in the following "words:String*" argument designates that
    // makeSentence() MUST be called by passing it one or more String arguments.
    def makeSentence(words:String*):String = words.mkString(" ") + "."

    // EXAMPLE 1)
    var strResult:String = makeSentence("Make", "these", "words", "into", "a", "single", "sentence")
    println(s"strResult 1) = $strResult")
    // PRINTS:  strResult 1) = Make these words into a single sentence.
    // ***************************************************************************
    // EXAMPLE 2)  The '_*' characters in the below call to makeSentence()
    //             performs "TYPE ASCRIPTION" at compile time, which up-casts
    //             listOfWords from type List[String] into one or more String
    //             arguments which makeSentence() requires.
    val listOfWords:List[String] = List("Tomorrow", "is", "a", "different", "day")
    strResult = makeSentence(listOfWords: _*)
    println(s"strResult 2) = $strResult")
    // PRINTS: strResult 2) = Tomorrow is a different day.
    // ***************************************************************************
    // EXAMPLE 3) This is identical to EXAMPLE 2) above except makeSentence()
    //            gets passed an Array[String].  As with EXAMPLE 2) above,
    //            makeSentence is called using the '_*' chars, which is explained
    //            in EXAMPLE 2).
    val arrayOfWords:Array[String] = listOfWords.toArray
    strResult = makeSentence(arrayOfWords: _*)
    println(s"strResult 3) = $strResult")
    // PRINTS: strResult 3) = Tomorrow is a different day.
    // ***************************************************************************
    // EXAMPLE 4) Here we first perform an ETA EXPANSION on makeSentence(),
    //            and then call it.
    var etaExpand:(Seq[String]=>String) = makeSentence
    strResult = etaExpand(listOfWords)
    println(s"strResult 4) = $strResult")
    // PRINTS: strResult 4) = Tomorrow is a different day.
    // ***************************************************************************
    // EXAMPLE 5) The following ETA EXPANSION performed on makeSentence is
    //            identical to EXAMPLE 4).  Only the syntax is different.
    etaExpand = makeSentence _
    strResult = etaExpand(listOfWords)
    println(s"strResult 5) = $strResult")
    // PRINTS: strResult 5) = Tomorrow is a different day.

    // NOTE: If you uncomment the following commented-out line it WON'T COMPILE
    //       because makeSentence(_) returns a function of type:  String=>String
    //       While etaExpand is a function of type:  Seq[String]=>String
    // etaExpand = makeSentence(_) // WON'T COMPILE!
  }
}

============================================================================

When a method argument accepts a variable number of arguments, as
designated by the asterisk (*) char, the Scala compiler designates
that argument as type Seq.  So in the following code sample, the
getString() method's "str" argument has the data type Seq[String].

object Demo
{
  def getString(str:String *):String =
  {
    if (str.isInstanceOf[Seq[String]])
      println("str is of type: Seq[String]") // PRINTS: str is of type: Seq[String]

    str.mkString(" ")
  }

  def main(args:Array[String])
  {
    var strResult:String = getString("Cat", "Dog", "Mouse")
    println(s"strResult 1) = $strResult") // PRINTS: strResult 1) = Cat Dog Mouse

    val seqOfStrings:Seq[String] = Seq("Alpha", "Beta", "Xray", "Zulu")
    // NOTE: Although the getString() method's argument "str" is of type
    //       Seq[String], you CAN'T pass getString() an argument having
    //       that data type.  If you uncomment the following line of
    //       code, it WON'T COMPILE because the getString() method MUST
    //       be called with one or more String arguments.
    // getString(seqOfStrings)  // WON'T COMPILE!

    // You can call getString() by passing it a Seq[String], but you MUST add
    // the ":_*" text as shown below.  Doing that performs TYPE ASCRIPTION,
    // as is described in the previous sample program above.
    strResult = getString(seqOfStrings:_*)
    println(s"strResult 2) = $strResult") // PRINTS: strResult 2) = Alpha Beta Xray Zulu

    // Scala Array and List classes are subtypes of Seq, so they can also
    // be passed as arguments to the getString() method, as long as they
    // also include the ":_*" text when they're called.  Examples...
    val arrayOfStrings:Array[String] = seqOfStrings.toArray
    strResult = getString(arrayOfStrings:_*)
    println(s"strResult 3) = $strResult") // PRINTS: strResult 3) = Alpha Beta Xray Zulu

    val listOfStrings:List[String] = seqOfStrings.toList
    strResult = getString(listOfStrings:_*)
    println(s"strResult 4) = $strResult") // PRINTS: strResult 4) = Alpha Beta Xray Zulu
  }
}

============================================================================

object Demo
{
  def main(args: Array[String]): Unit =
  {
    def add(numbers:Double *):Double      = { numbers.reduce(_ + _) }
    def divide(numbers:Double *):Double   = { numbers.reduce(_ / _) }
    def multiply(numbers:Double *):Double = { numbers.reduce(_ * _) }
    def subtract(numbers:Double *):Double = { numbers.reduce(_ - _) }

    val numbersList:List[Double] = List(7777.777D, 2.54D, 33.3D, 10.0D)

    // NOTE: The _* in the following calls to add(), divide(), multiply(), and subtract()
    //       transforms numbersList into 4 SEPARATE numbers of type Double so those
    //       4 functions can handle the "variable number of arguments" they were defined to receive.
    var result:Double = add(numbersList:_*) // Performs this calculation: 7777.777 + 2.54 + 33.3 + 10.0
    println("result = " + result) // PRINTS: result = 7823.617

    result = divide(numbersList:_*) // Performs this calculation: 7777.777 / 2.54 / 33.3 / 10.0
    println("result = " + result) // PRINTS: result = 9.195546333735312

    result = multiply(numbersList:_*) // Performs this calculation: 7777.777 * 2.54 * 33.3 * 10.0
    println("result = " + result) // PRINTS: result = 6578599.342139998

    result = subtract(numbersList:_*) // Performs this calculation: 7777.777 - 2.54 - 33.3 - 10.0
    println("result = " + result) // PRINTS: result = 7731.937
  }
}

============================================================================

object Demo
{
  def main(args:Array[String]): Unit =
  {
    var averageScore:Double = calculateAverage() // PRINTS: numbers IS a Seq[Double] data type.
                                                 //         List()

    printScore(averageScore, "averageScore = ") // PRINTS: The score is not a number.

    averageScore = calculateAverage(1.23, 4.56, 7.89) // PRINTS: numbers IS a Seq[Double] data type.
                                                      //         ArraySeq(1.23, 4.56, 7.89)

    printScore(averageScore, "averageScore = ")  // PRINTS: averageScore = 4.56
  }

  /**
   * @param numbers - NOTE: When a variable number of arguments is passed to a function
   *                        as in this example, the asterisk (*) transforms the data type
   *                        into a Seq[].  For example, even though the "numbers" argument
   *                        is declared as a Double, the asterisk transforms it into a
   *                        a Seq[Double].
   * @return the average of all Double values passed to this function.
   */
  def calculateAverage(numbers:Double *):Double =
  {
    // NOTE: The following if() statement exists to:
    //       1) Demonstrate how to use the isInstanceOf[] method.
    //       2) Demonstrate how to perform pattern matching using the "matches" keyword.
    if (numbers.isInstanceOf[Seq[Double]])
    {
      numbers match
      {
        case a: Seq[Double] => println("numbers IS a Seq[Double] data type.")
        case _              => println("numbers is NOT a Seq[Double] data type.")
      }
    }
    println(numbers)
    numbers.sum / numbers.length // Return the average of all numbers passed to this function.
  }

  def printScore(score:Double, msg:String):Unit =
  {
    if   (score.isNaN) println("The score is not a number.")
    else println(msg + score) // PRINTS: averageScore = 4.56
  }
}

============================================================================

object Demo {
  def main(args: Array[String]) {
    {
      val fruits: List[String] = List("apple", "banana", "blueberry", "cherry")

      // The following 5 calls to the printAll() function shows that
      // printAll() can accept a variable number of arguments.
      printAll() // PRINTS: nothing (no text)
      printAll("ONE") // PRINTS: ONE
      printAll("ONE", "TWO") // PRINTS: ONE
                             //         TWO
      printAll("ONE", "TWO", "THREE") // PRINTS: ONE
                                      //         TWO
                                      //         THREE

      // The _* in the following call to printAll() transforms
      // the List "fruits" into 4 SEPARATE STRINGS.
      printAll(fruits: _*) // PRINTS: apple
                           //         banana
                           //         blueberry
                           //         cherry
      printAll(fruits.toString()) // PRINTS: List(apple, banana, blueberry, cherry)
      println(fruits.flatten)     // PRINTS: List(a, p, p, l, e, b, a, n, a, n, a, b, l, u, e, b, e, r, r, y, c, h, e, r, r, y)
    }

    /**
     * @param strs - A variable number of strings can get passed to this printAll() function.
     */
    def printAll(strs: String*) // The asterisk char (*) designates possible MULTIPLE ARGUMENTS.
    {
      strs.foreach(println)
    }
  }
}
