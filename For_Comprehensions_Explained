================================================================================
A Scala for comprehension can contain the following 3 expressions:
1) Generator.  Every for comprehension begins with a generator.  for compehensions
               can have multiple generators.  The left side of a generator can
               also be a pattern, such as the example on the following line.  Where
               getAnimals() is a function that rerurns a 3-element tuple, and
               getTheSquirrel() is the defined function which yields the squirrel...
               def getTheSquirrel = for { (dog, cat, squirrel) <- getAnimals yield squirrel }

2) Definition.  A definition binds the pattern on the left to the value of the expression on the right.
3) Filter.      A filter drops all elements from the iteration for which the expression returns false.
                For example.  For this filter...
                if (name startsWith "To")
                ...any value for name that does NOT start with the string "To" is dropped from the result.

Here is an example:
for
{
  p <- persons           // Generator  (Iterates over all elements contained in persons.)
  n = p.name             // Definition (Equivalent to: val n = p.name)
  if (n startsWith "To") // Filter     (Any value n that does NOT start with the String "To" is dropped.)
} yield x                // The for comprehension result is stored in x.

A generator has this general form:   pattern <- expression
A definition has this general form:  pattern = expression
A filter has this general form:      if (expression)

The Scala compiler translates for comprehensions into
a series of method calls that may include...

map()
flatMap()
foreach()
withFilter()

Just as for comprehensions are compiled into those 4 functions, the
opposite is also true.  If you write a class that implements these
4 functions, that class can be used inside a for comprehension.

HOW TO WRITE A DATA TYPE THAT CAN BE USED IN A FOR COMPREHENSION
================================================================
1) If a custom data type defines a foreach() method, it allows
   for loops (with single and multiple generators) like this:
   for (x <- intList) println(x)
2) If a custom data type defines ONLY map(), it can be used in
   for expressions consisting of a SINGLE generator.
3) If a custom data type defines BOTH flatMap() and map(),
   it allows for expressions using multiple generators.
4) If a custom data type defines withFilter(), it allows
   for expressions containing an if() statement (aka, a filter).

If you want your custom class to work well with a for expression,
it should generally implement the 4 methods shown in the following
MyCustomClass, with the method signatures shown below.

abstract class MyCustomClass[A]
{
  def map[B](func: A => B):                    MyCustomClass[B]
  def flatMap[B](func: A => MyCustomClass[B]): MyCustomClass[B]
  def withFilter(x: A => Boolean):             MyCustomClass[A]
  def foreach((x: A => Unit):                  Unit
}
The following code sample implements a Sequence class that has implemented
these four (4) methods.

================================================================================
import scala.collection.mutable.ArrayBuffer
object Demo
{
  case class Person(firstName:String, lastName:String)
  case class Sequence[A](private val initialElems: A*)
  {
    private val elems = ArrayBuffer[A]()
    elems ++= initialElems // NOTE: ArrayBuffer is a MUTABLE type so the contents of elems can change.

    def flatMap[B](func: A => Sequence[B]):Sequence[B] =
    {
      val mapRes:Sequence[Sequence[B]] = map(func)
      flattenLike(mapRes)
    }

    private def flattenLike[B](seqOfSeq:Sequence[Sequence[B]]):Sequence[B] =
    {
      var xs:ArrayBuffer[B] = ArrayBuffer[B]()
      for (listB:Sequence[B] <- seqOfSeq)
      {
        for (elem <- listB) { xs += elem }
      }
      Sequence(xs: _*)
    }

    def withFilter(func: A => Boolean) =
    {
      val tmpArrayBuffer = elems.filter(func)
      Sequence(tmpArrayBuffer: _*)
    }

    def map[B](func: A=>B):Sequence[B] =
    {
      val arrayBuf:ArrayBuffer[B] = elems.map(func)
      Sequence(arrayBuf: _*)
    }

    def foreach(block: A => Unit):Unit = { elems.foreach(block) }
  }

  def main(args:Array[String]): Unit =
  {
    // The following code REQUIRES the flatMap() method to be defined by the above case class named Sequence.
    val myFriends   = Sequence(Person("Jack",   "Daniels"),  Person("Johnny", "Walker"), Person("Jim", "Beam"))
    val joesFriends = Sequence(Person("Joseph", "Schlitz"),  Person("George", "Jones"),  Person("Jim", "Beam"))

    // For a class to work with MULTIPLE for() loop generators (as shown here), that class
    // MUST implement a flatMap() method--as in the above-defined Sequence class.
    val mutualFriends = for
                        {
                          myFriend   <- myFriends   // This is a GENERATOR.
                          joesFriend <- joesFriends // This is another GENERATOR.
                          if (myFriend.firstName == joesFriend.firstName &&
                              myFriend.lastName  == joesFriend.lastName)
                        } yield myFriend
    println("mutualFriends = " + mutualFriends) // PRINTS: mutualFriends = Sequence(ArrayBuffer(Person(Jim,Beam)))
  }
}
