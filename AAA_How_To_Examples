The following sample code shows how to obtain:

1) Environment Variables
2) System Properties

import scala.collection.JavaConverters._
object Demo
{
  /********************************************
   * main() function
   ********************************************/
  def main(args: Array[String])
  {
    println("\n================================================")
    println("PRINT ALL ENVIRONMENT VALUES:")
    var envVars = System.getenv().asScala
    for ((k,v) <- envVars) { println(s"key = $k\nvalue = $v\n") }
    println("================================================")

    println("PRINT ALL SYSTEM PROPERTIES:\n")
    var sysProps = System.getProperties().asScala
    for ((k,v) <- sysProps) { println(s"key = $k\nvalue = $v\n") }
    println("================================================")

    // Obtain a single environment value...
    println("\nUSER = " + envVars.get("USER")) // PRINTS: USER = Some(tjb)

    // Obtain a single system property...
    println("java.version = " + sysProps.get("java.version")) // PRINTS: java.version = Some(11.0.13)
  }
}

===========================================================================
The following sample program demonstrates how to do the following:

1) How to obtain the Scala version being used.
2) How to execute a Linux script file from a Scala program.

import java.io.{File, PrintWriter}
import scala.collection.mutable.ArrayBuffer
import scala.sys.{SystemProperties, exit}
import sys.process._
import scala.util.Properties._

object Demo
{
  type StringTuple = (String, String)

  def main(args: Array[String]): Unit =
  {
    // The following 2 lines of code print the Scala version being used:
    println(versionNumberString) // PRINTS: 2.12.14
    println(versionString)       // PRINTS: version 2.12.14

    val osName:String = sys.props("os.name").toLowerCase
    if (false == osName.contains("linux"))
    {
      println("FAIL - Operating system is not Linux.")
      return
    }
    val tempDir = getTempDirectory()
    if (tempDir == None)
    {
      println("FAIL - Temporary directory not found.")
      return
    }
    println("====================================")

    // Create a linux script file in the temporary directory.
    val scriptFilename:String = tempDir + "/" + "linuxScriptTester.sh"
    val scriptFile = new File(scriptFilename)

    // Write linux command(s) to the script file.
    val pw = new PrintWriter(scriptFile)
    pw.print("ls -la /home/tjb\n")
    scriptFile.setExecutable(true) // Sets the file's Linux user permission to executable.
    pw.flush()
    pw.close()

    // Generate the "command" that'll execute the linux script file.
    var command:Seq[String] = Seq(scriptFilename)

    // Execute the linux script file...
    // NOTE: Calling command.! executes the linuxScriptTester.sh file, sending its output to the terminal.
    //       The following line is commented out because we DON'T want that behavior in this program.
    // command!
    //
    // Calling command.!! executes the Linux linuxScriptTester.sh file, and returns the result as a String.
    val filesInfo:String = command.!!
    scriptFile.delete // Delete the linux script file.

    // Obtain the filenames from the "ls -la" command in the linuxScriptTester.sh file.
    val fileNames:Array[String] = getMp3WavFilenames(filesInfo)

    // *******************************************************************
    // This section used ONLY for debugging.
    // println(fileNames.mkString)
    for (x <- fileNames)
    {
      println(x)
    }
    println("====================================")
    val result = transformFilenames(fileNames)
    for (x <- result)
    {
      println(s"origFilename = ${x._1},  transformedFilename = ${x._2}")
    }
    // *******************************************************************
  }

  /**
   * Read in-line comments for details.
   */
  def getMp3WavFilenames(filesInfo:String):Array[String] =
  {
    // NOTE: The following commented-out block of code could replace all the below
    //       code in this function!  But that's drinking from the firehose, so the
    //       current code will stand for now.
    //  (for (x <- filesInfo.split("\n").drop(3).filter(x => x.startsWith("-"))) yield ((x.substring(44))))
    //   .filter(x => !x.startsWith("."))
    //   .filter(x => (x.toLowerCase.endsWith(".mp3") || x.toLowerCase.endsWith(".wav")))

    var tempArray:Array[String] = filesInfo.split("\n")
    // The first 3 lines returned by "ls -la" aren't filenames, so drop them.
    tempArray.drop(3)
    // The first char of every file returned by "ls -la" designates the file type.
    // If that first char is a "-" it designates a regular file--not a directory
    // file, not a network file, etc.  Obtain only regular file names.
    tempArray = tempArray.filter(x => x.startsWith("-"))
    // For each file returned by "ls -la", strip all leading chars to obtain only the filenames.
    tempArray = for (x <- tempArray) yield ((x.substring(44)))
    // Remove all invisible files, which have filenames beginning with the period "." char.
    tempArray = tempArray.filter(x => !x.startsWith("."))
    // Obtain ONLY filenames ending with ".mp3" or ".wav".
    tempArray = tempArray.filter(x => (x.toLowerCase.endsWith(".mp3") || x.toLowerCase.endsWith(".wav")))
    tempArray
  }

  /**
   * Read in-line comments for details.
   */
  def transformFilenames(filenameArray:Array[String]): ArrayBuffer[StringTuple] =
  {
    // Declare an empty ArrayBuffer, which gets populated
    // further below, and is returned by this method.
    val result:ArrayBuffer[StringTuple] = ArrayBuffer()

    for (origFilename <- filenameArray)
    {
      // Replace whitespace chars in the filename with underscore ('_') chars.
      val str:String = origFilename.replace(" ", "_").replace("\t", "_")

      var prevChar:Char = 0.toChar // MUST initialize to a char that CAN'T exist in a valid filename.
      val trav:Traversable[Char] = str.toTraversable // Obtain a traversable for the str String.
      val strBuild = StringBuilder.newBuilder // Declare a StringBuilder to construct a new string.

      // The following trav.foreach{} function loops through each char in the str traversable,
      // where x references the current char.
      trav.foreach {
        // Change the filename's chars to uppercase or lowercase based on this criteria:
        // 1) The first char of the filename will be set to uppercase.  If the filename's first
        //    char is '_', setting it to uppercase will have no effect, and won't matter.
        // 2) All chars preceded with the '_' char will be set to uppercase.
        // 3) All remaining chars will be set to lowercase.
        x => val myChar = if (prevChar == 0 || (prevChar == '_' && x.toChar != '_'))
                            x.toChar.toUpper
                          else
                            x.toChar.toLower

        // The following if() statement will transform multiple consecutive '_' chars
        // into a single '_' char.  Ensuring that the filename will never contain more
        // more than one consecutive '_' char.
        if (myChar != '_'  ||  (myChar == '_'  &&  prevChar != '_'))
          strBuild.append(myChar)
        prevChar = myChar
      }
      result += new StringTuple(origFilename, strBuild.toString())
    }
    result
  }

  /**
   * Obtains and returns the Linux temporary directory path as a String.
   */
  def getTempDirectory():String =
  {
    val sysProps:SystemProperties = new SystemProperties()
    val tempDir:Option[String] = sysProps.get("java.io.tmpdir")
    if (tempDir == None) "" else tempDir.get.toString
  }
}
===========================================================================
