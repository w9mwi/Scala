The following sample code shows how to obtain:

1) Environment Variables
2) System Properties

import scala.collection.JavaConverters._
object Demo
{
  /********************************************
   * main() function
   ********************************************/
  def main(args: Array[String])
  {
    println("\n================================================")
    println("PRINT ALL ENVIRONMENT VALUES:")
    var envVars = System.getenv().asScala
    for ((k,v) <- envVars) { println(s"key = $k\nvalue = $v\n") }
    println("================================================")

    println("PRINT ALL SYSTEM PROPERTIES:\n")
    var sysProps = System.getProperties().asScala
    for ((k,v) <- sysProps) { println(s"key = $k\nvalue = $v\n") }
    println("================================================")

    // Obtain a single environment value...
    println("\nUSER = " + envVars.get("USER")) // PRINTS: USER = Some(tjb)

    // Obtain a single system property...
    println("java.version = " + sysProps.get("java.version")) // PRINTS: java.version = Some(11.0.13)
  }
}

===========================================================================
The following sample program demonstrates how to do the following:

1) How to obtain the Scala version being used.
2) How to execute a Linux script file from a Scala program.


import java.io.{File, PrintWriter}
import java.nio.file.{Files, Path, Paths, StandardCopyOption}
import scala.collection.mutable.ArrayBuffer
import scala.sys.{SystemProperties}
import sys.process._
import scala.util.Properties._

object Demo
{
  type StringTuple = (String, String)

  def main(args: Array[String]): Unit =
  {
    // The following 2 lines of code print the Scala version being used:
    println(versionNumberString) // PRINTS: 2.12.14
    println(versionString)       // PRINTS: version 2.12.14

    val osName:String = sys.props("os.name").toLowerCase
    if (false == osName.contains("linux"))
    {
      println("FAIL - Operating system is not Linux.")
      return
    }
    val tempDir:String = getTempDirectory()
    if (tempDir == None)
    {
      println("FAIL - Temporary directory not found.")
      return
    }
    println("====================================")

    // Create a linux script file in the temporary directory.
    val scriptFilename:String = tempDir + "/" + "linuxScriptTester.sh"
    val scriptFile:File = new File(scriptFilename)
    val dirPath:String = "/home/tjb/junkDir/"

    // Write linux command(s) to the script file.
    val pw:PrintWriter = new PrintWriter(scriptFile)
    pw.print("ls -la " + dirPath + "\n")
    scriptFile.setExecutable(true) // Sets the file's Linux user permission to executable.
    pw.flush()
    pw.close()

    // Generate the "command" that'll execute the linux script file.
    var command:Seq[String] = Seq(scriptFilename)

    // Execute the linux script file...
    // NOTE: Calling command.! executes the linuxScriptTester.sh file, sending its output to the terminal.
    //       The following line is commented out because we DON'T want that behavior in this program.
    // command!
    //
    // Calling command.!! executes the Linux linuxScriptTester.sh file, and returns the result as a String.
    val filesInfo:String = command.!!
    scriptFile.delete // Delete the linux script file.

    // Obtain the filenames from the "ls -la" command in the linuxScriptTester.sh file.
    val fileNames:Array[String] = getMp3WavFilenames(filesInfo)
    val origAndNewFilenames:ArrayBuffer[StringTuple] = transformFilenames(fileNames)
    renameFiles(dirPath, origAndNewFilenames)
  }

  /**
   * Read in-line comments for details.
   */
  def getMp3WavFilenames(filesInfo:String):Array[String] =
  {
    // Each element of varArray will contain each row of text returned by the "ls -la" command.
    var varArray:Array[String] = filesInfo.split("\n")
    val filenameIndex:Int = getFilenameIndex(varArray)

    // *****************************************************************************
    // NOTE: This block of commented-out code could replace all the below code in
    //       this function!  But that's like drinking from a firehose, so the
    //       current code will stand for now.
    //  (for (x <- filesInfo.split("\n").drop(3).filter(x => x.startsWith("-")))
    //  yield (if (x.indexOf("'") > -1) x.substring(filenameIndex - 1) else x.substring(filenameIndex)))
    //  .filter(x => !x.startsWith("."))
    //  .filter(x => (x.toLowerCase.endsWith(".mp3") || x.toLowerCase.endsWith(".wav")))
    // *****************************************************************************

    // The first 3 lines returned by "ls -la" aren't real filenames, so drop them.
    varArray.drop(3)
    // The first char of every file returned by "ls -la" designates the file type.
    // If that first char is a "-" it designates a regular file--not a directory
    // file, not a network file, etc.  Obtain only regular file names.
    varArray = varArray.filter(x => x.startsWith("-"))
    // For each file returned by "ls -la", strip all leading chars to obtain only the filenames.
    // varArray = for (x <- varArray) yield (x.substring(filenameIndex))
    varArray = for (x <- varArray) yield (if (x.indexOf("'") > -1) x.substring(filenameIndex - 1) else x.substring(filenameIndex))
    // Remove all invisible files, which have filenames beginning with the period "." char.
    varArray = varArray.filter(x => !x.startsWith("."))
    // Obtain ONLY filenames ending with ".mp3" or ".wav".
    varArray = varArray.filter(x => (x.toLowerCase.endsWith(".mp3") || x.toLowerCase.endsWith(".wav")))
    varArray
  }

  /**
   * Read in-line comments for details.
   */
  def transformFilenames(filenameArray:Array[String]): ArrayBuffer[StringTuple] =
  {
    // Declare an empty ArrayBuffer, which gets populated
    // further below, and is returned by this method.
    val result:ArrayBuffer[StringTuple] = ArrayBuffer()
    val ZERO:Int = 0

    for (origFilename <- filenameArray)
    {
      var prevChar:Char = ZERO.toChar // MUST initialize to a char that CAN'T exist in a valid filename.
      // Replace whitespace chars in the filename with underscore ('_') chars...
      val str:String = origFilename.replace(" ", "_").replace("\t", "_")
      // Obtain a traversable for str, which allows it to be traversed without using a var.
      val trav:Traversable[Char] = str.toTraversable
      // Declare a StringBuilder, which is mutable, allowing a new String to be built in one swoop.
      val strBuild = StringBuilder.newBuilder

      // The following trav.foreach{} function loops through each char in the str traversable,
      // where x references the current char.
      trav.foreach {
        // Change the filename's chars to uppercase or lowercase based on this criteria:
        // 1) The first char of the filename is always set to uppercase.  If the filename's
        //    first char is '_', setting it to uppercase will have no effect, and won't matter.
        // 2) All chars preceded with the '_' char will be set to uppercase.
        // 3) All remaining chars will be set to lowercase.
        x => val myChar = if (prevChar == ZERO || (prevChar == '_' && x.toChar != '_'))
                            x.toChar.toUpper
                          else
                            x.toChar.toLower
          // The following if() statement will transform multiple consecutive '_' chars
          // into a single '_' char.  Ensuring that the filename will never contain more
          // more than one consecutive '_' char.
          if (myChar != '_'  ||  (myChar == '_'  &&  prevChar != '_'))
            strBuild.append(myChar)
          prevChar = myChar
      }
      result += new StringTuple(origFilename, strBuild.toString())
    }
    result
  }

  /**
   * Obtains and returns the Linux temporary directory path as a String.
   */
  def getTempDirectory():String =
  {
    val sysProps:SystemProperties = new SystemProperties()
    val tempDir:Option[String] = sysProps.get("java.io.tmpdir")
    if (tempDir == None) "" else tempDir.get.toString
  }

  /**
   * @param dirPath - String containing the directory path where the files exist.
   * @param origAndNewFilenames - Each element of this ArrayBuffer is a tuple of
   *                              type (String, String), which contains BOTH
   *                              the original filename and the new filename.
   */
  def renameFiles(dirPath:String, origAndNewFilenames:ArrayBuffer[StringTuple]):Unit =
  {
    for (x <- origAndNewFilenames)
    {
      // The following println() is for DEBUGGING.
      println(s"BEFORE=${x._1}\nAFTER =${x._2}\n")
      // NOTE: Both the Files and Path classes are Java classes.
      val path:Path = Files.move(Paths.get(dirPath + x._1),  // x._1 is the original filename.
                                 Paths.get(dirPath + x._2),  // x._2 is the new filename.
                                 StandardCopyOption.REPLACE_EXISTING)
    }
  }

  /**
   * The filenames Array argument passed to this method contains all text returned
   * by the Linux "ls -la" command.  Each Array element of filenames contains
   * a single row of that text.  The filenames(1) element will ALWAYS contain
   * the filename "./" as shown below, which is the file we use to determine
   * the location (index) of all filenames in the filenames Array.
   * WARNING: If a filename contains whitespace (like shown in the text below),
   *          it's surrounded by single quote (') chars.  When that occurs
   *          we know the filename index is ONE LESS than the returned value.
   *
   * total 588
   * drwxr-xr-x 28 tjb  tjb    4096 Sep 29 15:11  ./
   * drwxr-xr-x  3 root root   4096 Dec 17  2021  ../
   * -rw-rw-r--  1 tjb  tjb       0 Sep 29 15:11  aaa.txt
   * -rw-rw-r--  1 tjb  tjb       0 Sep 29 15:05 '     ABC    XYZ    .mp3'
   * drwxrwxr-x  2 tjb  tjb    4096 Dec 18  2021  .android/
   */
  def getFilenameIndex(filenames:Array[String]):Int =
  {
    filenames(1).indexOf(".")
  }
}
===========================================================================
