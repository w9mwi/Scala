Like most other Scala collections, a Map can be mutable or immutable.
By default, Maps are immutable, which means you don't need to specify
an import statement for Map.  Use the following import statements
accordingly...

import scala.collection.immutable.Map
import scala.collection.mutable.Map
import scala.collection.{immutable, mutable}

The term Map has its origins in mathematics.  A mapping in mathematics is something that
takes values from one set and returns values from another set.  A function in mathematics
is technically a mapping.  The Scala Map collection type is very similar to that definition,
in that it maps from a "key" to a "value."  For example a key could be a zip code that's
of type Int, and the value would be "city, state" of type String.

A Map can multiple elements where the key->value pairs in each element are
of different types.  For example, the following val myMap has as its first
element an Int->String key->value pair.  Its second element a String->Int
key->value pair.  And its third element a Double->Float key->value pair.

val myMap = Map(1 -> "one", "two" -> 2, 123.4D -> 567.8F)
println(myMap) // PRINTS: Map(1 -> one, two -> 2, 123.4 -> 567.8)
==========================================================================================
import scala.collection.{immutable, mutable}

object Demo
{
  def main(args: Array[String])
  {
    var immutMap:immutable.Map[Int, String] = Map(1 -> "one", 2 -> "two", 3 -> "three", 4 -> "four", 5 -> "five")
    // NOTE: When iterating through all elements of a Map, the order of its elements
    //       may be different than the order of when the Map was constructed.
    println("A) " + immutMap) // PRINTS:  A) Map(5 -> five, 1 -> one, 2 -> two, 3 -> three, 4 -> four)

    // NOTE: A Map's key can be of any type, and a Map's value can be of any type!
    //       Here's how to obtain a Map's value from its key.  (key = 3, value = "three")
    println("B) immutMap(3) = "       + immutMap(3))       // PRINTS: B) immutMap(3) = three
    println("C) immutMap.apply(3) = " + immutMap.apply(3)) // PRINTS: C) immutMap.apply(3) = three

    // To add a Map element to an existing Map, do the following...
    immutMap += (6 -> "six")
    println("D) " + immutMap) // PRINTS: D) Map(5 -> five, 1 -> one, 6 -> six, 2 -> two, 3 -> three, 4 -> four)

    // To remove a Map element from an existing Map, use the key after the - or -= operator.
    // So the following line of code removes the (6 -> "six") element...
    immutMap -= 6
    println("E) " + immutMap) // PRINTS: E) Map(5 -> five, 1 -> one, 2 -> two, 3 -> three, 4 -> four)

    // If you try to remove a Map element that doesn't exist in the Map, nothing will happen.
    // Example: Here, we try removing the Map element having a key of 99, which doesn't exist...
    immutMap -= 99
    println("F) " + immutMap + "\n") // PRINTS: E) Map(5 -> five, 1 -> one, 2 -> two, 3 -> three, 4 -> four)

    // The following 2 lines of code print identical results--all the elements contained in immutMap.
    immutMap.foreach(print); println     // PRINTS: (5,five)(1,one)(2,two)(3,three)(4,four)
    for (map <- immutMap) { print(map) } // PRINTS: (5,five)(1,one)(2,two)(3,three)(4,four)

    // To use a mutable Map, declare it by specifying the mutable.Map type like this...
    var mutMap:mutable.Map[String, Int] = mutable.Map("one" -> 1, "two" -> 2, "three" -> 3)
    println("\n\nG) " + mutMap)

    // Obtain all elements from mutMap that are NOT the ("three" -> 3) pair.
    // NOTE: In the following line of code, replacing ("three" -> 3) with ("three", 3)
    //       obtains the identical results...
    mutMap = mutMap.filterNot(x => x == ("three" -> 3))
    println("H) " + mutMap) // PRINTS: H) Map(one -> 1, two -> 2)
  }
}
==========================================================================================
