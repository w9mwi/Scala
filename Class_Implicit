NOTE:  This section ignores "implicit" parameters.  For details about
       implicit parameters, see the section titled:  Implicit_Parameters

       "implicit" is a Scala keyword.   the "implicit" keyword
       can be used in conjunction with a class, an object,
       or a function, like this...

       1) implicit class  someClass(str: String){ ... }
       2) implicit object someObject(str: String){ ... }
       3) implicit def    someFunction(str: String){ ... }

       If the "implicit" keyword is used in a function definition,
       the function MUST return a class, an object, or a trait, which
       then makes the returned object, class or trait implicit.  The
       "implicit" keyword can also be used on a val/var declaration
       if the val/var is assigned a class, an object, or a trait.

The following code sample shows how to use implicit class.
Using an implicit class, you can add new functions to an
existing Scala class.  In this example we add the decrement()
and increment() functions to the String class, which
already exists in Scala.

In the following example, we create a var named 'state'
of type String.  Now, when you type the text 'state.' in
your IDE, and then press "Ctrl + space bar", the 'increment'
and 'decrement' functions THAT YOU DEFINED will appear in
the IDE's dropdown menu, so you can select them.  This shows
the functions you defined are now avaliable for the Scala
String type.

For this to work, your implicit class must have a single parameter
(that matches the type of an existing Scala type), and your new
function name(s) must be different than function names that already
exist for that type.

NOTICE: The two (2) sample programs below have identical behavior.
        The first sample shows the 'implicit' keyword being used
        ONLY on a class definition.  The second sample shows the
        'implicit' keyword being used ONLY on a function definition.

====================================================================

This is the same sample program as shown further below, except
a class is defined as implicit instead of a function.

object Demo
{
  // Define the EnhancedString class as an implicit class...
  implicit class EnhancedString(str: String)
  {
    // increment or decrement every Char in the String by one.
    def decrement:String = { str.map(ch => (ch - 1).toChar) }
    def increment:String = { str.map(ch => (ch + 1).toChar) }
  }

  def main(args: Array[String]): Unit =
  {
    var state:String = "Wisconsin"

    state = state.increment
    println(state) // PRINTS: Xjtdpotjo
    state = state.decrement
    println(state) // PRINTS: Wisconsin
    state = state.decrement
    println(state) // PRINTS: Vhrbnmrhm
  }
}

====================================================================

This is the same sample program as shown above, except we define
an implicit function, instead of an implicit class.  Since the
implicit function defined below returns an EnhancedString class,
an implicit class is what's actually being defined.

object Demo
{
  class EnhancedString(str: String)
  {
    // increment or decrement every Char in the String by one.
    def decrement:String = { str.map(ch => (ch - 1).toChar) }
    def increment:String = { str.map(ch => (ch + 1).toChar) }
  }

  // NOTE: This function returns the EnhancedString class, and its
  //       definition must include the "implicit" keyword.  This
  //       function can be given ANY NAME, except for function names
  //       that already exist on the String class (i.e., compare, split,
  //       toInt, etc.).  If this implicit function isn't defined,
  //       this program won't compile, even though this code never
  //       explicitly calls this function directly by name.  This
  //       function gets called implicitly.
  implicit def stupidDumbFuncName(str: String):EnhancedString =
  {
    new EnhancedString(str)
  }

  def main(args: Array[String]): Unit =
  {
    var state:String = "Wisconsin"

    state = state.increment
    println(state) // PRINTS: Xjtdpotjo
    state = state.decrement
    println(state) // PRINTS: Wisconsin
    state = state.decrement
    println(state) // PRINTS: Vhrbnmrhm
  }
}

===============================================================

The following code sample is similar to the examples above.
Read in-line comments for explanations.

object Demo
{
  sealed trait Animal
  final case class Bird(name:String) extends Animal
  final case class Cat(name:String)  extends Animal
  final case class Dog(name:String)  extends Animal

  // The [A] represents any type of defined Animal.
  // In this program it would be Bird, Cat, or Dog.
  trait BehavesLikeHuman[A]
  {
    // This method is undefined here.  It must be defined
    // in the code that declares a BehavesLikeHuman type.
    def speak(animalType:A):Unit
  }

  /****************************
   * main()
   ***************************/
  def main(args: Array[String]): Unit =
  {
    // Here is where the BehavesLikeHuman.speak() method gets defined for a Dog type.
    // NOTE: This code works with or without the 'implicit' keyword preceding the 'val' keyword.
    implicit val dogBehavesLikeHuman:BehavesLikeHuman[Dog] = new BehavesLikeHuman[Dog]
    {
      def speak(dog:Dog):Unit =
      {
        println(s"I am a dog, and my name is ${dog.name}.")
      }
    }

    // Here is where the BehavesLikeHuman.speak() method gets defined for a Cat type.
    // NOTE: This code works with or without the 'implicit' keyword preceding the 'val' keyword.
    val catBehavesLikeHuman:BehavesLikeHuman[Cat] = new BehavesLikeHuman[Cat]
    {
      def speak(cat:Cat):Unit =
      {
        println(s"I am a cat, and my name is ${cat.name}.")
      }
    }

    val myDog:Dog = Dog("Stoner")
    dogBehavesLikeHuman.speak(myDog) // PRINTS: I am a dog, and my name is Stoner.

    val myCat:Cat = Cat("Drunkie")
    catBehavesLikeHuman.speak(myCat) // PRINTS: I am a cat, and my name is Drunkie.
  }
}
