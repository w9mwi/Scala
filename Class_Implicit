NOTE:  "implicit" is a Scala keyword.  The "implicit" keyword
       can be used in conjunction with a class, an object, or
       a function, like this...
       
       1) implicit class  someClass(str: String){ ... }
       2) implicit object someObject(str: String){ ... }
       3) implicit def    someFunction(str: String){ ... }

The following code sample shows how to use implicit class.
Using an implicit class, you can add new functions to an
existing Scala class.  In this example we add the decrement()
and increment() functions to the String class, which
already exists in Scala.

In the following example, we create a var named 'state'
of type String.  Now, when you type the text 'state.' in
your IDE, and then press "Ctrl + space bar", the 'increment'
and 'decrement' functions THAT YOU DEFINED will appear in
the IDE's dropdown menu, so you can select them.  This shows
the functions you defined are now avaliable for the Scala
String type.

For this to work, your implicit class must have a single parameter
(that matches the type of an existing Scala type), and your new
function name(s) must be different than function names that already
exist for that type.

NOTICE: The two (2) sample programs below have identical behavior.
        The first sample shows the 'implicit' keyword being used
        ONLY on a class definition.  The second sample shows the
        'implicit' keyword being used ONLY on a function definition.

====================================================================
This is the same sample program as shown further below, except
a class is defined as implicit instead of a function.

object Demo
{
  // Define the EnhancedString class as an implicit class...
  implicit class EnhancedString(str: String)
  {
    // increment or decrement every Char in the String by one.
    def decrement:String = { str.map(ch => (ch - 1).toChar) }
    def increment:String = { str.map(ch => (ch + 1).toChar) }
  }

  def main(args: Array[String]): Unit =
  {
    var state:String = "Wisconsin"

    state = state.increment
    println(state) // PRINTS: Xjtdpotjo
    state = state.decrement
    println(state) // PRINTS: Wisconsin
    state = state.decrement
    println(state) // PRINTS: Vhrbnmrhm
  }
}

====================================================================
This is the same sample program as shown above, except we
define an implicit function, instead of an implicit class.

object Demo
{
  class EnhancedString(str: String)
  {
    // increment or decrement every Char in the String by one.
    def decrement:String = { str.map(ch => (ch - 1).toChar) }
    def increment:String = { str.map(ch => (ch + 1).toChar) }
  }

  // NOTE: This function returns the EnhancedString class, and its
  //       definition must include the "implicit" keyword.  This
  //       function can be given ANY NAME, except for function names
  //       that already exist on the String class (i.e., compare, split,
  //       toInt, etc.).  If this implicit function isn't defined,
  //       this program won't compile, even though this code never
  //       explicitly calls this function directly by name.  This
  //       function gets called implicitly.
  implicit def stupidDumbFuncName(str: String):EnhancedString = new EnhancedString(str)

  def main(args: Array[String]): Unit =
  {
    var state:String = "Wisconsin"

    state = state.increment
    println(state) // PRINTS: Xjtdpotjo
    state = state.decrement
    println(state) // PRINTS: Wisconsin
    state = state.decrement
    println(state) // PRINTS: Vhrbnmrhm
  }
}
