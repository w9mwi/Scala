
The following example shows how to read a text file, and print its contents to the screen.
==========================================================================================

import java.io.FileNotFoundException
import scala.io.{BufferedSource, Source}

object Demo
{
  def main(args: Array[String]): Unit =
  {
    try
    {
      // NOTE: For this program to work, create a ch8.txt file as shown on the next line.
      val filePathAndName:String = "/home/tbouril/ch8.txt"
      var fileSource:BufferedSource = Source.fromFile(filePathAndName)

      // The following line of code prints to the console the entire contents
      // of filePathAndName, exactly as it'd appear in a text editor.
      println("1) fileSource.mkString = \n" + fileSource.mkString)

      // The following line of code PRINTS NOTHING to the console because
      // the file iterator has been "spent."
      println("2) fileSource.mkString = \n" + fileSource.mkString)

      // Reinitialize fileSource so its iterator gets reset...
      fileSource = Source.fromFile(filePathAndName)

      // The type Source extends Iterator[Char], and BufferedSource extends Source.
      // That means BufferedSource and Source read one Char at a time from the file.
      // Reading Chars one at a time is inefficient--so we can use other Iterator
      // types to read files.  The code BELOW calls getLines(), which returns a type
      // of Iterator[String], which reads one line of text (as a String) at a time.
      val fileContents:Iterator[String] = fileSource.getLines
      println("3) fileContents.foreach(println) = ")
      // The following line of code prints to the console the entire contents
      // of filePathAndName, exactly as it'd appear in a text editor.
      fileContents.foreach(println)

      // The following line of code PRINTS NOTHING to the console because
      // the file iterator has been "spent."
      println("4) fileContents.mkString = " + fileContents.mkString)
      fileSource.close // Close the file because we're done using it.
    }
    catch
      { case fnfe:FileNotFoundException => println("File Not Found, Jack!") }
  }
}

==========================================================================================
The following code shows how to...
1) Read a comma-delimited matrix of numbers stored in a text file.
2) Convert that text matrix into an two-dimensional Array of type Double.

import java.io.FileNotFoundException
import scala.io.Source

object Demo
{
  def main(args: Array[String]): Unit =
  {
    try
    {
      // NOTE: The identityMatrix.txt file referenced below contains the following text.
      //       Where there MUST NOT be any chars after the final 0 char shown below.
      //       1.0, 0.0, 0.0,
      //       0.0, 1.0, 0.0,
      //       0.0, 0.0, 1.0
      val filePathAndName:String = "/home/tbouril/identityMatrix.txt"

      // The following delimiterString (" *, *") means zero or more
      // space chars. (' ') occur BEFORE the comma, AND zero or more
      // space chars. (' ') occur AFTER the comma.
      val delimiterString = " *, *"

      // The following call to fileToDataGrid() initializes the matrix val into
      // a 3X3 two-dimensional Array.  Where each element of matrix corresponds
      // to one of the 9 numbers contained in the identityMatrix.txt file...
      val matrix:Array[Array[Double]] = fileToDataGrid(filePathAndName, delimiterString)

      // PRINT the entire contents of matrix, as shown immediately below...
      printMatrixContents(matrix)
      // matrix(0)(0) = 1.0
      // matrix(0)(1) = 0.0
      // matrix(0)(2) = 0.0
      // matrix(1)(0) = 0.0
      // matrix(1)(1) = 1.0
      // matrix(1)(2) = 0.0
      // matrix(2)(0) = 0.0
      // matrix(2)(1) = 0.0
      // matrix(2)(2) = 1.0
    }
    catch
      { case fnfe:FileNotFoundException => println("File Not Found, Jack!") }
  }

  /**
    *
    */
  def fileToDataGrid(fileName:String, delim:String): Array[Array[Double]] =
  {
    // Initialize strIter so it will contains the following 3 lines of text,
    // obtained from the identityMatrix.txt file.
    // 1.0, 0.0, 0.0,
    // 0.0, 1.0, 0.0,
    // 0.0, 0.0, 1.0
    val strIter:Iterator[String] = Source.fromFile(fileName).getLines()
    dataGrid(strIter, delim)
  }

  /**
    * The lines:Iterator[String] argument passed to this function contains this text:
    * 1.0, 0.0, 0.0,
    * 0.0, 1.0, 0.0,
    * 0.0, 0.0, 1.0
    *
    * This function converts the lines argument (of type Iterator[String]) to an
    * Array[Array[Double]] type by returning the following result...
    * Array(Array(1.0, 0.0, 0.0), Array(0.0, 1.0, 0.0), Array(0.0, 0.0, 1.0))
    */
  def dataGrid(lines:Iterator[String], delim:String): Array[Array[Double]] =
  {
    val result:Array[Array[Double]] = (lines.map(s=>s.split(delim).map(_.toDouble))).toArray
    result
  }

  /**
    * Print to the console the entire contents of the two-dimensional Array
    * matrix passed to this function.
    */
  def printMatrixContents(matrix:Array[Array[Double]]): Unit =
  {
    var rowIndex:Int = 0
    var columnIndex:Int = 0
    for (row <- matrix)
    {
      columnIndex = 0
      for (number <- row)
      {
        println("matrix(" + rowIndex + ")(" + columnIndex + ") = " + number)
        columnIndex += 1
      }
      rowIndex += 1
    }
  }
}

==========================================================================================
import java.io.{File, FileNotFoundException}
import java.util.Scanner

import scala.io.{BufferedSource, Source}

object Demo
{
  def main(args: Array[String]): Unit =
  {
    try
    {
      // NOTE: The identityMatrix.txt file referenced below contains the following text.
      //       Where there MUST NOT be any chars after the final 0 char shown below.
      //       1.0, 0.0, 0.0,
      //       0.0, 1.0, 0.0,
      //       0.0, 0.0, 1.0
      val filePathAndName:String = "/home/tbouril/identityMatrix.txt"

      // Below we use the Java Scanner class to read from the file one "word"
      // at a time, and print it to the console.  Where "word" is any text
      // string separated by the delimiter.  If you don't specify a delimiter
      // (as is done below by calling useDelimiter()), the default delimiter
      // is whitespace (a space char, tab char, etc.).  FYI, calling the
      // Calling the reset() method sets the Scanner to the default delimiter
      // (whitespace).
      val scan:Scanner = new Scanner(new File(filePathAndName))

      // Set the delimiter pattern for the file we're reading.  The following delimiter
      // pattern (" *, *") means that zero or more space chars can occur BEFORE the
      // comma, AND zero or more space chars can occur AFTER the comma.
      scan.useDelimiter(" *, *")

      // The following while() loop prints the contents of scan with
      // a single space char after each number, as is shown below...
      while (scan.hasNext) { print(scan.next() + " ") }
      // PRINTS: 1.0 0.0 0.0
      //         0.0 1.0 0.0
      //         0.0 0.0 1.0

        // The following while() loop prints NOTHING because the scan iterator is "spent."
      while (scan.hasNext) { print(scan.next() + " ")}

      scan.close() // Close the Scanner when done using it.

      // Instead of reading text from a file, the following line of code reads text from
      // a URL.  This text is then converted to a string and printed to the console.
      val yahooText:BufferedSource = Source.fromURL("https://www.yahoo.com/")
      println(yahooText.mkString)

      // The following println PRINTS NOTHING because the yahooText iterator
      // was "spent" in its above call to mkString
      println(yahooText.mkString)
    }
    catch
      { case fnfe:FileNotFoundException => println("File Not Found, Jack!") }
  }
}

==========================================================================================
import java.io.{FileNotFoundException, FileWriter, PrintWriter}
import scala.io.{BufferedSource, Source}

object Demo
{
  def main(args: Array[String]): Unit =
  {
    try
    {
      val filePathAndName:String = "/home/tbouril/output.txt"

      // Create a new file, then write 5 random numbers to it,
      // where each number is followed by a single-space char.
      var pw = new PrintWriter(filePathAndName)
      for (idx <- 1 to 5) { pw.print(math.random + " ") }
      pw.flush(); // flush the PrintWriter before it's used again below.

      // Next, append 5 integers to the existing output.txt file created above.
      // The "true" Boolean parameter below prevents the file from being overwritten
      // if it already exists, so all new data will be APPENDED to existing data.
      pw = new PrintWriter(new FileWriter(filePathAndName, true))
      for (idx <- 1 to 5) { pw.print(idx + " ") }
      pw.flush(); // Always flush the PrintWriter before closing it.
      pw.close(); // Always close the PrintWriter when done using it.

      // Open the output.txt file that was created above,
      // and print its contents to the console window.
      val fileSource:BufferedSource = Source.fromFile(filePathAndName)
      val stringOfNumbers:String = fileSource.mkString.map(replaceChar)
      fileSource.close() // Close the file when done using it.
      println(stringOfNumbers)
      // NOTE: The first 5 numbers printed will be different than the ones shown below, as they're random numbers.
      // PRINTS: 0.648140024571042
      //         0.40746398975208087
      //         0.31017414471515214
      //         0.5752929936068312
      //         0.6250777711271934
      //         1
      //         2
      //         3
      //         4
      //         5

      // NOTE: It may be difficult to understand the replaceChar() function because
      //       in its definition below it appears to not take an argument, and it
      //       appears to return a function.  In reality, replaceChar() is passed
      //       a Char, and returns a Char.  Notice how the replaceChar() function is
      //       passed to the map() function above, and how it's called here...
      val myChar:Char = replaceChar(' ')
      println(myChar) // Prints the newline char ('\n'), which is invisible.
    }
    catch
      { case fnfe:FileNotFoundException => println("File Not Found, Jack!") }

    /**
      * This function gets passed a Char value and returns a Char value.
      * NOTICE the unconventional-looking syntax for this function!!!
      *
      * @return a newline ('\n') Char when passed a space (' ') Char;
      *         otherwise, return the same Char passed to this function.
      */
    def replaceChar:(Char => Char) =
    {
      (myChar:Char) => (if (myChar == ' ') '\n' else myChar)
    }
  }
}

==========================================================================================
import java.io.{FileNotFoundException, PrintWriter}
import scala.io.{BufferedSource, Source}

object Demo
{
  def main(args: Array[String]): Unit =
  {
    try
    {
      val inFile:String  = "/home/tbouril/input.txt"
      val outFile:String = "/home/tbouril/output.txt"

      // The literal function c=>c.toUpper is what's
      // used to convert chars to uppercase.
      mapFile(inFile, outFile, c=>c.toUpper)
    }
    catch
    { case fnfe:FileNotFoundException => println("File Not Found, Jack!") }
  }

  /**
    * This function reads from the inFile, and writes that text to the
    * the outFile as all upper-case chars.
    *
    * @param inFile - An input file that contains text.
    * @param outFile - An output file that contains text copied from the inFile.
    * @param trans - A literal function that converts a char to uppercase.
    */
  def mapFile(inFile:String, outFile:String, trans:Char=>Char): Unit =
  {
    val pw:PrintWriter    = new PrintWriter(outFile)
    val in:BufferedSource = Source.fromFile(inFile)

    // The following for() loop converts each Char read from the
    // inFile to upper case, then writes it to the outFile.
    for (c <- in) { pw.print(if (c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z') trans(c) else c) }
    in.close();  pw.close();
  }
}

==========================================================================================
import scala.io.Source

object Demo
{
  type NameData = (String, Int, String, Int)

  def main(args: Array[String]) =
  {
    // Each line of the WI.TXT file contains comma-delimted String
    // data in this format:  stateAbbreviation, sex, year, name, numberBorn
    // EXAMPLE:  WI,M,1958,Thomas,1445
    val fileName:String = "/home/tbouril/ScalaData/WI.TXT"

    // Initialize an Array[String], where each element of the Array
    // contains a single line of text obtained from the WI.TXT file.
    val nameArray:Array[String]  = Source.fromFile(fileName).getLines().toArray
    val nameData:Array[NameData] = nameArray.map(parseLine)

    // Print the NameData tuple obtained from every element of the nameData Array.
    // nameData.foreach(println)

    println("nameArray contains " + nameArray.length + " lines of text.")

    val sex:String  = "M"
    val year:Int    = 1958
    val name:String = "Thomas"
    val data:Array[NameData] = nameData.filter(nd => nd._1.equalsIgnoreCase(sex)  &&
                                               nd._2 == year  &&
                                               nd._3.equalsIgnoreCase(name))

    // NOTE: Because of the way the WI.TXT file's data is defined, the data
    //       Array should always contain either zero elements, or one element.
    println("data contains " + data.length + " element(s).")
    if (data.length == 1)
    { println("Year = " + year + ", Sex = " + sex + ", Name = " + name + ", Number Born = " + data(0)._4) }
    else
    { println("No data found for Year = " + year + ", Sex = " + sex + ", Name = " + name) }

    val female1959:Array[NameData] = nameData.filter(x => x._1 == "F"  &&  x._2 == 1959)
    var maxNames:Int = female1959.map(_._4).max

    // Print the NameData for the most common female name(s) born in 1959.
    female1959.filter(_._4 == maxNames).foreach(println)

    // Print the NameData for all female names occurring 100 times and born in 1959.
    val rose:Array[NameData] = nameData.filter(x => x._1 == "F"  &&  x._2 == 1959  &&  x._4 == 100)
    rose.foreach(println)
  }

  /**
    * Pass this function a line of text delimited by commas where the line
    * of text has this format: (String, String, Int, String, Int).  Then,
    * return the final 4 values of that String as the type NameData.
    * @param line
    * @return
    */
  def parseLine(line:String): NameData =
  {
    val parts:Array[String] = line.split(",")
    val nd:NameData = (parts(1), parts(2).toInt, parts(3), parts(4).toInt)
    nd // Return the NameData tuple.
  }
}
==========================================================================================
