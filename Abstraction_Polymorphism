Abstraction - You want to write code where some part of what it does is not
              fully specified until it is used.

Polymorphism - This word literally means "many shapes."  And example of polymorphism
               would be to implement a sorting algorithm that could be applied
               to multiple data types, such as Int, String, Float, Double, Char.

               There are 2 types of polymorphism.  UNIVERSAL polymorphism implies the
               code can work with an infinite nuber of types.  AD-HOC polymorphism
               works with only a finite number of types.
               
               UNIVERSAL polymorphism consists of these two different forms...

               1) Inclusion Polymorphism - Is obtained from sub-typing.  In other
                  words, when all elements of one type are also part of another
                  type.  Some examples of this are the Scala types Double, Float,
                  Long, Int, Short, and Byte, which are all subtypes of the type
                  AnyVal.  This is accomplished via inheritance, which is also
                  known as subtyping.  So if class B inherits from class A, class
                  B is a subtype of class A, and class B has access to all data
                  and methods available in class A. However the parent class A does
                  NOT have access to the data and methods defined in class B.

               2) Parametric Polymorphism

=========================================================================================
Any class you define in Scala has its own toString() method that exists by default.
The following sample code shows the default Scala toString() method that gets called
(on our user-defined class named Vect3D_1) returns a string that contains information
that does not give us the info. we really want.  To fix that problem, we defined another
class named Vect3D_2 that overrides the default toString() method, so it prints human-
readable info.

object Demo
{
  class Vect3D_1(val x:Double, val y:Double, val z:Double)

  class Vect3D_2(val x:Double, val y:Double, val z:Double)
  {
    // Override the toString() method, so it prints human-readable information...
    override def toString():String = { "Vect3D_2(" + x +", " + y + ", " + z + ")" }
  }

  def main(args: Array[String]):Unit =
  {
    val myVect_1 = new Vect3D_1(1.2, 2.2, 3.3)
    println("myVect_1 = " + myVect_1.toString) // PRINTS: myVect_1 = Demo$Vect3D_1@16c0663d

    val myVect_2 = new Vect3D_2(1.2, 2.2, 3.3)
    println("myVect_2 = " + myVect_2.toString) // PRINTS: myVect_2 = Vect3D_2(1.2, 2.2, 3.3)
  }
}
=========================================================================================
