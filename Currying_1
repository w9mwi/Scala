SEE THE FOLOWING WEB PAGE FOR MORE INFO. ON CURRYING:
--> http://www.codecommit.com/blog/scala/function-currying-in-scala

The following code sample demonstrates the use of a CURRIED FUNCTION.
A CURRIED FUNCTION is a function that...
1) Gets passed a value and returns a function.
   ...AND...
2) The returned function gets passed a value, and returns a value.

object Demo
{
  def main(args: Array[String])
  {
    // The add_1() function gets the Int 5 value assigned to its x parameter,
    // and returns a function.  The returned function takes an Int value for
    // its y parameter, and returns the Int value (x + y).
    var plus5:(Int => Int) = add_1(5)
    var result:Int         = plus5(6) // The plus5 function gets passed the Int value 6 as its y parameter.
    println("result = " + result) // PRINTS: result = 11

    // The add_2() function gets the Int 5 value assigned to its x parameter,
    // and returns a function.  The returned function takes an Int value for
    // its y parameter, and returns the Int value (x + y).
    plus5  = add_2(5)
    result = plus5(6) // The plus5 function gets passed the Int value 6 as its y parameter.
    println("result = " + result) // PRINTS: result = 11

    // The add_3() function gets the Int 5 value assigned to its x parameter,
    // and returns a function.  The returned function takes an Int value for
    // its y parameter, and returns the Int value (x + y).
    plus5  = add_3(5)
    result = plus5(6) // The plus5 function gets passed the Int value 6 as its y parameter.
    println("result = " + result) // PRINTS: result = 11

    result = add_4(5)(6)
    println("result = " + result) // PRINTS: result = 11

    plus5  = add_4(5)_ // The underscore (_) here is OPTIONAL--it tells Scala you want to specify only the 1st argument.
    result = plus5(6)  // The plus5 function gets passed the Int value 6 as its y parameter.
    println("result = " + result) // PRINTS: result = 11
  }

  // The following 4 functions are identical, they're just written differently.
  // All 4 of these functions get called by passing an Int parameter, and
  // all 4 of them return a function.  Where the function returned gets passed
  // an Int parameter, and returns an Int value.
  def add_1(x:Int):Int => Int   = (y:Int) => x + y
  def add_2(x:Int):(Int => Int) = (y:Int) => x + y
  def add_3(x:Int):(Int => Int) =
  {
    y:Int => x + y
  }
  def add_4(x:Int)(y:Int):Int = x + y
}


================================================================================================

DEFINITION OF A PARTIALLY APPLIED FUNCTION:
A partially-applied function gets passed a function with multiple
parameters, and RETURNS A FUNCTION with fewer parameters.

Partially applied functions give you this capability:

* You write a general function.
* You create a specific function from the general function.

Currying - DEFINITION #1:
           The technique of transforming a function that takes
           multiple arguments into a function that takes a single
           argument, where the other arguments having been specified
           by the curry.

           DEFINITION #2:
           A function that takes multiple arguments can be
           translated into a series of function calls that
           each take a single argument.  Here's an example
           where we curry the following 3-argument function
           into 3 separate functions that each take a single
           argument...

result = f(x)(y)(z)

f1     = f(x)   // f(x)  returns a function that gets assigned to f1.  Therefore, f1 is a function.
f2     = f1(y)  // f1(y) returns a function that gets assigned to f2.  Therefore, f2 is a function.
result = f2(z)  // f2(z) returns a result, which is NOT a function, but some value.

To obtain the final result above, we need to call 3 functions:
1) f(x)  must get called first.
2) f1(y) must get called second.
3) f2(z) must get called last.

Immediately after the f(x) function is called above (and just before
the f1(y) function is called), the f2(z) function is partially applied.
Immediately after the f1(y) function is called (and just before the
f2(z) function is called), the f2(z) function is still partially applied.
Only after the f2(z) function is called (when it returns a result), is
the f2(z) function fully applied.

Since the f2(z) function is built from caling both the f(x) and f1(y) functions,
f(x) and f1(y) are partially-applied functions of function f2(z).
========================================================================
object Demo
{
  def main(args: Array[String])
  {
    // Immediately after sum1(2) gets called, the func1() function is partially applied.
    // After func1(5) gets called, the func1() function is fully applied.
    val func1:(Int => Int) = sum1(2)
    println(func1(5))       // PRINTS: 7  (NOTE: 7 = 2 + 5)
    println(func1.apply(5)) // Equivalent to the previous line of code.

    // Immediately after sum2(2)(42) gets called, the func2() function is partially applied.
    // After func2(13) gets called, the func2() function is fully applied.
    val func2:(Int => Int) = sum2(2)(42)
    println(func2(13))       // PRINTS: 57 (NOTE: 57 = 2 + 42 + 13)
    println(func2.apply(13)) // Equivalent to the previous line of code.
  }

  // NOTE: When the following 2 functions ( sum1() and sum2()() ) are called, they
  //       are only PARTIALLY APPLIED.  sum1() is not fully applied until the
  //       func1() function gets called.  And sum2()() is not fully applied until
  //       the func2() function gets called.
  def sum1(a: Int):(Int => Int)       = { b => a + b }     // b is the value  5 passed from func1(5)
  def sum2(a:Int)(b:Int):(Int => Int) = { c => a + b + c } // c is the value 13 passed from func2(13)
}
========================================================================
object Demo
{
  def main(args: Array[String])
  {
    val result:Int = plus2(11)
    println("result = " + result) // PRINTS: result = 13 (2 + 11 = 13)
  }

  def plus(a:Int)(b:Int):Int = { println("a = " + a + ",  b = " + b);  a + b } // PRINTS: a = 2,  b = 11
  def plus2 = plus(2)(_)  // NOTE: This plus2()() function calls the plus() function defined above.
}
========================================================================
object Demo
{
  def main(args: Array[String])
  {
    val greeting = "This is Scala"
    var result = wrap("<div>")(greeting)("</div>")
    println("result = " + result) // PRINTS: result = <div>This is Scala</div>

    // NOTE: wrapWithDiv is a partially-applied function BEFORE IT GETS CALLED
    //       because it's defined as a function that returns a function.
    //       Therefore, only AFTER wrapWithDiv() gets called is it fully applied.
    result = wrapWithDiv(greeting)
    println("result = " + result) // PRINTS: result = <div>This is Scala</div>
  }

  def wrap(prefix:String)(html:String)(suffix:String):String = { prefix + html + suffix }
  // NOTE: wrapWithDiv is defined by calling the wrap() function and passing
  //       to it the Scala placeholder underscore symbol (_).
  def wrapWithDiv:(String => String) = wrap("<div>")(_)("</div>")
}
========================================================================
object Demo
{
  def main(args: Array[String])
  {
    // The following line of code converts the add() function defined below
    // (which contains one parameter list) into a curried function (which
    // contains two parameter lists) via an "Eta Expansion".  The "Eta
    // Expansion" occurs by adding the underscore character (_) after
    // the "add" method name.  For a more detailed explanation of an
    // "Eta Expansion", read the following web page:
    // --> https://stackoverflow.com/questions/39445018/what-is-the-eta-expansion-in-scala
    val addFunction        = add _
    val addFunctionCurried = addFunction.curried // Converts the addFunction into a curried function.

    println(add(123, 456))                // PRINTS: 579
    println(addFunction(123, 456))        // PRINTS: 579
    println(addFunctionCurried(123)(456)) // PRINTS: 579

    // The following 2 lines of code calls addFunctionCurried twice.
    // When the first line of code calls it, it's PARTIALLY APPLIED.
    // When the second line of code calls it, it's FULLY APPLIED.
    val func:(Int => Int) = addFunctionCurried(123)
    println(func(456)) // PRINTS: 579
  }

  /**
    * The below add() function is a regular Scala function.  In the code
    * above, this add() function is used to create a curried function.
    */
  def add(x:Int, y:Int):Int = { x + y }
}
========================================================================
object Demo
{
  def main(args: Array[String])
  {
    // The add_1() function is a just a standard, normal function.
    // The first time the add_1() is called here, it's called in
    // the usual way....
    println("add_1(7, 3) = " + add_1(7, 3)) // PRINTS: add_1(7, 3) = 10

    // Perform an "Eta Expansion" on add_1(), transforming the "def" function into a true function...
    val addFunc:((Int, Int) => Int) = add_1 _

    val addFuncCurried:(Int => (Int => Int)) = addFunc.curried // Make the add_1() function a curried function.
    println("addFuncCurried(7)(3) = " + addFuncCurried(7)(3)) // PRINTS: addFuncCurried(7)(3) = 10

    // addFuncCurried called with one param returns a PARTIALLY APPLIED function...
    val partiallyAppliedCurried:(Int => Int) = addFuncCurried(7)
    // Call partiallyAppliedCurried to make addFuncCurried FULLY APPLIED...
    println("partiallyAppliedCurried(3) = " + partiallyAppliedCurried(3)) // PRINTS: partiallyAppliedCurried(3) = 10

    // *****************************************************************************************
    // The add_2()() function called below is a curried function,
    // and can be called in the following two (2) ways...
    //
    // 1) Call sum_2()() once by passing to it both Int params, so it
    //    returns an Int result...
    println("add_2(7)(3) = " + add_2(7)(3)) // PRINTS: add_2(7)(3) = 10

    // 2) Call sum_2()() twice...  sum_2()() is called the first time by
    //    initializing its x Int parameter, and it returns a function.
    //    (At this point, the sum_2()() function is PARTIALLY APPLIED)
    //    Then, sum_2()() is called the second time by initializing
    //    its y Int parameter so it will now return an Int value.
    //    (At this point, the sum_2()() function is FULLY APPLIED.)
    val func:(Int => Int) = add_2(7)(_) // The func function is PARTIALLY APPLIED here.
    println("func(3) = " + func(3)) // PRINTS: func(3) = 10  (func is now FULLY APPLIED.)
  }

  /**
    * This add_1() function is a normal function, NOT a curried function.
    */
  def add_1(x:Int, y:Int):Int = { x + y }

  /**
    * This add_2() function is a CURRIED FUNCTION because
    * it takes multiple arguments, and returns a function
    * that takes a single argument.
    */
  def add_2(x:Int) = { (y:Int) => x + y }
}
========================================================================
