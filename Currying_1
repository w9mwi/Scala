DEFINITION OF A PARTIALLY APPLIED FUNCTION:
A partially-applied function gets passed a function with multiple
parameters, and RETURNS A FUNCTION with fewer parameters.

Partially applied functions give you this capability:

* You write a general function.
* You create a specific function from the general function.

Currying - DEFINITION #1:
           The technique of transforming a function that takes
           multiple arguments into a function that takes a single
           argument, where the other arguments having been specified
           by the curry.

           DEFINITION #2:
           A function that takes multiple arguments can be
           translated into a series of function calls that
           each take a single argument.  Here's an example
           where we curry the following 3-argument function
           into 3 separate functions that each take a single
           argument...

result = f(x)(y)(z)

f1     = f(x)   // f(x)  returns a function that gets assigned to f1.  Therefore, f1 is a function.
f2     = f1(y)  // f1(y) returns a function that gets assigned to f2.  Therefore, f2 is a function.
result = f2(z)  // f2(z) returns a result, which is NOT a function.

To obtain the final result above, we need to call 3 functions:
1) f(x)  must get called first.
2) f1(y) must get called second.
3) f2(z) must get called last.

Immediately after the f(x) function is called above (and just before
the f1(y) function is called), the f2(z) function is partially applied.
Immediately after the f1(y) function is called (and just before the
f2(z) function is called), the f2(z) function is still partially applied.
Only after the f2(z) function is called (when it returns a result), is
the f2(z) function fully applied.

Since the f2(z) function is built from caling both the f(x) and f1(y) functions,
f(x) and f1(y) are partially-applied functions of function f2(z).
========================================================================
object Demo
{
  def main(args: Array[String])
  {
    // Immediately after sum1(2) gets called, the func1 function is partially applied.
    // After func1(5) gets called, the func1 function is fully applied.
    val func1:(Int => Int) = sum1(2)
    println(func1(5)) // PRINTS: 7  (2 + 5 = 7)

    // Immediately after sum2(2)(42) gets called, the func2 function is partially applied.
    // After func2(5) gets called, the func2 function is fully applied.
    val func2:(Int => Int) = sum2(2)(42)
    println(func2(5)) // PRINTS: 49 (2 + 42 + 5 = 49)
  }

  def sum1(a: Int):(Int => Int)       = { b => a + b }
  def sum2(a:Int)(b:Int):(Int => Int) = { c => a + b + c }
}
========================================================================
object Demo
{
  def main(args: Array[String])
  {
    val result:Int = plus2(11)
    println("result = " + result) // PRINTS: result = 13 (2 + 11 = 13)
  }

  def plus(a:Int)(b:Int):Int = { println("a = " + a + ",  b = " + b);  a + b } // PRINTS: a = 2,  b = 11
  def plus2 = plus(2)(_)  // NOTE: This plus2()() function calls the plus() function defined above.
}
========================================================================
object Demo
{
  def main(args: Array[String])
  {
    val greeting = "This is Scala"
    var result = wrap("<div>")(greeting)("</div>")
    println("result = " + result) // PRINTS: result = <div>This is Scala</div>

    // NOTE: wrapWithDiv is a partially-applied function BEFORE IT GETS CALLED
    //       because it's defined as a function that returns a function.
    //       Therefore, only AFTER wrapWithDiv() gets called is it fully applied.
    result = wrapWithDiv(greeting)
    println("result = " + result) // PRINTS: result = <div>This is Scala</div>
  }

  def wrap(prefix:String)(html:String)(suffix:String):String = { prefix + html + suffix }
  // NOTE: wrapWithDiv is defined by calling the wrap() function and passing
  //       to it the Scala placeholder underscore symbol (_).
  def wrapWithDiv:(String => String) = wrap("<div>")(_)("</div>")
}
========================================================================
object Demo
{
  def main(args: Array[String])
  {
    val addFunction = add _  // Converts the def add() function (defined below)
                             // into a true function via an "Eta Expansion".
    val addCurried = addFunction.curried // Converts the addFunction into a curried function.
    val result:Int = addCurried(23)(46)
    println("result = " + result) // PRINTS: result = 69
  }

  // NOTE: add() is a regular Scala function.  In the code above,
  //       this add() function is used to create a curried function.
  def add(x:Int, y:Int):Int = { x + y }
}
========================================================================
