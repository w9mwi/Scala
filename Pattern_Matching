


object Demo
{
  case class Person(name:String, age:Int)

  def main(args: Array[String]): Unit =
  {
    // ***************************************************************
    // Call the listMatcher() function with the List[Int] data type...
    var list:List[Int] = Nil
    listMatcher(list) // PRINTS: 1) intList = Nil = List()
    list = List(1, 2, 3, 4)
    listMatcher(list) // PRINTS: 2) intList = List(1, 2, 3, 4)
    list = List(1, 2, 3, 4, 5, 6, 7, 8, 9)
    listMatcher(list) // PRINTS: 3) intList = List(1, 2, 3, 4, 5, 6, 7, 8, 9)
    list = List(-123, 2)
    listMatcher(list) // PRINTS: 3) intList = List(-123, 2)
    list = List(99, 666, 777, 888)
    listMatcher(list) // PRINTS: 4) head = 99, tail = List(666, 777, 888)
    list = List(-666)
    listMatcher(list) // PRINTS: 5) intList ends with -666
    list = List(44, 33, 22, 11)
    listMatcher(list) // PRINTS: 6) head = 44,  tail = List(33, 22, 11)
    list = 44 :: List(55, 66, 77)
    listMatcher(list) // PRINTS: 6) head = 44,  tail = List(55, 66, 77)
    list = 44 :: Nil
    listMatcher(list) // PRINTS: 6) head = 44,  tail = List()
    println("================================")

    // **********************************************************
    // Call the anyMatcher() function with the Any data type...
    var anyValue:Any = BigInt("98765432101234567890")
    anyMatcher(anyValue) // PRINTS: 1) anyValue = 98765432101234567890
    anyValue = List()
    anyMatcher(anyValue) // PRINTS: 2) anyValue = Nil = List()
    anyValue = Array()
    anyMatcher(anyValue) // PRINTS: 3) anyValue = Array()
    anyValue = Vector(List(1,2,3), Array('X', 'Y', 'Z'), 777)
    anyMatcher(anyValue) // PRINTS: 4) anyValue = Vector(List(1, 2, 3), [C@23a5fd2, 777)
    anyValue = Person("Jack", 13)
    anyMatcher(anyValue) // PRINTS: 5) Jack is 13 years old.
    anyValue = Array("ABC", "DEF", "UVW", "XYZ")
    anyMatcher(anyValue) // PRINTS: 6) anyValue doesn't match one of the coded data types.
    println("================================")

    // *******************************************
    printNumberAsRanking(0)    // PRINTS:   0 = 0th
    printNumberAsRanking(1)    // PRINTS:   1 = 1st
    printNumberAsRanking(2)    // PRINTS:   2 = 2nd
    printNumberAsRanking(3)    // PRINTS:   3 = 3th
    printNumberAsRanking(4)    // PRINTS:   4 = 4th
    printNumberAsRanking(5)    // PRINTS:   5 = 5th
    printNumberAsRanking(6)    // PRINTS:   6 = 6th
    printNumberAsRanking(7)    // PRINTS:   7 = 7th
    printNumberAsRanking(8)    // PRINTS:   8 = 8th
    printNumberAsRanking(9)    // PRINTS:   9 = 9th
    printNumberAsRanking(10)   // PRINTS:  10 = 10th
    printNumberAsRanking(11)   // PRINTS:  11 = 11th
    printNumberAsRanking(12)   // PRINTS:  12 = 12th
    printNumberAsRanking(13)   // PRINTS:  13 = 13th
    printNumberAsRanking(14)   // PRINTS:  14 = 14th
    printNumberAsRanking(15)   // PRINTS:  15 = 15th
    printNumberAsRanking(16)   // PRINTS:  16 = 16th
    printNumberAsRanking(17)   // PRINTS:  17 = 17th
    printNumberAsRanking(18)   // PRINTS:  18 = 18th
    printNumberAsRanking(19)   // PRINTS:  19 = 19th
    printNumberAsRanking(20)   // PRINTS:  20 = 20th
    printNumberAsRanking(21)   // PRINTS:  21 = 21st
    printNumberAsRanking(22)   // PRINTS:  22 = 22nd
    printNumberAsRanking(23)   // PRINTS:  23 = 23rd
    printNumberAsRanking(24)   // PRINTS:  24 = 24th
    printNumberAsRanking(25)   // PRINTS:  25 = 25th
    printNumberAsRanking(99)   // PRINTS:  99 = 99th
    printNumberAsRanking(100)  // PRINTS: 100 = 100th
    printNumberAsRanking(101)  // PRINTS: 101 = 101th
    printNumberAsRanking(102)  // PRINTS: 102 = 102nd
    printNumberAsRanking(103)  // PRINTS: 103 = 103rd
    printNumberAsRanking(104)  // PRINTS: 104 = 104th
  }

  def listMatcher(intList:List[Int]):Unit = {
    intList match {
      case Nil => println("1) intList = Nil = List()")
      case List(_, _, 3, _) => println(s"2) intList = $intList")
      // "_*" designates a variable number of arguments, which matches on zero or more arguments.
      case List(_, 2, _*) => println(s"3) intList = $intList")
      case 99 :: tail => println(s"4) head = 99, tail = $tail")
      // Test that the list ends with -666.
      // "_*" designates a variable number of arguments, which matches on zero or more arguments.
      // ":+" infix operator appends one element to the list.
      case List(_*) :+ -666 => println("5) intList ends with -666")
      case head :: tail => println(s"6) head = $head,  tail = $tail")
    }
  }

  def anyMatcher(anyValue:Any):Unit = {
    anyValue match {
      case _: BigInt => println(s"1) anyValue = $anyValue")
      case Nil => println("2) anyValue = Nil = List()")
      case Array() => println("3) anyValue = Array()")
      case Vector(List(_, 2, 3), _, 777) => println(s"4) anyValue = $anyValue")
      case Person(n, a) => println(s"5) $n is $a years old.")
      case _ => println("6) anyValue doesn't match one of the coded data types.")
    }
  }

  def printNumberAsRanking(number:Int):Unit = {
    println(s"$number = ${numberRankMatcher(number)}")
  }

  def numberRankMatcher(number:Int):String = {
    number match {
      case x if ((x % 10 == 0) || (x > 9 && x < 15)) => (number + "th")
      case x if (x % 10 == 1) => (number + "st")
      case x if (x % 10 == 2) => (number + "nd")
      case x if (x % 10 == 3) => (number + "rd")
      case _ => (number + "th")
    }
  }
}


========================================================================================
========================================================================================
========================================================================================
========================================================================================

==================================================================================

object Demo
{
  // By default, a case class's parameters are val types (when you don't specify
  // a val/var type), so they can NOT be changed.  The following CaseClassDemo
  // class has its params declared as var types, so they CAN be changed--even
  // if the instance of CaseClassDemo is declared a val.
  case class CaseClassDemo(var str:String, var integer:Int, var float:Float)

  // NOTE: The Email, SMS, VoiceRecording, and TrashNotify case classes declarations
  //       below all extend the Notification class, which is an abstract class.
  //       Therefore, these 4 case classes can be treated as a Notification class.
  abstract class Notification
  case class Email(sender:String, title:String, body:String) extends Notification
  case class SMS(caller:String, message:String) extends Notification
  case class VoiceRecording(contactName:String, link:String) extends Notification
  case class TrashNotify() extends Notification

  def main(args: Array[String])
  {
    val myClass1 = CaseClassDemo("Tom", 321, 56.789F)
    println("myClass1.str = "        + myClass1.str +
            ",  myClass1.integer = " + myClass1.integer +
            ",  myClass1.float = "   + myClass1.float)

    // NOTE: Even though myClass1 is a val type, notice that we can alter its member
    //       values here cuz the parameters of CaseClassDemo are declared as var.
    myClass1.str     = "Jim"
    myClass1.integer = 666
    myClass1.float   = 345.67F
    println("myClass1.str = "        + myClass1.str +
            ",  myClass1.integer = " + myClass1.integer +
            ",  myClass1.float = "   + myClass1.float)

    // We now show how case classes are used for pattern matching.  The following
    // 4 classes were all defined (above) as subclasses of the Notification class.
    // Therefore, all 4 of these classes can be considered a Notification class,
    // and therefore can be used to match on the Notification class in the
    // showNotification function below.
    val someEmail:Email = Email("Sender Bender", "Titletown, USA", "Hi.  See you later.")
    val someSms:SMS = SMS("12345", "Are you there?")
    val someVoiceRecording:VoiceRecording = VoiceRecording("Tom", "www.420.com")
    val someTrash:TrashNotify = TrashNotify()

    println()
    println(showNotification(someTrash))
    println(showNotification(someVoiceRecording))
    println(showNotification(someEmail))
    println(showNotification(someSms))
  }

  def showNotification(notification:Notification):String =
  {
    notification match
    {
      case Email(email, title, _) => s"You have an email from $email with title: $title"
      case SMS(number, message) =>  s"You have an SMS from $number! Message: $message"
      case VoiceRecording(name, link) =>  s"You received a Voice Recording from $name!  To hear it, click: $link"
      case _ => s"This is some other type of Notification message--trash it!"
    }
  }
}

==================================================================================

object Demo
{
  trait Computer
  {
    def getRAM():String
    def getHDD():String
    def getCPU():String
    // Every class has a toString() method by default.  Here,
    // we override toString() to return what we want.
    override def toString = "RAM = " + getRAM +", HDD = " + getHDD + ", CPU = " + getCPU
  }

  private class PC(val ram:String, val hdd:String, val cpu:String) extends Computer
  { // 3 methods defined here...
    def getRAM():String = ram;   def getHDD():String = hdd;   def getCPU():String = cpu;
  }

  private class Server(val ram:String, val hdd:String, val cpu:String) extends Computer
  { // 3 methods defined here...
    def getRAM():String = ram;    def getHDD():String = hdd;  def getCPU():String = cpu;
  }

  object ComputerFactory
  {
    // NOTE: The apply() method gets invoked automatically by
    //       Scala when the class constructor gets called.
    def apply(compType:String, ram:String, hdd:String, cpu:String):Computer =
    {
      compType.toUpperCase match { case "PC"     => new PC(ram, hdd, cpu)
                                   case "SERVER" => new Server(ram, hdd, cpu)
                                   case _        => null }
    }
  }

  def main(args:Array[String])
  {
    val pc         = ComputerFactory("pc",        " 2 GB", "500 GB", "2.4 GHz")
    val server     = ComputerFactory("server",    "16 GB", "  1 TB", "2.9 GHz")
    val noComputer = ComputerFactory("undefined", " 0 GB", "  0 GB", "0.0 GHz")
    // The following 3 println statements print this:
    // Factory PC Config:     RAM =  2 GB, HDD = 500 GB, CPU = 2.4 GHz
    // Factory Server Config: RAM = 16 GB, HDD =   1 TB, CPU = 2.9 GHz
    // No Computer:           null
    println("Factory PC Config:     " + pc)
    println("Factory Server Config: " + server)
    println("No Computer:           " + noComputer)
  }
}

==================================================================================

It's possible to perfom pattern matching without using the "match" keyword,
by using a single case statement, as shown in the following code...

object Demo
{
  def main(args: Array[String])
  {
    val mySeq:Seq[Int] = Seq(2,3,4)
    println("mySeq = " + mySeq)       // PRINTS: mySeq = List(2, 3, 4)
    val mySeqZip:Seq[(Int,Int)] = mySeq.zipWithIndex
    println("mySeqZip = " + mySeqZip) // PRINTS: mySeqZip = List((2,0), (3,1), (4,2))

    // Every element of mySeqZip contains a List of (Int,Int) tuples.
    // The following line of code loops though each element of that
    // List, and calls the anonymous function contained in the loop.
    // Each (Int,Int) tuple will match on the case statement, which
    // will then invoke println.
    mySeqZip.foreach { case (value, index) => println(s"$index:$value") }
    // PRINTS:
    // 0:2
    // 1:3
    // 2:4

    // All of the above code can be written in this one line of code...
    Seq(2,3,4).zipWithIndex.foreach { case (value, index) => println(s"$index:$value") }
  }
}
