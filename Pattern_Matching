
In most cases pattern matching (which invokes the unapply() method) is performed
using the Scala keyword "match".  But pattern matching can also be performed in
an assignment statement, which isn't very intuitive, like this...

val FullName(first, last) = joe  // This line perfroms pattern matching.

The following code sample shows an example of how this is done.
Read in-line comments for details.

object Demo
{
  def main(args: Array[String]): Unit = {
    // For all case classes Scala automatically generates
    // both an apply() method and an unapply() method.
    case class FullName(firstName:String, lastName:String)

    // When a case class is instantiated (as on the following line),
    // Scala automatically invokes the case class's apply() method.
    val joe:FullName = FullName("Joe", "Blow") // FullName.apply() gets called.
    println(s"1) joe.firstName = ${joe.firstName},  joe.lastName = ${joe.lastName}")
    // PRINTS: 1) joe.firstName = Joe,  joe.lastName = Blow

    // The following line of code doesn't seem to make sense because it's NOT
    // very intuitive.  The following line of code performs a pattern match
    // on "val joe" by automatically invoking the FullName.unapply() method.
    // The unapply() method extracts joe.firstName and joe.lastName from
    // val joe and assigns them to the vals "first" and "last" respectively.
    // NOTE:  If the following line contained the keyword var instead of val,
    //        then first and last would become vars instead of vals.
    val FullName(first, last) = joe
    println(s"2) first = $first,  last = $last")
    // 2) first = Joe,  last = Blow
  }
}


===================================================================================

The following sample programs demonstrate many variations on
how to use Scala's "match" keyword with a case statement to
perform pattern matching.  Read in-line comments for details.


object Demo
{
  case class Person(name:String, age:Int)

  def main(args: Array[String]): Unit =
  {
    // ***************************************************************
    // Call the listMatcher() function with the List[Int] data type...
    var list:List[Int] = Nil
    listMatcher(list) // PRINTS: 1) intList = Nil = List()
    list = List(1, 2, 3, 4)
    listMatcher(list) // PRINTS: 2) intList = List(1, 2, 3, 4)
    list = List(1, 2, 3, 4, 5, 6, 7, 8, 9)
    listMatcher(list) // PRINTS: 3) intList = List(1, 2, 3, 4, 5, 6, 7, 8, 9)
    list = List(-123, 2)
    listMatcher(list) // PRINTS: 3) intList = List(-123, 2)
    list = List(99, 666, 777, 888)
    listMatcher(list) // PRINTS: 4) head = 99, tail = List(666, 777, 888)
    list = List(-666)
    listMatcher(list) // PRINTS: 5) intList ends with -666
    list = List(44, 33, 22, 11)
    listMatcher(list) // PRINTS: 6) head = 44,  tail = List(33, 22, 11)
    list = 44 :: List(55, 66, 77)
    listMatcher(list) // PRINTS: 6) head = 44,  tail = List(55, 66, 77)
    list = 44 :: Nil
    listMatcher(list) // PRINTS: 6) head = 44,  tail = List()
    println("================================")

    // **********************************************************
    // Call the anyMatcher() function with the Any data type...
    var anyValue:Any = BigInt("98765432101234567890")
    anyMatcher(anyValue) // PRINTS: 1) anyValue = 98765432101234567890
    anyValue = List()
    anyMatcher(anyValue) // PRINTS: 2) anyValue = Nil = List()
    anyValue = Array()
    anyMatcher(anyValue) // PRINTS: 3) anyValue = Array()
    anyValue = Vector(List(1,2,3), Array('X', 'Y', 'Z'), 777)
    anyMatcher(anyValue) // PRINTS: 4) anyValue = Vector(List(1, 2, 3), [C@23a5fd2, 777)
    anyValue = Person("Jack", 13)
    anyMatcher(anyValue) // PRINTS: 5) Jack is 13 years old.
    anyValue = Array("ABC", "DEF", "UVW", "XYZ")
    anyMatcher(anyValue) // PRINTS: 6) anyValue doesn't match one of the coded data types.
    println("================================")

    // *******************************************
    printNumberAsRanking(0)    // PRINTS:   0 = 0th
    printNumberAsRanking(1)    // PRINTS:   1 = 1st
    printNumberAsRanking(2)    // PRINTS:   2 = 2nd
    printNumberAsRanking(3)    // PRINTS:   3 = 3th
    printNumberAsRanking(4)    // PRINTS:   4 = 4th
    printNumberAsRanking(5)    // PRINTS:   5 = 5th
    printNumberAsRanking(6)    // PRINTS:   6 = 6th
    printNumberAsRanking(7)    // PRINTS:   7 = 7th
    printNumberAsRanking(8)    // PRINTS:   8 = 8th
    printNumberAsRanking(9)    // PRINTS:   9 = 9th
    printNumberAsRanking(10)   // PRINTS:  10 = 10th
    printNumberAsRanking(11)   // PRINTS:  11 = 11th
    printNumberAsRanking(12)   // PRINTS:  12 = 12th
    printNumberAsRanking(13)   // PRINTS:  13 = 13th
    printNumberAsRanking(14)   // PRINTS:  14 = 14th
    printNumberAsRanking(15)   // PRINTS:  15 = 15th
    printNumberAsRanking(16)   // PRINTS:  16 = 16th
    printNumberAsRanking(17)   // PRINTS:  17 = 17th
    printNumberAsRanking(18)   // PRINTS:  18 = 18th
    printNumberAsRanking(19)   // PRINTS:  19 = 19th
    printNumberAsRanking(20)   // PRINTS:  20 = 20th
    printNumberAsRanking(21)   // PRINTS:  21 = 21st
    printNumberAsRanking(22)   // PRINTS:  22 = 22nd
    printNumberAsRanking(23)   // PRINTS:  23 = 23rd
    printNumberAsRanking(24)   // PRINTS:  24 = 24th
    printNumberAsRanking(25)   // PRINTS:  25 = 25th
    printNumberAsRanking(99)   // PRINTS:  99 = 99th
    printNumberAsRanking(100)  // PRINTS: 100 = 100th
    printNumberAsRanking(101)  // PRINTS: 101 = 101st
    printNumberAsRanking(102)  // PRINTS: 102 = 102nd
    printNumberAsRanking(103)  // PRINTS: 103 = 103rd
    printNumberAsRanking(104)  // PRINTS: 104 = 104th
  }

  def listMatcher(intList:List[Int]):Unit = {
    intList match {
      case Nil => println("1) intList = Nil = List()")
      case List(_, _, 3, _) => println(s"2) intList = $intList")
      // "_*" designates a variable number of arguments, which matches on zero or more arguments.
      case List(_, 2, _*) => println(s"3) intList = $intList")
      case 99 :: tail => println(s"4) head = 99, tail = $tail")
      // Test that the list ends with -666.
      // "_*" designates a variable number of arguments, which matches on zero or more arguments.
      // ":+" infix operator appends one element to the list.
      case List(_*) :+ -666 => println("5) intList ends with -666")
      case head :: tail => println(s"6) head = $head,  tail = $tail")
    }
  }

  def anyMatcher(anyValue:Any):Unit = {
    anyValue match {
      case _: BigInt => println(s"1) anyValue = $anyValue")
      case Nil => println("2) anyValue = Nil = List()")
      case Array() => println("3) anyValue = Array()")
      case Vector(List(_, 2, 3), _, 777) => println(s"4) anyValue = $anyValue")
      case Person(n, a) => println(s"5) $n is $a years old.")
      case _ => println("6) anyValue doesn't match one of the coded data types.")
    }
  }

  def printNumberAsRanking(number:Int):Unit = {
    println(s"$number = ${numberRankMatcher(number)}")
  }

  def numberRankMatcher(number:Int):String = {
    number match {
      case x if ((x % 10 == 0) || (x > 9 && x < 15)) => (number + "th")
      case x if (x % 10 == 1) => (number + "st")
      case x if (x % 10 == 2) => (number + "nd")
      case x if (x % 10 == 3) => (number + "rd")
      case _ => (number + "th")
    }
  }
}

==================================================================================

object Demo
{
  // NOTICE: The Email, SMS, VoiceRecording, and MorseCodeNotify case classes declarations
  //         below all extend the Notification class, which is an abstract class.
  //         Therefore, these 4 case classes can be treated as a Notification class.
  abstract class Notification
  case class Email(sender:String, title:String, body:String) extends Notification
  case class SMS(caller:String, message:String)              extends Notification
  case class VoiceRecording(contactName:String, link:String) extends Notification
  case class MorseCodeNotify()                               extends Notification

  def main(args: Array[String])
  {
    // We now demonstrate how to pattern match on the 4 case classes defined above.
    // Because all 4 of those case classes extend the Notification abstract class,
    // we can pass these classes as an argument to the showNotification() method
    // below, as type Notification.
    val emailNotify:Email               = Email("Sender Bender", "Titletown, USA", "Hi.  See you later.")
    val smsNotify:SMS                   = SMS("12345", "Are you there?")
    val voiceNotify:VoiceRecording      = VoiceRecording("Tom", "www.420.com")
    val morseCodeNotify:MorseCodeNotify = MorseCodeNotify()

    println

    println(showNotification(morseCodeNotify))
    println(showNotification(voiceNotify))
    println(showNotification(emailNotify))
    println(showNotification(smsNotify))
  }

  def showNotification(notification:Notification):String =
  {
    notification match
    {
      case Email(email, title, _)     => s"You have an email from $email with title: $title"
      case SMS(number, message)       =>  s"You have an SMS from $number! Message: $message"
      case VoiceRecording(name, link) =>  s"You received a Voice Recording from $name!  To hear it, click on: $link"
      case _                          => "This is an unknown Notification message."
    }
  }
}

==================================================================================

THE FOLLOWING PROGRAM IS OLD JUNK THAT WILLPROBABLY BE DELETED LATER.

object Demo
{
  trait Computer
  {
    def getRAM():String
    def getHDD():String
    def getCPU():String
    // Every class has a toString() method by default.  Here,
    // we override toString() to return what we want.
    override def toString = "RAM = " + getRAM +", HDD = " + getHDD + ", CPU = " + getCPU
  }

  private class PC(val ram:String, val hdd:String, val cpu:String) extends Computer
  { // 3 methods defined here...
    def getRAM():String = ram;   def getHDD():String = hdd;   def getCPU():String = cpu;
  }

  private class Server(val ram:String, val hdd:String, val cpu:String) extends Computer
  { // 3 methods defined here...
    def getRAM():String = ram;    def getHDD():String = hdd;  def getCPU():String = cpu;
  }

  object ComputerFactory
  {
    // NOTE: The apply() method gets invoked automatically by
    //       Scala when the class constructor gets called.
    def apply(compType:String, ram:String, hdd:String, cpu:String):Computer =
    {
      compType.toUpperCase match { case "PC"     => new PC(ram, hdd, cpu)
                                   case "SERVER" => new Server(ram, hdd, cpu)
                                   case _        => null }
    }
  }

  def main(args:Array[String])
  {
    val pc         = ComputerFactory("pc",        " 2 GB", "500 GB", "2.4 GHz")
    val server     = ComputerFactory("server",    "16 GB", "  1 TB", "2.9 GHz")
    val noComputer = ComputerFactory("undefined", " 0 GB", "  0 GB", "0.0 GHz")
    // The following 3 println statements print this:
    // Factory PC Config:     RAM =  2 GB, HDD = 500 GB, CPU = 2.4 GHz
    // Factory Server Config: RAM = 16 GB, HDD =   1 TB, CPU = 2.9 GHz
    // No Computer:           null
    println("Factory PC Config:     " + pc)
    println("Factory Server Config: " + server)
    println("No Computer:           " + noComputer)
  }
}

==================================================================================

THE FOLLOWING PROGRAM IS OLD JUNK THAT WILLPROBABLY BE DELETED LATER.

It's possible to perfom pattern matching without using the "match" keyword,
by using a single case statement, as shown in the following code...

object Demo
{
  def main(args: Array[String])
  {
    val mySeq:Seq[Int] = Seq(2,3,4)
    println("mySeq = " + mySeq)       // PRINTS: mySeq = List(2, 3, 4)
    val mySeqZip:Seq[(Int,Int)] = mySeq.zipWithIndex
    println("mySeqZip = " + mySeqZip) // PRINTS: mySeqZip = List((2,0), (3,1), (4,2))

    // Every element of mySeqZip contains a List of (Int,Int) tuples.
    // The following line of code loops though each element of that
    // List, and calls the anonymous function contained in the loop.
    // Each (Int,Int) tuple will match on the case statement, which
    // will then invoke println.
    mySeqZip.foreach { case (value, index) => println(s"$index:$value") }
    // PRINTS:
    // 0:2
    // 1:3
    // 2:4

    // All of the above code can be written in this one line of code...
    Seq(2,3,4).zipWithIndex.foreach { case (value, index) => println(s"$index:$value") }
  }
}
