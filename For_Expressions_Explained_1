
A Scala "for expression" can contain the following 4 expressions:

1) Generator/Receiver - The "<-" operator in a for expression separates the generator and
                        the receiver.  The generator appears on the RIGHT SIDE of the "<-"
                        operator, and the receiver appears on the LEFT SIDE of the "<-"
                        operator.  The generator references the collection that the for loop
                        iterates through.  The receiver is basically a "val" that gets
                        assigned the current element of the collection.

                        In the following for expression "people" is the generator and "p" is the receiver.

                        for (p <- people)  // "people" is the GENERATOR, "p" is the RECEIVER.
                          println(s"Person = $p")

                        When a for loop is embedded within another for loop, the for expression
                        will contain multiple generator/receiver pairs.

2) Definition - A definition is basically a "val" declaration contained within a for loop.  For each
                element in the collection (each iteration of the for loop), this val gets assigned
                some part of that element.  This val can then be referenced in a for expression's
                FILTER or YIELD section to make the code more readable.  A definition is OPTIONAL
                in a for expression--it's not required.

3) Filter - A filter is a Boolean expression contained within a for expression.  Each element of the
            collection for which this filter expression returns False will NOT be returned by the for
            expression.  Thus, it acts to filter/remove certain elements of the collection from the
            the for expression's result.  A filter is OPTIONAL in a for expression--it's not required.

4) yield - "yield" is a Scala keyword that appears at the tail-end of a for expression.
           The expression that appears after the "yield" keyword is used to alter the
           result returned by the for expression.  So both the FILTER expression and the
           YIELD expression are used to alter the result returned by a for expression.
           The "yield" keyword is OPTIONAL in a for expression--it's not required.

The following two code samples demonstrate how to write some basic for expressions.
Read comments for details.
============================================================================
object Demo
{
  case class Person(name:String, yearBorn:Int)

  def main(args: Array[String]): Unit =
  {
    val people:List[Person] = List(Person("Jim", 1975), Person("Sue", 1988),
                                   Person("Tom", 1999), Person("Tony", 1944))
    println("PART 1) =====================")
    for (p <- people)  // "people" is the GENERATOR, "p" is the RECEIVER.
      println(s"Person = $p") // PRINTS: Person = Person(Jim,1975)
                              //         Person = Person(Sue,1988)
                              //         Person = Person(Tom,1999)
                              //         Person = Person(Tony,1944)

    println("PART 2) =====================")
    val result:List[String] =
      for {
        p <- people               // "people" is the GENERATOR, "p" is the RECEIVER
        name = p.name             // DEFINITION
        if (name startsWith "To") // FILTER - Return only people whose names start with "To".
      } yield name                // YIELD - Return only the Person.name member of the class Person.


    // The Scala API supplies the foreach() method for every collection.  Use the foreach()
    // method to print the result returned by the above for expression.
    result.foreach(println) // PRINTS: Tom
                            //         Tony
  }
}
============================================================================
object Demo
{
  case class Person(firstName:String, lastName:String)

  def main(args:Array[String]): Unit =
  {
    val states:List[String] = List("Alabama", "Alaska", "Wisconsin", "Wyoming")

    var statesCapitalized:List[String]  = for (x <- states) yield x.toUpperCase
    println(statesCapitalized) // PRINTS:  List(ALABAMA, ALASKA, WISCONSIN, WYOMING)

    statesCapitalized = states.map(_.toUpperCase) // This line generates identical results to the above for expression.
    println(statesCapitalized) // PRINTS:  List(ALABAMA, ALASKA, WISCONSIN, WYOMING)

    // =================================================================

    val people:List[Person] = List(Person("Barney", "Rubble"),
                                   Person("Fred", "Flintstone"),
                                   Person("Betty", "Rubble"))

    val firstNamesStartingWithB:List[String] =
        for {
              p <- people                // This line contains the RECEIVER and GENERATOR.
              fname = p.firstName        // This line is the DEFINITION.
              if (fname.startsWith("B")) // This line is the FILTER.
            } yield fname.toUpperCase

    println(firstNamesStartingWithB) // PRINTS: List(BARNEY, BETTY)
  }
}
============================================================================

Assume you want use a for expression to iterate through some Scala-defined collection, such as:

* Array[String]
* List[(Char, Boolean)]
* Map[String, Int]

The Scala compiler will translate that for expression into a series of method calls,
using one or more of the following four methods.  As these four methods are defined
in all Scala collection classes.

withFilter() - Enables a collection class to work with a filter in a for expression.
               (This method is called ONLY when a for expression implements a filter.)

foreach()    - Enables a collection class to work with a for expression that DOESN'T use the "yield" keyword.
               This foreach() method will work with a single for expression, or with multiple embedded
               for expressions--as long as NONE of them implement the "yield" keyword.

map()        - Enables a collection class to work with a for expression that DOES use the "yield" keyword.
               This map() method works only with a single for expression, not with multiple embedded
               for expressions.  When a collection class must work with multiple embedded for expressions,
               the collection class MUST contain this map() method, AND the flatMap() method mentioned below.

flatMap()    - Enables a collection class to work with multiple embedded for expressions that also
               implement the "yield" keyword.

If you write your own collection class and want to make it work with a for expression, you must
write the above four methods and make them members of your collection class.  Here's an example
of how you could do that.  
or more of the above methods to make it to work with for expressions.  If you needed to write
these methods for your own class, you'd begin with code similar to this:

abstract class CustomCollectionClass[A]
{
  def foreach(func: A => Unit):Unit
  def map[B](func: A => B):CustomCollectionClass[B]
  def flatMap[B](func: A => CustomCollectionClass[B]):CustomCollectionClass[B]
  def withFilter(func: A => Boolean):CustomCollectionClass[A]
}

================================================================================
This code shows a simple example of how to use a for expression.

object Demo
{
  case class Person(firstName:String, lastName:String)

  def main(args:Array[String]): Unit =
  {
    val states:List[String] = List("Alabama", "Alaska", "Wisconsin", "Wyoming")

    var statesCapitalized:List[String]  = for (x <- states) yield x.toUpperCase
    println(statesCapitalized) // PRINTS:  List(ALABAMA, ALASKA, WISCONSIN, WYOMING)

    statesCapitalized = states.map(_.toUpperCase) // This line generates identical results to the above for expression.
    println(statesCapitalized) // PRINTS:  List(ALABAMA, ALASKA, WISCONSIN, WYOMING)

    // =================================================================

    val people:List[Person] = List(Person("Barney", "Rubble"),
                                   Person("Fred", "Flintstone"),
                                   Person("Betty", "Rubble"))

    val firstNamesStartingWithB:List[String] =
        for {
              p <- people                // This line contains the RECEIVER and GENERATOR.
              fname = p.firstName        // This line is the DEFINITION.
              if (fname.startsWith("B")) // This line is the FILTER.
            } yield fname.toUpperCase

    println(firstNamesStartingWithB) // PRINTS: List(BARNEY, BETTY)
  }
}

================================================================================

The code sample shown below defines a case class named Sequence, which
implements the four (4) methods mentioned above in CustomCollectionClass[A].
Those 4 methods will make the Sequence case class work with "for expressions"
(which use the "yield" keyword).  This Sequence class works with generic
types, so it's defined below as Sequence[A], where A is the generic type.

import scala.collection.mutable.ListBuffer
object Demo
{
  case class Person(firstName:String, lastName:String)
  case class Sequence[A](private val initialElems: A*) // A* designates a variable number of args of type A.
  {
    // When this Sequence constructor is called it creates an elems
    // instance, which represents all elements in this Sequence class.
    // EXAMPLE:  As you can call the List constructor like this: List(1, 2, 3),
    //           you can call the Sequence constructor like this: Sequence(1, 2, 3)
    //           The Demo.main() method below calls this Sequence constructor,
    //           where the number of args it gets passed is variable.
    private val elems:ListBuffer[A] = ListBuffer[A]()
    elems ++= initialElems // The ++= operator for the ListBuffer class appends multiple elements.
    // NOTE: "elems ++= initialElems" above could be replaced with:  for { x <- initialElems } elems += x

    /*********************************************************
     * NOTE: This foreach() method enables the main() function
     *       below to implement a for loop on the Sequence
     *       case class, similar to this example, where ints
     *       is a Sequence class:
     *       for (x <- ints) println(x)
     ********************************************************/
    def foreach(block: A => Unit):Unit =
    {
      elems.foreach(block)
    }

    /*********************************************************
     * NOTE: This map() method enables the main() function
     *       below to implement a for loop on the Sequence
     *       case class, similar to this example, where ints
     *       is a Sequence class:
     *       for { x <- ints } yield x*2
     ********************************************************/
    def map[B](func: A=>B):Sequence[B] =
    {
      val listBuf:ListBuffer[B] = elems.map(func)
      // NOTE: The :_* below is the syntax used when calling a constructor, or a method,
      //       that accepts a variable number of arguments.  In this example, since
      //       the Sequence constructor is written to accept a variable number of args,
      //       the :_* syntax must be used with the listBuf collection.
      Sequence(listBuf.toSeq:_*) // Return a new Sequence class where map() was run
                                 // on all elements of the previous Sequence class.
    }

    /*********************************************************
     * NOTE: This flatMap() method enables the main() function
     *       below to implement MULTIPLE GENERATORS within
     *       a for loop on this Sequence case class.
     ********************************************************/
    def flatMap[B](func: A => Sequence[B]):Sequence[B] =
    {
      val resultListBuf:ListBuffer[B] = ListBuffer[B]()

      // NOTE: In Scala the flatMap function calls the following 2 functions, in this order:
      //       1) Calls the map function on every element in the collection, returning a new collection.
      //       2) Calls the flatten function on the result returned by map, returning that result.
      for (listBuf:Sequence[B] <- map(func)) // First map is called.
      {
        for (elem <- listBuf) { resultListBuf += elem }  // This for() loop "flattens" the result returned by map.
      }

      // NOTE: The :_* below is the syntax used when calling a constructor, or a method,
      //       that accepts a variable number of arguments.  In this example, since
      //       the Sequence constructor is written to accept a variable number of args,
      //       the :_* syntax must be used with the resultListBuf collection.
      Sequence(resultListBuf.toSeq:_*) // Return a new Sequence class where flatMap() was
                                       // run on all elements of the previous Sequence class.
    }

    /*********************************************************
     * NOTE: This withFilter() method enables the main()
     *       function below to implement filters within
     *       for loops on this Sequence case class:
     ********************************************************/
    def withFilter(func: A => Boolean):Sequence[A] =
    {
      val listBuf:ListBuffer[A] = elems.filter(func)
      // NOTE: The :_* below is the syntax used when calling a constructor, or a method,
      //       that accepts a variable number of arguments.  In this example, since
      //       the Sequence constructor is written to accept a variable number of args,
      //       the :_* syntax must be used with the listBuf_1 collection.
      Sequence(listBuf.toSeq:_*) // Return a new Sequence class where withFilter() was
      // run on all elements of the previous Sequence class.
    }
  } // END: case class Sequence[A]

  /*********************************************************
   *
   ********************************************************/
  def main(args:Array[String]): Unit =
  {
    // The following 2 lines call the above Sequence constructor by passing it a variable
    // number of arguments.  The above Sequence constructor can be called by passing to it
    // any data type, such as Ints.  EXAMPLE:  val seqInts = Sequence(1, 2, 3, 4)
    val myFriends:Sequence[Person]   = Sequence(Person("Jack",   "Daniels"),  Person("Johnny", "Walker"), Person("Jim", "Beam"))
    val joesFriends:Sequence[Person] = Sequence(Person("Joseph", "Schlitz"),  Person("George", "Jones"),  Person("Jim", "Beam"))

    // The following for loop works with MULTIPLE GENERATORS
    // because the Sequence.flatMap() method is defined above.
    val mutualFriends:Sequence[Person] =
    for {
          myFriend   <- myFriends   // This is a GENERATOR.
          joesFriend <- joesFriends // This is another GENERATOR.
          if (myFriend.firstName == joesFriend.firstName &&  myFriend.lastName  == joesFriend.lastName)
        } yield myFriend

    println("mutualFriends = " + mutualFriends) // PRINTS: mutualFriends = Sequence(List(Person(Jim,Beam)))
    mutualFriends.foreach(println)              // PRINTS: Person(Jim,Beam)
  }
}

================================================================================
Below are more examples of how to write for() expressions.

object Demo {
  case class Person(name:String, isMale:Boolean, children:Person*)

  def removeDuplicates[A](xs:List[A]):List[A] = {
    if (xs.isEmpty) xs
    else xs.head :: removeDuplicates(xs.tail.filter(x => x != xs.head))
  }

  /************************************
   * main()
   ***********************************/
  def main(args: Array[String]): Unit = {
    val lara = Person("Lara", false)
    val bob  = Person("Bob",  true)
    val julie = Person("Julie", false, lara, bob)
    val persons = List(lara, bob, julie)

    // EXAMPLE 1:
    var result1:List[(String, String)] = persons.filter(p => !p.isMale).flatMap(p => p.children.map(c => (p.name, c.name)))
    println(result1) // PRINTS: List((Julie,Lara), (Julie,Bob))

    // EXAMPLE 2: Identical to EXAMPLE 1 except persons.filter() is replaced with persons.withFilter().
    result1 = persons.withFilter(p => !p.isMale).flatMap(p => p.children.map(c => (p.name, c.name)))
    println(result1) // PRINTS: List((Julie,Lara), (Julie,Bob))

    // EXAMPLE 3: Identical results as EXAMPLE 1 and EXAMPLE 2.
    result1 = for (p <- persons; if !p.isMale; c <- p.children) yield (p.name, c.name)
    println(result1) // PRINTS: List((Julie,Lara), (Julie,Bob))

    // EXAMPLE 4:
    var result2:List[String] = for {
                        p <- persons
                        n = p.name
                        if (n.startsWith("Bo"))
                      } yield n
    println(result2) // PRINTS: List(Bob)

    // EXAMPLE 5:
    // NOTE: The following for() expression generates a result DIFFERENT than EXAMPLE 4.
    var result3:List[Person] = for {
                                     p <- persons
                                     if p.name.startsWith("Bo")
                                   } yield p
    println(result3) // PRINTS: List(Person(Bob,true,WrappedArray()))

    // EXAMPLE 6:
    var result4:List[(Int,String)] = for (x <- List(1,2); y <- List("one","two")) yield (x,y)
    println(result4) // PRINTS: List((1,one), (1,two), (2,one), (2,two))

    // EXAMPLE 7:
    case class Book(title:String, authors:String *)
    val books:List[Book] = List(Book("Structure of Computer Programs", "Abelson", "Sussman"),
                                Book("Principles of Compiler Design", "Aho", "Alfred", "Ullman"),
                                Book("Programming in Modula-2", "Wirth", "Worthless"),
                                Book("ML Programming", "Ullman", "Gookers"),
                                Book("The Java Language Specs", "Joy", "Gosling", "Steele"))
    var result5:List[String] = for (b <- books; a <- b.authors;  if a.startsWith("Gosling")) yield b.title
    println(result5) // PRINTS: List(The Java Language Specs)

    result2 = for (b <- books; if b.title.indexOf("Program") >= 0) yield b.title
    println(result2) // PRINTS: List(Structure of Computer Programs, Programming in Modula-2, ML Programming)

    // This example finds all authors that have written 2 or more books.
    // Unfortunately, it returns the author's name multiple times.
    result2 = for (b1 <- books;      b2 <- books;      if (b1 != b2);
                   a1 <- b1.authors; a2 <- b2.authors; if (a1 == a2)) yield a1
    println(result2) // PRINTS: List(Ullman, Ullman)

    // Here we remove the duplicates from result2.
    result2 = removeDuplicates(result2)
    println(result2) // PRINTS: List(Ullman)
  }
}

================================================================================
