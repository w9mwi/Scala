
A Scala "for expression" can contain the following 3 expressions:

1) Generator/Receiver - The "<-" operator in a for expression separates the generator and
                        the receiver.  The generator appears on the RIGHT SIDE of the "<-"
                        operator, and the receiver appears on the LEFT SIDE of the "<-"
                        operator.  The generator is the collection that the for loop
                        iterates through.  The receiver is basically a "val" that gets
                        assigned the current element of the collection.

                        In the following for expression "people" is the generator and "p" is the receiver.

                        for (p <- people)  // "people" is the GENERATOR, "p" is the RECEIVER.
                          println(s"Person = $p")

                        When a for loop is embedded within another for loop, the for expression
                        will contain multiple generator/receiver pairs.

2) Definition - A definition is basically a "val" declaration contained within a for loop.  For
                each iteration of the for loop, this val gets assigned some pattern of the of
                the collection.  A definition is OPTIONAL in a for expression--it's not required.

3) Filter - A filter is a Boolean expression.  Each element of the collection for which this
            expression is False will NOT be returned by the for expression.  Thus, it acts to
            remove certain elements in the collection from the result returned by the for
            expression.  A filter is OPTIONAL in a for expression--it's not required.

4) yield - "yield" is a Scala keyword that's appears at the tail-end of a for expression.
           The expression that appears after the "yield" keyword determines the result
           returned by for expression, as does the "filter" expression mentioned above.
           The "yield" keyword is OPTIONAL in a for expression--it's not required.

The following code shows examples of the above.  Read comments for details.

object Demo
{
  def main(args: Array[String]): Unit =
  {
    case class Person(name:String, yearBorn:Int)
    val people:List[Person] = List(Person("Jim", 1975), Person("Sue", 1988),
                                   Person("Tom", 1999), Person("Tony", 1944))

    println("PART 1) =====================")
    for (p <- people)  // "people" is the GENERATOR, "p" is the RECEIVER.
      println(s"Person = $p") // PRINTS: Person = Person(Jim,1975)
                              //         Person = Person(Sue,1988)
                              //         Person = Person(Tom,1999)
                              //         Person = Person(Tony,1944)

    println("PART 2) =====================")
    val result:List[Person] =
      for {
        p <- people               // "people" is the GENERATOR, "p" is the RECEIVER
        name = p.name             // DEFINITION
        if (name startsWith "To") // FILTER - Return only people whose names start with "To".
      } yield name                // Return only the name of each element in the people List,
                                  // that wasn't filtered out by the above filter.

    // The Scala API supplies the foreach() method for every collection.  Use the foreach()
    // method to print the result returned by the above for expression.
    result.foreach(println) // PRINTS: Person(Tom,1999)
                            //         Person(Tony, 1944)
  }
}






                For example, in the for expression shown immediately below, any person whose
                name does NOT start with the string "To" is dropped from the result
                based on this if() statement:   if (name startsWith "To")
                        

                        def getTheSquirrel = for { (dog, cat, squirrel) <- getAnimals yield squirrel }

                        A for expression can contain MULTIPLE generator/receiver pairs, like this

                        for {
                              i <- range
                              j <- rangeUntil
                        } {println (s"$i, $j") }



 , as shown in the example below, where
               getAnimals() is a function that rerurns a 3-element tuple, and
               getTheSquirrel() is the defined function which yields the squirrel...

               def getTheSquirrel = for { (dog, cat, squirrel) <- getAnimals yield squirrel }



The Scala compiler translates "for expressions" into
a series of method calls that may include...

foreach()    - Any class that defines this function can be used in a "BASIC FOR LOOP" (which
               does NOT use the "yield" keyword) using a single generator, or multiple generators,
               like this:  for (x <- intList) println(x)
map()        - Any class used in a "for expression" (which uses the "yield" keyword)
               MUST implement the map() function.  If the "for expression" (which uses
               the "yield" keyword) contains MULTIPLE generators, that class MUST
               implement BOTH the map() AND flatMap() functions.
flatMap()    - This function enables a class to work with a "for expression" (which uses
               the "yield" keyword) that implements MULTIPLE generators.  If a "for expression"
               (which uses the "yield" keyword) contains ONLY ONE generator, the class needs
               to implement ONLY the map() function--the flatMap() function won't be called,
               so it's optional.
withFilter() - This method enables a class to work with a filter.

The 4 functions listed immediately above enable a user-defined class to work
with "for expressions" (which use the "yield" keyword).  Scala-defined classes
that work with "for expressions" (which use the "yield" keyword) also implement
those 4 functions.

If you want your class to work well with a for expression (which uses the "yield" keyword),
it should generally implement the 4 functions shown in the following MyCustomClass,
with the corresponding function signatures.

abstract class MyCustomClass[A]
{
  def foreach(func: A => Unit):Unit
  def map[B](func: A => B):MyCustomClass[B]
  def flatMap[B](func: A => MyCustomClass[B]):MyCustomClass[B]
  def withFilter(func: A => Boolean):MyCustomClass[A]
}

================================================================================
This code shows a simple example of how to use a for expression.

object Demo
{
  case class Person(firstName:String, lastName:String)

  def main(args:Array[String]): Unit =
  {
    val states:List[String] = List("Alabama", "Alaska", "Wisconsin", "Wyoming")

    var statesCapitalized:List[String]  = for (x <- states) yield x.toUpperCase
    println(statesCapitalized) // PRINTS:  List(ALABAMA, ALASKA, WISCONSIN, WYOMING)

    statesCapitalized = states.map(_.toUpperCase) // This line generates identical results to the above for expression.
    println(statesCapitalized) // PRINTS:  List(ALABAMA, ALASKA, WISCONSIN, WYOMING)

    // =================================================================

    val people:List[Person] = List(Person("Barney", "Rubble"),
                                   Person("Fred", "Flintstone"),
                                   Person("Betty", "Rubble"))

    val firstNamesStartingWithB:List[String] =
      for {
            p <- people                // This line is the GENERATOR.
            fname = p.firstName        // This line is the DEFINITION.
            if (fname.startsWith("B")) // This line is the FILTER.
          } yield fname.toUpperCase

    println(firstNamesStartingWithB) // PRINTS: List(BARNEY, BETTY)
  }
}

================================================================================

The code sample shown below defines a case class named Sequence, which
implements the four (4) methods mentioned above in MyCustomClass[A].
Those 4 methods will make the Sequence case class work with "for expressions"
(which use the "yield" keyword).  This Sequence class works with generic
types, so it's defined below as Sequence[A], where A is the generic type.

import scala.collection.mutable.ListBuffer
object Demo
{
  case class Person(firstName:String, lastName:String)
  case class Sequence[A](private val initialElems: A*) // A* designates a variable number of args of type A.
  {
    // When this Sequence constructor is called it creates an elems
    // instance, which represents all elements in this Sequence class.
    // EXAMPLE:  As you can call the List constructor like this: List(1, 2, 3),
    //           you can call the Sequence constructor like this: Sequence(1, 2, 3)
    //           The Demo.main() method below calls this Sequence constructor,
    //           where the number of args it gets passed is variable.
    private val elems:ListBuffer[A] = ListBuffer[A]()
    elems ++= initialElems // The ++= operator for the ListBuffer class appends multiple elements.
    // NOTE: "elems ++= initialElems" above could be replaced with:  for { x <- initialElems } elems += x

    /*********************************************************
     * NOTE: This foreach() method enables the main() function
     *       below to implement a for loop on the Sequence
     *       case class, similar to this example, where ints
     *       is a Sequence class:
     *       for (x <- ints) println(x)
     ********************************************************/
    def foreach(block: A => Unit):Unit =
    {
      elems.foreach(block)
    }

    /*********************************************************
     * NOTE: This map() method enables the main() function
     *       below to implement a for loop on the Sequence
     *       case class, similar to this example, where ints
     *       is a Sequence class:
     *       for { x <- ints } yield x*2
     ********************************************************/
    def map[B](func: A=>B):Sequence[B] =
    {
      val listBuf:ListBuffer[B] = elems.map(func)
      // NOTE: The :_* below is the syntax used when calling a constructor, or a method,
      //       that accepts a variable number of arguments.  In this example, since
      //       the Sequence constructor is written to accept a variable number of args,
      //       the :_* syntax must be used with the listBuf collection.
      Sequence(listBuf.toSeq:_*) // Return a new Sequence class where map() was run
                                 // on all elements of the previous Sequence class.
    }

    /*********************************************************
     * NOTE: This flatMap() method enables the main() function
     *       below to implement MULTIPLE GENERATORS within
     *       a for loop on this Sequence case class.
     ********************************************************/
    def flatMap[B](func: A => Sequence[B]):Sequence[B] =
    {
      val resultListBuf:ListBuffer[B] = ListBuffer[B]()

      // NOTE: In Scala the flatMap function calls the following 2 functions, in this order:
      //       1) Calls the map function on every element in the collection, returning a new collection.
      //       2) Calls the flatten function on the result returned by map, returning that result.
      for (listBuf:Sequence[B] <- map(func)) // First map is called.
      {
        for (elem <- listBuf) { resultListBuf += elem }  // This for() loop "flattens" the result returned by map.
      }

      // NOTE: The :_* below is the syntax used when calling a constructor, or a method,
      //       that accepts a variable number of arguments.  In this example, since
      //       the Sequence constructor is written to accept a variable number of args,
      //       the :_* syntax must be used with the resultListBuf collection.
      Sequence(resultListBuf.toSeq:_*) // Return a new Sequence class where flatMap() was
                                       // run on all elements of the previous Sequence class.
    }

    /*********************************************************
     * NOTE: This withFilter() method enables the main()
     *       function below to implement filters within
     *       for loops on this Sequence case class:
     ********************************************************/
    def withFilter(func: A => Boolean):Sequence[A] =
    {
      val listBuf:ListBuffer[A] = elems.filter(func)
      // NOTE: The :_* below is the syntax used when calling a constructor, or a method,
      //       that accepts a variable number of arguments.  In this example, since
      //       the Sequence constructor is written to accept a variable number of args,
      //       the :_* syntax must be used with the listBuf_1 collection.
      Sequence(listBuf.toSeq:_*) // Return a new Sequence class where withFilter() was
      // run on all elements of the previous Sequence class.
    }
  } // END: case class Sequence[A]

  /*********************************************************
   *
   ********************************************************/
  def main(args:Array[String]): Unit =
  {
    // The following 2 lines call the above Sequence constructor by passing it a variable
    // number of arguments.  The above Sequence constructor can be called by passing to it
    // any data type, such as Ints.  EXAMPLE:  val seqInts = Sequence(1, 2, 3, 4)
    val myFriends:Sequence[Person]   = Sequence(Person("Jack",   "Daniels"),  Person("Johnny", "Walker"), Person("Jim", "Beam"))
    val joesFriends:Sequence[Person] = Sequence(Person("Joseph", "Schlitz"),  Person("George", "Jones"),  Person("Jim", "Beam"))

    // The following for loop works with MULTIPLE GENERATORS
    // because the Sequence.flatMap() method is defined above.
    val mutualFriends:Sequence[Person] =
    for {
          myFriend   <- myFriends   // This is a GENERATOR.
          joesFriend <- joesFriends // This is another GENERATOR.
          if (myFriend.firstName == joesFriend.firstName &&  myFriend.lastName  == joesFriend.lastName)
        } yield myFriend

    println("mutualFriends = " + mutualFriends) // PRINTS: mutualFriends = Sequence(List(Person(Jim,Beam)))
    mutualFriends.foreach(println)              // PRINTS: Person(Jim,Beam)
  }
}

================================================================================
Below are more examples of how to write for() expressions.

object Demo {
  case class Person(name:String, isMale:Boolean, children:Person*)

  def removeDuplicates[A](xs:List[A]):List[A] = {
    if (xs.isEmpty) xs
    else xs.head :: removeDuplicates(xs.tail.filter(x => x != xs.head))
  }

  /************************************
   * main()
   ***********************************/
  def main(args: Array[String]): Unit = {
    val lara = Person("Lara", false)
    val bob  = Person("Bob",  true)
    val julie = Person("Julie", false, lara, bob)
    val persons = List(lara, bob, julie)

    // EXAMPLE 1:
    var result1:List[(String, String)] = persons.filter(p => !p.isMale).flatMap(p => p.children.map(c => (p.name, c.name)))
    println(result1) // PRINTS: List((Julie,Lara), (Julie,Bob))

    // EXAMPLE 2: Identical to EXAMPLE 1 except persons.filter() is replaced with persons.withFilter().
    result1 = persons.withFilter(p => !p.isMale).flatMap(p => p.children.map(c => (p.name, c.name)))
    println(result1) // PRINTS: List((Julie,Lara), (Julie,Bob))

    // EXAMPLE 3: Identical results as EXAMPLE 1 and EXAMPLE 2.
    result1 = for (p <- persons; if !p.isMale; c <- p.children) yield (p.name, c.name)
    println(result1) // PRINTS: List((Julie,Lara), (Julie,Bob))

    // EXAMPLE 4:
    var result2:List[String] = for {
                        p <- persons
                        n = p.name
                        if (n.startsWith("Bo"))
                      } yield n
    println(result2) // PRINTS: List(Bob)

    // EXAMPLE 5:
    // NOTE: The following for() expression generates a result DIFFERENT than EXAMPLE 4.
    var result3:List[Person] = for {
                                     p <- persons
                                     if p.name.startsWith("Bo")
                                   } yield p
    println(result3) // PRINTS: List(Person(Bob,true,WrappedArray()))

    // EXAMPLE 6:
    var result4:List[(Int,String)] = for (x <- List(1,2); y <- List("one","two")) yield (x,y)
    println(result4) // PRINTS: List((1,one), (1,two), (2,one), (2,two))

    // EXAMPLE 7:
    case class Book(title:String, authors:String *)
    val books:List[Book] = List(Book("Structure of Computer Programs", "Abelson", "Sussman"),
                                Book("Principles of Compiler Design", "Aho", "Alfred", "Ullman"),
                                Book("Programming in Modula-2", "Wirth", "Worthless"),
                                Book("ML Programming", "Ullman", "Gookers"),
                                Book("The Java Language Specs", "Joy", "Gosling", "Steele"))
    var result5:List[String] = for (b <- books; a <- b.authors;  if a.startsWith("Gosling")) yield b.title
    println(result5) // PRINTS: List(The Java Language Specs)

    result2 = for (b <- books; if b.title.indexOf("Program") >= 0) yield b.title
    println(result2) // PRINTS: List(Structure of Computer Programs, Programming in Modula-2, ML Programming)

    // This example finds all authors that have written 2 or more books.
    // Unfortunately, it returns the author's name multiple times.
    result2 = for (b1 <- books;      b2 <- books;      if (b1 != b2);
                   a1 <- b1.authors; a2 <- b2.authors; if (a1 == a2)) yield a1
    println(result2) // PRINTS: List(Ullman, Ullman)

    // Here we remove the duplicates from result2.
    result2 = removeDuplicates(result2)
    println(result2) // PRINTS: List(Ullman)
  }
}

================================================================================
