object Demo
{
  def main(args: Array[String]): Unit =
  {
    println("factorial(11) = " + factorial(12))
  }

  /**
    * THIS IS A RECURSIVE FUNCTION.
    */
  def factorial(x:BigInt):BigInt =
  {
    if (x <= 1) { return(1) }
    else { x * factorial(x-1) }
  }
}
// =================================================================
// =================================================================
object Demo
{
  def main(args: Array[String]) =
  {
    val tom:List[Int] = List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
    // The following 3 println statements print identical results.
    println("sum_1() = " + sum_1(tom))
    println("sum_2() = " + sum_2(tom))
    println("tom.sum = " + tom.sum)

    // The following 2 println statements print identical results.
    println("tom.map(x => x*2) = " + tom.map(x => x*2))
    println("tom.map(_*2)      = " + tom.map(_*2))
  }

  /**
    * This sum_1() function uses imperative programming, and
    * returns the same result as the sum_2() function below.
    */
  def sum_1(ints:List[Int]):Int =
  {
    var sum = 0
    for (number <- ints)
    {
      sum += number
    }
    sum
  }

  /**
    * THIS IS A RECURSIVE FUNCTION!
    * This sum_2() function uses functional programming, and
    * returns the same result as the sum_1() function above.
    */
  def sum_2(list:List[Int]):Int = list match
  {
    // NOTE: Both the x, and the tail, names below could
    //       be changed to any name you wish.
    case Nil => 0
    case x :: tail => x + sum_2(tail)
  }
}
// =================================================================
// =================================================================
// NOTE: The following 2 lines are examples of FUNCTION LITERALS...
//       (a:Int, b:Int) => a+b
//       (x:Double)     => x*x
object Demo
{
  // The following 2 vals (add and square) are initialized as functions.
  // The text to the right of the '=' sign would be considered a function
  // literal, if that text stood alone and was NOT assigned to a val or var.
  val add    = (a:Int, b:Int) => a+b
  val square = (x:Double)     => x*x

  // The following 2 functions have behavior identical
  // to the 2 corresponding function literals above.
  def add2(a:Double, b:Double):Double = a+b
  def square2(x: Double):Double       = x*x

  def main(args: Array[String]): Unit =
  {
    println("add(4,5)  = " + add(4,5))
    println("square(7) = " + square(7))

    println("add2(4,5)  = " + add2(4,5))
    println("square2(7) = " + square2(7))
  }
}
// =================================================================
// =================================================================
A HIGHER-ORDER FUNCTION is a function that operates on other functions.
In other words, a HIGHER-ORDER FUNCTION is a function that gets passed
a function as a parameter, and/or returns a function.  The following
code defines two functions (compose and compose2, both of which have
identical behavior) that are higher-order functions--as they both
get passed functions as parameters, and they both return a function.
Both compose and compose2 return the function f(g(x))...

object Demo
{
  val plus5   = (x:Double) => x+5.0  // EQUIVALENT TO:  def plus5(x:Double):Double = x+5.0
  val square  = (x:Double) => x*x    // EQUIVALENT TO:  def square(x:Double):Double = x*x
  val compose = (f:Double  => Double, g:Double => Double, x:Double) => f(g(x))

  // The following compose2() function gets passed 2 functions as params (f and g),
  // and returns a function that gets passed a Double and returns a Double.
  def compose2(f:Double => Double, g:Double => Double):Double => Double =
  {
    x => f(g(x)) // This is the returned function.
  }

  def main(args: Array[String])
  {
    val a:(Double => Double) = compose2(plus5, square) // EQUIVALENT TO:  val a  = compose2(plus5, square)
    val b                    = compose2(square, plus5) // EQUIVALENT TO:  val b:(Double => Double) = compose2(square, plus5)

    println("a(3) = " + a(3)) // PRINTS: a(3) = 14.0
    println("b(3) = " + b(3)) // PRINTS: b(3) = 64.0

    // The following 2 calls to compose() are identical
    // to the above two function calls a(3) and b(3)...
    println("compose(plus5,  square, 3) = " + compose(plus5, square, 3)) // PRINTS: compose(plus5,  square, 3) = 14.0
    println("compose(square, plus5,  3) = " + compose(square, plus5, 3)) // PRINTS: compose(square, plus5,  3) = 64.0
  }
}

// =================================================================
// =================================================================
The following code contains a function named "funcOfGunc", which is
a parametric function (not type dependent) that's equivalent to the
function named "compose2" in the FunctionFGX program immediately above.
(Taken from Page 156 of the book.)
object Demo
{
  def main(args:Array[String]): Unit =
  {
    val plus5  = (x:Double) => x+5
    val square = (x:Double) => x*x

    // First, test the plus5 and square functions defined above...
    println("plus5(3)  = " + plus5(3))  // Prints: plus5(3)  = 8.0
    println("square(3) = " + square(3)) // Prints: square(3) = 9.0

    // Next, initialize myFunc so it points to funcOfGunc...
    val myFunc:(Double=>Double) = funcOfGunc(plus5, square)

    // Finally, call myFunc with a numeric value and print the result...
    var result:Double = myFunc(7.0D)
    println("result = " + result) // Prints: result = 54.0  (NOTE: 54.0 = 5.0+(7.0*7.0))

    // Instead of creating an interim myFunc val above, we can call funcOfGunc
    // here in one step by calling it as a curried function...
    result = funcOfGunc(plus5, square)(7.0D)
    println("result = " + result) // Prints: result = 54.0  (NOTE: 54.0 = 5.0+(7.0*7.0))
  }

  def funcOfGunc[A,B,C](func:(B=>A), gunc:(C=>B)):(C=>A) = { x=>func(gunc(x)) }
}

==============================================================================

object Demo
{
  type IntDoubleTuple = (Int, Double)

  /**
    * @param blockOfCode -
    * @tparam A - The A type in the timer() function below is really the IntDoubleTuple
    *             type defined above.  If you replace all three A references in the timer()
    *             function below with references to IntDoubleTuple, the code still works.
    *
    * @return the type A in this example is the IntDoubleTuple type defined above.
    */
  def timer[A](blockOfCode: => A) =
  {
    val startTime:Long = System.nanoTime
    // When the following line of code gets called, all code contained in the blockOfCode param
    // passed to this timer() function executes, including the Thread.sleep(1000) method.  The
    // value returned to codeBlock is the single Int value 42 returned by the blockOfCode parameter.
    val codeBlock:A = blockOfCode

    // Even though codeBlock is of type A (the IntDoubleTuple type defined above),
    // codeBlock contains ONLY a single Int value, which is the Int value 42
    // returned by the blockOfCode parameter.  THAT'S WEIRD!...  Because if you
    // try to access codeBlock._1 or codeBlock._2, you'll get a compile error!
    println("codeBlock = " + codeBlock) // PRINTS: codeBlock = 42

    val stopTime:Long  = System.nanoTime
    val delta:Long     = stopTime - startTime
    (codeBlock, delta / 1000000D)  // Returns the tuple (Int, Double)
  }

  def main(args:Array[String]): Unit =
  {
    // Here, we pass a block of code as a parameter to the timer() function defined above.
    // The block of code is everything contained between the {} braces...
    val resultTuple:IntDoubleTuple = timer { Thread.sleep(1000); 42}

    // The following line prints this:  resultTuple._1 = 42, resultTuple._2 = 1012.724867
    println("resultTuple._1 = " + resultTuple._1 + ", resultTuple._2 = " + resultTuple._2)
  }
}
