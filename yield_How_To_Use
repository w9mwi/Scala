===========================================================================
  A Scala for comprehension can contain the following 3 expressions...
  
  1) Generators - Every for comprehension begins with a generator.  Multiple generators are possible.
  2) Definitions - A definition binds the pattern on the left with the expression on the right.
  3) Filters
  
  Here's an example:
  for {
        p <- people                 // GENERATOR
        fname = p.firstName         // DEFINITION - Note the a val/var keyword isn't used in a for comprehension.
        if (fname.startsWith("B"))  // FILTER - Must have a boolean value, so an if() statement is often used.
      } yield fname.toUpperCase
Here is a Scala code example...
===========================================================================
object Demo
{
  case class Person(firstName:String, lastName:String)

  def main(args:Array[String]): Unit =
  {
    val people:List[Person] = List(Person("Barney", "Rubble"), Person("Fred", "Flintstone"), Person("Betty", "Rubble"))
    val namesStartingWithB:List[String] = for
                                          {
                                            p <- people
                                            fname = p.firstName
                                            if (fname.startsWith("B"))
                                          } yield fname.toUpperCase
    println(namesStartingWithB) // PRINTS: List(BARNEY, BETTY)
  }
}
===========================================================================
Scala for loops are based on mathematical set comprehensions.  They are
a way to filter, transform, and combine lists.
===========================================================================
If you want a custom data type (aka, a custom class) to wotk with a for
comprehension, it should contain the following functions...

1) A foreach() method so it allows "for loops".
2) A map() method so it can be used as a generator in for comprehensions.
3) A flatMap() method allows the data type (class) to be used with multiple generators.
4) A withFilter() method allows the filter expression as an if() statement within the for comprehension.

If you want your custom class (data type) to work well with for comrehensions, it
doesn't require all 4 of the above methods, but it will work very well if it does.
Here's an abstract class example definition of a class that will work with for
comprehensions...

abstract class CustomClass[A]
{
  def map[B](func: A => B):CustomClass[B]
  def flatMap[B](func: A => CustomClass[B]):CustomClass[B]
  def withFilter(func: A => Boolean):CustomClass[A]
  def foreach(func: A => Unit):Unit
}



===========================================================================

// ----------------------------------------------------------
// ----------------------------------------------------------
// for() loop examples that return a "yield" value...
// In Scala, yield is part of for() loop comprehensions.
// For each iteration of your for loop, yield generates a value
// which will be remembered.  It's like the for loop has a buffer
// you canâ€™t see, and for each iteration of your for loop another
// item is added to that buffer.  When your for loop finishes
// running, it will return this collection of all the yielded
// values.  The type of the collection that is returned is the
// same type that you were iterating over, so a Map yields a
// Map, a List yields a List, and so on.
//
// Also, note that the initial collection is not changed; the
// for/yield construct creates a new collection according to
// the algorithm you specify.
//
// To understand more about how for() loops and yield work, SEE:
// https://alvinalexander.com/scala/scala-for-loops-foreach-how-to-translated-by-compiler
// *******************************************************************
object Demo
{
  def main(args: Array[String])
  {
    // NOTE: To determine the data type of numList below. using the
    //       IntelliJ IDE, place the cursor on the text numList, then
    //       press both the 'Alt' and '=' keys simultaneously.  Doing
    //       so reveals the data type of numList is:  List[Int]
    val numList = List(1, 2, 3, 4, 5)

    // The following for() loop will yield a List[Int] containing all
    // numbers in numList multiplied by 10.  This result will then
    // get set into the val result.
    val result = for (x <- numList) yield (x * 10)
    result.foreach(println)
  }
}
// *******************************************************************
object Demo
{
  def main(args: Array[String])
  {
    // NOTE: To determine the data type of numList below. using the
    //       IntelliJ IDE, place the cursor on the text numList, then
    //       press both the 'Alt' and '=' keys simultaneously.  Doing
    //       so reveals the data type of numList is:  List[Int]
    val numList = List(1,2,3,4,5,6,7,8,9,10);

    // The following for() loop will yield a List[Int] containing all
    // numbers in numList EXCEPT 3, 8, 9, and 10.  This result will
    // then get set into the val retVal.
    val retVal = for { number <- numList if number != 3; if number < 8 } yield number

    // Print all numbers in retVal...
    for (number <- retVal)
    {
      println(number);
    }

    // The following line of code does exactly the same as the
    // above for() loop--it prints all numbers in retVal.
    retVal.foreach(println)
  }
}
// *******************************************************************
object Demo
{
  def main(args: Array[String])
  {
    val fruit = Vector("apple", "banana", "lime", "orange")

    // Convert all fruit names to uppercase, and print them.
    val ucFruits = for (fruitName <- fruit) yield fruitName.toUpperCase
    ucFruits.foreach(println)

    // For each fruit, create a tuple containing its name and name length.
    // NOTE: The fruitAndLength data type is:  Vector[(String, Int)]
    val fruitAndLength = for (f <- fruit) yield (f, f.length)
    println(fruitAndLength.mkString)

    // Print each fruit name AND its Vector index.
    for ((name, index) <- fruit.zipWithIndex) { println(s"index = $index, name = $name"); }

    // Print the fruit having a Vector index = 0
    println(fruit(0))
  }
}
// *******************************************************************
object Demo
{
  def main(args: Array[String]): Unit =
  {
    // NOTE: Each "for loop"/"yield" pair below returns an IndexedSeq data type.
    //       Therefore, both "for loop"/"yield" pairs coupled together return a
    //       data type of:  IndexedSeq[IndexedSeq[Int]]
    val multiplicationTable:IndexedSeq[IndexedSeq[Int]] =
        for (idx <- 0 until 10) yield
        {
          {
            for (jdx <- 0 until 10) yield {idx * jdx}
          }
        }
    println("7 X 9 = " + multiplicationTable(7)(9)) // Prints: 7 X 9 = 63
    println("9 X 8 = " + multiplicationTable(9)(8)) // Prints: 9 X 8 = 72

    multiplicationTable.foreach(println)
  }
}
// *******************************************************************
// FROM PAGE 195
object Demo
{
  def main(args: Array[String]): Unit =
  {
    val values:Array[Double]  = Array(34.8, 49.1, 99.7)
    val weights:Array[Double] = Array(16.4, 7.8,  63.0)

    val result:Double = weightedAverage(values, weights)
    println("The result returned by weightedAverage() = " + result)
  }

  def weightedAverage(values:Array[Double], weights:Array[Double]): Double =
  {
    // If any of the following 3 calls to the require() method fail
    // to meet the specified conditions, an IllegalArgumentException
    // is thrown in the console window, along with the corresponding
    // error message.
    require(values.length == weights.length, // If values.length does NOT equal weights.length, this message prints...
            "FAIL: The 'values' Array length doesn't equal the 'weights' Array length.")

    require(weights.length > 0, // If weights.length is NOT > 0, this message prints...
            "FAIL: The 'weights' Array length must be greater than zero.")

    require(weights.sum != 0, // If weights.sum equals 0, this message prints...
            "FAIL: The sum of all 'weights' cannot equal zero.")


    val initialResult = (for ((v, w) <- values.zip(weights)) yield v*w).sum/weights.sum
    // The line of code directly above is broken up into the following 3 lines of
    // code below, in order to make the above line of code easier to understand.
    val zippedValuesAndWeights:Array[(Double, Double)] = values.zip(weights)
    val forLoopResult:Array[Double]                    = for ((v,w) <- zippedValuesAndWeights) yield v*w
    val finalResult:Double                             = forLoopResult.sum / weights.sum

    println("initialResult = " + initialResult + ",  finalResult = " + finalResult)
    finalResult // finalResult is returned here.
  }
}
// *******************************************************************
object Demo
{
  case class Person(firstName: String, lastName: String)

  def main(args:Array[String]):Unit =
  {
    val people = List(Person("barney", "rubble"),
                      Person("fred", "flintstone"))

    val namesStartingWithB = for {
      p <- people                // generator
      fname = p.firstName        // definition
      if (fname.startsWith("b")) // filter
    } yield fname.toUpperCase

    namesStartingWithB.foreach(println) // Prints: BARNEY
  }
}
// *******************************************************************

// NOTE: In the code shown below, creating the Sequence.foreach() method
//       (in the Sequence case class) enables the following for() loop,
//       AND the following foreach() method to work:
//       for (tom <- strings) { println(tom) } // Prints all elements of the strings ArrayBuffer.
//       strings.foreach(println) // Prints all elements of the strings ArrayBuffer.
//
//       Creating the Sequence.map() method (in the Sequence case class) enables
//       the following for() expression to work with the "yield" keyword:
//       val doubleInts = for { idx <- ints } yield idx*2
//
//       Creating the Sequence.withFilter() method (in the Sequence case class) enables
//       the following for() expression to work with the "if idx > 3.0F" statement:
//       val doubleFloatsGreaterThan5 = for { idx <- floats; if idx > 3.0F } yield idx*2
//
//       To sum up the lesson learned by the below code:
//       1) A for() loop generator (i.e., "for (p <- peeps)") works because
//          a foreach() method is defined in the peeps collection.
//       2) A for() loop's "yield" keyword works because the collection
//          being traversed by the for() loop contains the map() method.
//       3) An if() statement embedded within a for() loop comprehension
//          works because the collection being traversed by the for()
//          loop contains the withFilter() method.

import scala.collection.mutable.ArrayBuffer
object Demo
{
  // NOTE: The asterisk char (*) in the arguments list
  //       designates a variable number of arguments.
  case class Sequence[T](initialElems: T*)
  {
    private val elems = ArrayBuffer[T]()

    // Initialize the elems val with all params passed
    // to this Sequence case class.
    elems ++= initialElems

    // The following commented-out for() loop + yield statement is
    // equivalent to this single line of code above:  elems ++= initialElems
    //  for
    //  {
    //    e <- initialElems
    //  } yield elems += e

    def foreach(block: T => Unit): Unit =
    {
      elems.foreach(block)
    }

    def map[U](f: T => U): Sequence[U] =
    {
      val tuMap:ArrayBuffer[U] = elems.map(f)
      Sequence(tuMap: _*) // _* makes a collection work with a variable number of arguments.
    }

    def withFilter(p: T => Boolean): Sequence[T] =
    {
      val tmpArrayBuffer = elems.filter(p)
      Sequence(tmpArrayBuffer: _*) // _* makes a collection work with a variable number of arguments.
    }
  }

  def main(args:Array[String]):Unit =
  {
    val chars   = Sequence('A', 'B', 'C', 'X', 'Y', 'Z')
    val floats  = Sequence(1.0F, 2.0F, 3.0F, 4.0F, 5.0F)
    val ints    = Sequence(1, 2, 3, 4, 5)
    val strings = Sequence("Manitowoc", "Wisconsin", "USA")

    println(chars);  println(floats);  println(ints);  println(strings);

    // The following 2 lines of code won't work unless the above
    // Sequence case class implements the foreach() method.
    strings.foreach(println) // Prints all elements of the strings ArrayBuffer.
    for (tom <- strings) { println(tom) } // Prints all elements of the strings ArrayBuffer.

    // The following "yield" statement won't work unless the above
    // Sequence case class implements the map() method.
    val doubleInts = for { idx <- ints } yield idx*2
    doubleInts.foreach(println);  println();
    // The following "if idx > 3.0F" statement won't work unless the above
    // Sequence case class implements the withFilter() method.
    val doubleFloatsGreaterThan3 = for { idx <- floats; if idx > 3.0F } yield idx*2
    doubleFloatsGreaterThan3.foreach(println)
  }
}
===========================================================================

===========================================================================
===========================================================================
To see another example of how to use the Scala yield keyword,
search the following Git page for "yield"...
--> https://github.com/w9mwi/Scala/blob/master/Maps
