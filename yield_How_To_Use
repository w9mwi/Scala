// ----------------------------------------------------------
// ----------------------------------------------------------
// for() loop examples that return a "yield" value...
// In Scala, yield is part of for() loop comprehensions.
// For each iteration of your for loop, yield generates a value
// which will be remembered.  It's like the for loop has a buffer
// you canâ€™t see, and for each iteration of your for loop another
// item is added to that buffer.  When your for loop finishes
// running, it will return this collection of all the yielded
// values.  The type of the collection that is returned is the
// same type that you were iterating over, so a Map yields a
// Map, a List yields a List, and so on.
//
// Also, note that the initial collection is not changed; the
// for/yield construct creates a new collection according to
// the algorithm you specify.
//
// To understand more about how for() loops and yield work, SEE:
// https://alvinalexander.com/scala/scala-for-loops-foreach-how-to-translated-by-compiler
// *******************************************************************
object Demo
{
  def main(args: Array[String])
  {
    // NOTE: To determine the data type of numList below. using the
    //       IntelliJ IDE, place the cursor on the text numList, then
    //       press both the 'Alt' and '=' keys simultaneously.  Doing
    //       so reveals the data type of numList is:  List[Int]
    val numList = List(1, 2, 3, 4, 5)

    // The following for() loop will yield a List[Int] containing all
    // numbers in numList multiplied by 10.  This result will then
    // get set into the val result.
    val result = for (x <- numList) yield (x * 10)
    result.foreach(println)
  }
}
// *******************************************************************
object Demo
{
  def main(args: Array[String])
  {
    // NOTE: To determine the data type of numList below. using the
    //       IntelliJ IDE, place the cursor on the text numList, then
    //       press both the 'Alt' and '=' keys simultaneously.  Doing
    //       so reveals the data type of numList is:  List[Int]
    val numList = List(1,2,3,4,5,6,7,8,9,10);

    // The following for() loop will yield a List[Int] containing all
    // numbers in numList EXCEPT 3, 8, 9, and 10.  This result will
    // then get set into the val retVal.
    val retVal = for { number <- numList if number != 3; if number < 8 } yield number

    // Print all numbers in retVal...
    for (number <- retVal)
    {
      println(number);
    }

    // The following line of code does exactly the same as the
    // above for() loop--it prints all numbers in retVal.
    retVal.foreach(println)
  }
}
// *******************************************************************
object Demo
{
  def main(args: Array[String])
  {
    val fruit = Vector("apple", "banana", "lime", "orange")

    // Convert all fruit names to uppercase, and print them.
    val ucFruits = for (fruitName <- fruit) yield fruitName.toUpperCase
    ucFruits.foreach(println)

    // For each fruit, create a tuple containing its name and name length.
    // NOTE: The fruitAndLength data type is:  Vector[(String, Int)]
    val fruitAndLength = for (f <- fruit) yield (f, f.length)
    println(fruitAndLength.mkString)

    // Print each fruit name AND its Vector index.
    for ((name, index) <- fruit.zipWithIndex) { println(s"index = $index, name = $name"); }

    // Print the fruit having a Vector index = 0
    println(fruit(0))
  }
}
// *******************************************************************
object Demo
{
  def main(args: Array[String]): Unit =
  {
    // NOTE: Each "for loop"/"yield" pair below returns an IndexedSeq data type.
    //       Therefore, both "for loop"/"yield" pairs coupled together return a
    //       data type of:  IndexedSeq[IndexedSeq[Int]]
    val multiplicationTable:IndexedSeq[IndexedSeq[Int]] =
        for (idx <- 0 until 10) yield
        {
          {
            for (jdx <- 0 until 10) yield {idx * jdx}
          }
        }
    println("7 X 9 = " + multiplicationTable(7)(9)) // Prints: 7 X 9 = 63
    println("9 X 8 = " + multiplicationTable(9)(8)) // Prints: 9 X 8 = 72

    multiplicationTable.foreach(println)
  }
}
// *******************************************************************
// FROM PAGE 195
object Demo
{
  def main(args: Array[String]): Unit =
  {
    val values:Array[Double]  = Array(34.8, 49.1, 99.7)
    val weights:Array[Double] = Array(16.4, 7.8,  63.0)

    val result:Double = weightedAverage(values, weights)
    println("The result returned by weightedAverage() = " + result)
  }

  def weightedAverage(values:Array[Double], weights:Array[Double]): Double =
  {
    // If any of the following 3 calls to the require() method fail
    // to meet the specified conditions, an IllegalArgumentException
    // is thrown in the console window, along with the corresponding
    // error message.
    require(values.length == weights.length, // If values.length does NOT equal weights.length, this message prints...
            "FAIL: The 'values' Array length doesn't equal the 'weights' Array length.")

    require(weights.length > 0, // If weights.length is NOT > 0, this message prints...
            "FAIL: The 'weights' Array length must be greater than zero.")

    require(weights.sum != 0, // If weights.sum equals 0, this message prints...
            "FAIL: The sum of all 'weights' cannot equal zero.")


    val initialResult = (for ((v, w) <- values.zip(weights)) yield v*w).sum/weights.sum
    // The line of code directly above is broken up into the following 3 lines of
    // code below, in order to make the above line of code easier to understand.
    val zippedValuesAndWeights:Array[(Double, Double)] = values.zip(weights)
    val forLoopResult:Array[Double]                    = for ((v,w) <- zippedValuesAndWeights) yield v*w
    val finalResult:Double                             = forLoopResult.sum / weights.sum

    println("initialResult = " + initialResult + ",  finalResult = " + finalResult)
    finalResult // finalResult is returned here.
  }
}
// *******************************************************************
object Demo
{
  case class Person(firstName: String, lastName: String)

  def main(args:Array[String]):Unit =
  {
    val people = List(Person("barney", "rubble"),
                      Person("fred", "flintstone"))

    val namesStartingWithB = for {
      p <- people                // generator
      fname = p.firstName        // definition
      if (fname.startsWith("b")) // filter
    } yield fname.toUpperCase

    namesStartingWithB.foreach(println) // Prints: BARNEY
  }
}
