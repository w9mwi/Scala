
A parametric method is a method defined to accept any data type that applies
to the method's algorithm.  For example, a single method named add() can be
made to work with 3 different data types (Int, Float, Double) when the
add() method is written to accept a parametric data type.

Parametric data types are often referred to as generic data types.
Therefore...

PARAMETRIC DATA TYPE = GENERIC DATA TYPE

The following code sample defines the add() method with its argument as
a generic data type so it works with Scala's Numeric.plus() method.  The
add() method specifies the data type as a type 'A', which designates any
data type that works with the Numeric.plus() method.

IMPORTANT: Only Scala methods (which are written using the "def" keyword)
           can implement paramateric data types.  Scala functions (which
           are NOT written using the "def" keyword) can't be written to use
           paramateric data types.  To understand the difference between
           a Scala method and a Scala function, read this section:
           https://github.com/w9mwi/Scala/blob/master/Function_vs_Method

object Demo
{
  // The following add()() method is defined with two (2) argument lists,
  // which usually means it's a curried method.  However, because its
  // second  argument list contains an implicit argument, it's NOT a
  // curried method.  The Scala compiler automatically invokes the
  // implicit parameter when the add()() method is called with only
  // one of its two argument lists.
  //
  // This code shows how to define an add method so it will work with
  // different data types (Byte, Int, Long, Float, Double).  The returned
  // data type will be "upcast" to the highest of the two data types passed
  // to the method.
  def add[A](x:A, y:A)(implicit numeric:Numeric[A]):A = numeric.plus(x, y)

  def main(args:Array[String]): Unit =
  {
    val myByte:Byte     = 123
    val myInt:Int       = 456
    val myLong:Long     = 999999999L
    val myFloat:Float   = 876.543F
    val myDouble:Double = 1234567.890123D

    println("add(myByte, myInt)     = " + add(myByte, myInt))     // PRINTS: add(myByte, myInt)     = 579
    println("add(myInt, myLong)     = " + add(myInt, myLong))     // PRINTS: add(myInt, myLong)     = 1000000455
    println("add(myLong, myFloat)   = " + add(myLong, myFloat))   // PRINTS: add(myLong, myFloat)   = 1.0000009E9
    println("add(myFloat, myDouble) = " + add(myFloat, myDouble)) // PRINTS: add(myFloat, myDouble) = 1235444.433152785
    println("add(myByte, myDouble)  = " + add(myByte, myDouble))  // PRINTS: add(myByte, myDouble)  = 1234690.890123
    println("add(myInt, myFloat)    = " + add(myInt, myFloat))    // PRINTS: add(myInt, myFloat)    = 1332.543
  }
}

========================================================================================

In the sample code below, we make 4 different methods work with multiple data
types by declaring them as parametric methods.

object Demo
{
  def main(args:Array[String]): Unit =
  {
    println(myMethod('X'))           // PRINTS: X
    println(myMethod("My string"))   // PRINTS: My string
    println(myMethod(123.4F))        // PRINTS: 123.4
    println(myMethod(987.6D))        // PRINTS: 987.6

    println(makeTuple(987.6D, 123.4F)) // PRINTS: (987.6,123.4)
    println(makeTuple('A', "zip"))     // PRINTS: (A,zip)

    println(makeThreeElementList('X', 'Y', 'Z'))        // PRINTS: List(X, Y, Z)
    println(makeThreeElementList("Pop", "Stop", "Top")) // PRINTS: List(Pop, Stop, Top)

    val intList:List[Int] = List(1, 2, 3, 4, 5, 6)
    val result_1:Int = ourFold(intList, 0)(_+_)
    println("result_1 = " + result_1) // PRINTS: result_1 = 21

    val stringList:List[String] = List("A", "B", "C")
    val result_2:String = ourFold(stringList, "D")(_ + "" + _)
    println("result_2 = " + result_2) // PRINTS: result_2 = ABCD
  }

  /**
   * This is a RECURSIVE, CURRIED METHOD.  The List passed to this method can
   * be of any data type that works with the '+' operator such as Int, Float, String,
   * etc.  The data type must work with the '+' operator because when this ourFold()
   * method gets called (by the main() method) the 'func' parameter passed to
   * it uses the '+' operator.  Therefore, both operands used by the '+' operator
   * must be of the same data type.
   */
  def ourFold[A](list:List[A], base:A)(func:(A,A) => A):A =
  {
    // The following if() statement is used for testing/debugging.
    if (!list.isEmpty) {
      val result:A = func(list.head, base)
      if (result.isInstanceOf[Int])
        println(s"base = $base, value = ${result.asInstanceOf[Int]}")
    }

    if (list.isEmpty)
      base
    else {
      // val intList in the main() method above is initialized to:
      // List(1, 2, 3, 4, 5, 6)
      // Therefore, the one line of code in this else statement gets
      // executed recursively 5 consecutive times, like this:
      // func(1, ourFold(List(2,3,4,5,6), 0)(func)
      // func(2, ourFold(List(3,4,5,6),   0)(func)
      // func(3, ourFold(List(4,5,6),     0)(func)
      // func(4, ourFold(List(5,6),       0)(func)
      // func(5, ourFold(List(6),         0)(func)
      func(list.head, ourFold(list.tail, base)(func))
    }
  }

  // myMethod() below does nothing but return the same value (and data type) it was passed.
  // Since myMethod uses a parametric type, it will work with ALL data types.
  def myMethod[T](t:T):T = t

  // The below makeTuple() method takes two parameters (one of type A, one of type B),
  // and returns a tuple of type (A, B).
  def makeTuple[A,B](a:A, b:B):(A, B) = (a, b)

  // The below makeThreeElementList() method takes three parameters all of type A,
  // and returns a List of type A, containing the 3 values passed to this method.
  def makeThreeElementList[A](a1:A, a2:A, a3:A):List[A] = List(a1, a2, a3)
}
