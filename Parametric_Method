
A PARAMETRIC METHOD is defined to accept any data type that applies to
the method's algorithm.  For example, instead of defining 3 different
add() methods to work with data types Int, Float, and Double, you can
write a single add() method as a parametric method, so it'll work with
all 3 of those data types.

The following code sample shows this by defining the add() method so it calls
Scala's Numeric.plus() method via a an implicit parameter.  The add method
specifies the data type as a type 'A', which designates any data type that
works with the Numeric.plus() method.

IMPORTANT: Only Scala methods can use paramaterized data types.  Scala functions
           CAN'T be written to use paramaterized data types.  To distinguish a
           a method from a function, look for the following...
      
           A Scala function is NEVER defined using the "def" keyword.  If the
           "def" keyword is used, it is a method, not a function.  A Scala
           function's signature ALWAYS contains the rocket symbol (=>), and
           looks similar to this:
           String=>Int   (Takes a String argument, and returns an Int value.)

           A Scala method is ALWAYS defined using the "def" keyword.  A Scala 
           method's signature NEVER contains the rocket symbol (=>), and looks
           similar to this:
           (String):Int   (Takes a String argument, and returns an Int value.)

object Demo
{
  // The following add()() method is defined with two (2) parameter lists,
  // which usually means it's a curried method.  However, because its
  // second  parameter list contains an implicit argument, it's NOT a
  // curried method.  The Scala compiler automatically invokes the
  // implicit parameter when the add()() method is called with only
  // one of its two parameter lists.
  //
  // This code shows how to define an add method so it will work with
  // different data types (Byte, Int, Long, Float, Double).  The returned
  // data type will be "upcast" to the highest of the two data types passed
  // to the method.
  def add[A](x:A, y:A)(implicit numeric:Numeric[A]):A = numeric.plus(x, y)

  def main(args:Array[String]): Unit =
  {
    val myByte:Byte     = 123
    val myInt:Int       = 456
    val myLong:Long     = 999999999L
    val myFloat:Float   = 876.543F
    val myDouble:Double = 1234567.890123D

    println("add(myByte, myInt)     = " + add(myByte, myInt))     // PRINTS: add(myByte, myInt)     = 579
    println("add(myInt, myLong)     = " + add(myInt, myLong))     // PRINTS: add(myInt, myLong)     = 1000000455
    println("add(myLong, myFloat)   = " + add(myLong, myFloat))   // PRINTS: add(myLong, myFloat)   = 1.0000009E9
    println("add(myFloat, myDouble) = " + add(myFloat, myDouble)) // PRINTS: add(myFloat, myDouble) = 1235444.433152785
    println("add(myByte, myDouble)  = " + add(myByte, myDouble))  // PRINTS: add(myByte, myDouble)  = 1234690.890123
    println("add(myInt, myFloat)    = " + add(myInt, myFloat))    // PRINTS: add(myInt, myFloat)    = 1332.543
  }
}

========================================================================================

In the sample code below, we make 4 different methods work with multiple data
types by declaring them as parametric methods.

object Demo
{
  def main(args:Array[String]): Unit =
  {
    println(myMethod('X'))           // PRINTS: X
    println(myMethod("My string"))   // PRINTS: My string
    println(myMethod(123.4F))        // PRINTS: 123.4
    println(myMethod(987.6D))        // PRINTS: 987.6

    println(makeTuple(987.6D, 123.4F)) // PRINTS: (987.6,123.4)
    println(makeTuple('A', "zip"))     // PRINTS: (A,zip)

    println(makeThreeElementList('X', 'Y', 'Z'))        // PRINTS: List(X, Y, Z)
    println(makeThreeElementList("Pop", "Stop", "Top")) // PRINTS: List(Pop, Stop, Top)

    val intList:List[Int] = List(1, 2, 3, 4, 5, 6)
    val result_1:Int = ourFold(intList, 0)(_+_)
    println("result_1 = " + result_1) // PRINTS: result_1 = 21

    val stringList:List[String] = List("A", "B", "C")
    val result_2:String = ourFold(stringList, "D")(_+_)
    println("result_2 = " + result_2) // PRINTS: result_2 = ABCD
  }

  /**
   * This is a RECURSIVE, CURRIED METHOD.  The List passed to this method can
   * be of any data type that works with the '+' operator such as Int, Float, String,
   * etc.  The data type must work with the '+' operator because when this ourFold()
   * method gets called (by the main() method) the 'func' parameter passed to
   * it uses the '+' operator.  Therefore, both operands used by the '+' operator
   * must be of the same data type.
   *
   * @param list - A Scala List of type A, where A is a parameterized type.
   * @param base - A value of type A, where A is a parameterized type.
   * @param func - A method defined by the programmer that gets passed
   *               a value of type A, and a value of type A.
   * @return - A value of type A.
   */
  def ourFold[A](list:List[A], base:A)(func:(A,A) => A):A =
  {
    // NOTE: The "def ourFold..." line immediately above can be written either
    //       of these 3 ways, and the returned result will be identical:
    //       1) def ourFold[A](list:List[A], base:A)(func:(A,A) => A):A =
    //       2) def ourFold[A,B](list:List[B], base:A)(func:(B,A) => A):A =
    //       3) def ourFold[B,A](list:List[A], base:B)(func:(A,B) => B):B =

    // NOTE: Every time this ourFold() method gets called recursively below,
    //       the contents of these two (2) arguments remain UNCHANGED:
    //       1) base
    //       2) func
    //       Every time this ourFold() method gets called recursively below,
    //       the list param becomes one (1) element smaller (because list.tail
    //       gets passed to the list argument), until the if() statement
    //       executes, which terminates the recursion.
    if (list.isEmpty) base
    else func(list.head, ourFold(list.tail, base)(func))
  }

  // The below makeTuple() method takes two parameters (one of type A, one of type B),
  // and returns a tuple of type (A, B).
  def makeTuple[A,B](a:A, b:B):(A, B) = (a, b)

  // The below makeThreeElementList() method takes three parameters all of type A,
  // and returns a List of type A, containing the 3 values passed to this method.
  def makeThreeElementList[A](a1:A, a2:A, a3:A):List[A] = List(a1, a2, a3)
}

========================================================================================

The sample code shown below includes this CURRIED, PARAMETRIC METHOD:

def funcOfGunc[A,B,C](func:(B=>C), gunc:(A=>B)):(A=>C) = { x=>func(gunc(x)) }

Recall that a curried method gets called by passing it at least two (2)
separate parameter lists.  The main() method below shows that funcOfGunc gets
passed two (2) parameter lists when it's called, which means funcOfGunc is a
curried method.  However, notice that funcOfGunc is defined with only one
parameter list; yet, it gets called by passing it two (2) parameter lists.

QUESTION:  Since only one argument list appears in the definition of the
           funcOfGunc method, why must funcOfGunc get called by passing
           it two (2) argument lists?
ANSWER:    Notice that funcOfGunc RETURNS THIS METHOD:  x=>func(gunc(x))
           That returned method must get passed the argument x.  Therefore,
           when funcOfGunc is called you must pass to it:
           1) The func and gunc methods as two arguments contained
              in funcOfGunc's single parameter list.
           2) A second parameter list that contains only the value x.  Although
              the funcOfGunc definition DOESN'T show a second parameter list,
              funcOfGunc MUST get called by passing it the value x within a
              second parameter list.

IMPORTANT: Although a curried method gets called by passing it more than
           one parameter list, a curried method DOESN'T always require
           multiple parameter lists in its definition, as this example shows...

           // This funcOfGunc method is defined with only ONE parameter list,
           // but it MUST get called by passing it TWO parameter lists.
           def funcOfGunc[A,B,C](func:(B=>C), gunc:(A=>B)):(A=>C) = { x=>func(gunc(x)) }

The following 4 steps describe how to determine the parametric types (i.e., A, B, C)
used for the argument types, and the return types, in the funcOfGunc definition.

1) When funcOfGunc is called, the FIRST method it executes is gunc.
   So we'll begin by defining the parametric argument type, and the
   parametric return type, for the gunc method.  The gunc method
   is passed a single argument value, and returns a result value.
   Let's choose the first two letters of the alphabet so gunc gets
   passed type A, and returns type B, which translate to this signature:
   gunc:(A=>B)

2) When funcOfGunc is called, the SECOND method it executes is func.  So we
   must define the parametric argument type, and the parametric return type,
   for the func method.  The func method gets passed the type returned
   by the gunc method, which is type B.  The type returned by func we'll
   designate as C (the next letter in the alphabet).  So gunc gets passed
   type B, and returns type C, which translates to this signature:
   func:(B=>C)

3) When funcOfGunc is called, it returns the type returned by func, which
   is type C.  The only thing left to determine is the parametric argument
   type that gets passed to the funcOfGunc method, which is the same type
   passed to the gunc method, type A.  So this is the funcOfGunc signature:
   funcOfGunc:(A=>C)

4) From all the information obtained in Steps 1-3 above we can determine
   the definition of the funcOfGunc method, which is this:

   def funcOfGunc[A,B,C](func:(B=>C), gunc:(A=>B)):(A=>C) = { x=>func(gunc(x)) }

   However, because the A, B, and C data types in the example below
   are all the same (Int types), the above funcOfgunc definition
   can instead be written this way, with ONLY a single parametric
   data type of A:

   def funcOfGunc[A](func:(A=>A), gunc:(A=>A)):(A=>A) = { x=>func(gunc(x)) }

The above text explains the funcOfGunc method implemented in the
sample code shown below.

object Demo
{
  def main(args:Array[String]): Unit =
  {
    // The following "plus5" and "square" vals are defined as methods
    // that take a parameter of type Double, and return a type Double.
    val plus5:(Double=>Double)  = { x:Double => x+5.0D }
    val square:(Double=>Double) = { x:Double => x*x }

    // NOTE: 54.0 = 5.0+(7.0*7.0)
    var result:Double = funcOfGunc(plus5, square)(7.0D)
    println("result = " + result) // PRINTS: result = 54.0

    // NOTE: 144.0 = (5.0+7.0)*(5.0+7.0)
    result = funcOfGunc(square, plus5)(7.0D)
    println("result = " + result) // PRINTS: result = 144.0
  }

  // NOTE: Because the A, B, and C data types in the funcOfGunc definition below
  //       are all Int types, it can instead be writen the following way, with
  //       ONLY a single parametric data type A:
  //       def funcOfGunc[A](func:(A=>A), gunc:(A=>A)):(A=>A) = { x=>func(gunc(x)) }
  //
  def funcOfGunc[A,B,C](func:(B=>C), gunc:(A=>B)):(A=>C) = { x=>func(gunc(x)) }
}

========================================================================================
This code sample shows how to declare and use a parametric class
named "Sequence", as well the parametic method named "map".

import scala.collection.mutable.ListBuffer
object Demo
{
  case class Person(firstName:String, lastName:String)
  case class Sequence[A](private val initialElems: A*) // A* designates a variable number of args of type A.
  {
    // The following 2 lines of code get executed every time the this Sequence class is instantiated.
    private val elems:ListBuffer[A] = ListBuffer[A]()
    elems ++= initialElems // The ++= operator for the ListBuffer class appends multiple elements.
    // NOTE: "elems ++= initialElems" above could be replaced with:  for { x <- initialElems } elems += x

    // When you create your own class (or case class), you must define the following
    // 4 methods inside your class to make the class work with for() expressions.
    // That's what the remaining code inside this Sequence class accomplishes.
    // 1) foreach()
    // 2) map()
    // 3) flatMap()
    // 4) withFilter()

    /*********************************************************
     * NOTE: This foreach() method enables the main() method
     *       below to implement this type of for loop on this
     *       Sequence case class:  for (x <- ints) println(x)
     ********************************************************/
    def foreach(blockOfCode:A => Unit):Unit =
    {
      // The foreach() method always gets passed a block of Scala code.
      elems.foreach{blockOfCode}
    }

    /*********************************************************
     * NOTE: This map() method enables the main() method
     *       below to implement this type of for loop on
     *       this Sequence case class:
     *       for { x <- ints } yield x*2
     ********************************************************/
    def map[B](func: A=>B):Sequence[B] =
    {
      val listBuf:ListBuffer[B] = elems.map(func)
      // NOTE: The :_* below is the syntax used when calling a constructor, or a method,
      //       that accepts a variable number of arguments.  In this example, since
      //       the Sequence constructor is written to accept a variable number of args,
      //       the :_* text must be included.
      Sequence(listBuf.toSeq:_*)
    }

    /*********************************************************
     * NOTE: This flatMap() method enables the main() method
     *       below to implement MULTIPLE GENERATORS within
     *       a for loop on this Sequence case class.
     ********************************************************/
    def flatMap[B](func: A => Sequence[B]):Sequence[B] =
    {
      var listBuf_1:ListBuffer[B] = ListBuffer[B]()
      for (listBuf_2:Sequence[B] <- map(func)) // map(func) calls the above-defined map() method.
      {
        for (elem <- listBuf_2) { listBuf_1 += elem }
      }
      // NOTE: The :_* below is the syntax used when calling a constructor, or a method,
      //       that accepts a variable number of arguments.  In this example, since
      //       the Sequence constructor is written to accept a variable number of args,
      //       the :_* text must be included.
      Sequence(listBuf_1.toSeq:_*)
    }

    /*********************************************************
     * NOTE: This withFilter() method enables the main()
     *       method below to implement filters within
     *       for loops on this Sequence case class:
     ********************************************************/
    def withFilter(func: A => Boolean):Sequence[A] =
    {
      val listBuf:ListBuffer[A] = elems.filter(func)
      // NOTE: The :_* below is the syntax used when calling a constructor, or a method,
      //       that accepts a variable number of arguments.  In this example, since
      //       the Sequence constructor is written to accept a variable number of args,
      //       the :_* text must be included.
      Sequence(listBuf.toSeq:_*)
    }
  } // END: case class Sequence[A]


  def main(args:Array[String]): Unit =
  {
    // NOTE: The Sequence class can work with different types (i.e., String, Int, Person etc.) because
    //       it's defined as a parametric class, where the data type is determined at run time.
    val strings:Sequence[String] = Sequence("one", "two", "three")
    val numbers:Sequence[Int]    = Sequence(1, 2, 3, 4, 5)
    val names:Sequence[Person]   = Sequence(Person("Joe", "Blow"),
                                            Person("Jack", "Smack"),
                                            Person("Frank", "Crank"))

    // NOTE: The following 3 for() loops would cause compile errors if the foreach()
    //       and map() methods weren't defined in the above Sequence class.  The
    //       if() statement embedded within the 2nd for() loop below would cause
    //       a compile error if the withFilter() method wasn't defined in the
    //       above Sequence class.  To summarize...
    //       1) The generators shown below (i.e., "for (str < strings)") work because
    //          Sequence.foreach() is defined above.
    //       2) The below yield statements work because Sequence.map() is defined above.
    //       3) The below "if i > 2" statement works because Sequence.withFilter() is defined above.
    val strResult:Sequence[String]    = for (str <- strings)           yield str
    val intResult:Sequence[Int]       = for { i <- numbers; if i > 2 } yield i*2
    val personResult:Sequence[Person] = for (name <- names)            yield name

    for (str <- strResult) print(str + " ") // PRINTS: one two three
    println
    for (int <- intResult) print(int + " ") // PRINTS: 6 8 10
    println
    for (name <- personResult) print(name + " ") // PRINTS: Person(Joe,Blow) Person(Jack,Smack) Person(Frank,Crank)
    println

    // The following code REQUIRES the flatMap() method to be defined by the above case class named Sequence.
    val myFriends:Sequence[Person]   = Sequence(Person("Jack", "Daniels"),
                                                Person("Johnny", "Walker"),
                                                Person("Jim", "Beam"))
    val joesFriends:Sequence[Person] = Sequence(Person("Joseph", "Schlitz"),
                                                Person("George", "Jones"),
                                                Person("Jim", "Beam"))

    // For a class to work with MULTIPLE for() loop generators (as shown here), that class
    // MUST implement a flatMap() method--as in the above-defined Sequence class.
    val mutualFriends:Sequence[Person] = for
    {
      myFriend   <- myFriends   // This is a GENERATOR.
      joesFriend <- joesFriends // This is another GENERATOR.
      if (myFriend.firstName == joesFriend.firstName &&
        myFriend.lastName  == joesFriend.lastName)
    } yield myFriend
    println("mutualFriends = " + mutualFriends) // PRINTS: mutualFriends = Sequence(ArrayBuffer(Person(Jim,Beam)))
  }
}

========================================================================================

