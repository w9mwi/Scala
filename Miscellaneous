// ================================================================
// How to use the keyword 'type'.  You can create your own type
// names in Scala by using existing types.  When you create your
// own type, that type name should begin with a single uppercase
// character.  Here are two examples--type Couner and type Location.
object Demo
{
  type Counter  = Int
  type Location = (Int, Int, Int)

  def main(args: Array[String]): Unit =
  {
    var miles:Counter = 0
    val milesLimit:Int = 10

    do
    {
      println("miles = " + miles)
      miles += 1
    }
    while(miles <= milesLimit)

    val beginPoint:Location = (0, 0, 0)
    val endPoint:Location   = (2, 10, 3)
    var coordinate:Location = beginPoint
    var x:Int = 0; var y:Int = 0; var z:Int = 0;

    println("coordinate = (" + coordinate._1 + ", " + coordinate._2 + ", " + coordinate._3 + ")")
    while(coordinate._1 < endPoint._1 || coordinate._2 < endPoint._2 || coordinate._3 < endPoint._3)
    {
      if (coordinate._1 < endPoint._1)  x += 1;
      if (coordinate._2 < endPoint._2)  y += 1;
      if (coordinate._3 < endPoint._3)  z += 1;
      coordinate = (x, y, z)
      println("coordinate = (" + coordinate._1 + ", " + coordinate._2 + ", " + coordinate._3 + ")")
    }
  }
}
// ================================================================
// The following is an example of how to use implicit class.
// Using an implicit class, you can add new methods to an
// existing class.  In this example we add the decrement()
// and increment() methods to the existing Scala String class.
//
// Assume you create a var of type String named 'state'. Now,
// when you type the text 'state.', your new decrement and
// increment methods will appear in the list of methods to
// choose from.
//
// For this to work, your implicit class must have a single
// parameter (that matches the type of an existing Scala type),
// and your new method name(s) must be different than existing
// method names of that type.
object Demo
{
  class EnhancedString(val str: String)
  {
    def decrement:String = { str.map(ch => (ch - 1).toChar) }
    def increment:String = { str.map(ch => (ch + 1).toChar) }
  }
  implicit def stringToString(str: String) = new EnhancedString(str)

  def main(args: Array[String]): Unit =
  {
    var state:String = "Wisconsin"
    state = state.increment
    println(state)
    state = state.decrement
    println(state)
  }
}
// ================================================================
Every object in Scala is an instance of the "Any" object, because the
"Any" object is the parent of ALL other objects.  The Any object is
the direct parent of these two objects: AnyVal and AnyRef

The "Nothing" object (which has no value) is a subtype of ALL Scala
objects, and it exists to handle situations when functions don't
return a value.
// ================================================================
// HOW TO PASS A FUNCTION A VARIABLE NUMBER OF ARGUMENTS - PART 1
// See the PART 2 example below to see a better way of doing the
// same thing.
object Demo
{
  def main(args:Array[String]): Unit =
  {
    var averageScore = calculateAverage() // Pass no parameters!
    printScore(averageScore, "averageScore = ")

    averageScore = calculateAverage(1.23, 4.56, 7.89)
    printScore(averageScore, "averageScore = ")
  }

  /**
    * @param numbers - A Sequence of Double values representing a variable number of arguments.
    *                  A variable number of arguments is represented by the asterisk (*)
    *                  character in the parameter list.
    * @return a Double value representing the average of all values passed to this function.
    */
  def calculateAverage(numbers:Double *): Double = { numbers.sum / numbers.length }

  /**
    * @param score
    * @param msg
    */
  def printScore(score:Double, msg:String):Unit =
  {
    if (score.isNaN) println("The score is not a number.") else println(msg + score)
  }
}
// ================================================================
// HOW TO PASS A FUNCTION A VARIABLE NUMBER OF ARGUMENTS - PART 2
// This is a better alternative to doing the same thing done in
// the PART 1 example above.
object Demo
{
  def main(args:Array[String]): Unit =
  {
    var scores:List[Double] = List()
    var averageScore = calculateAverage(scores:_*)
    printScore(averageScore, "averageScore = ")

    scores = List(1.23, 4.56, 7.89)
    averageScore = calculateAverage(scores:_*)
    printScore(averageScore, "averageScore = ")
  }

  /**
    * @param numbers - A Sequence of Double values representing a variable number of arguments.
    *                  A variable number of arguments is represented by the asterisk (*)
    *                  character in the parameter list.
    * @return a Double value representing the average of all values passed to this function.
    */
  def calculateAverage(numbers:Double *): Double = { numbers.sum / numbers.length }

  /**
    * @param score
    * @param msg
    */
  def printScore(score:Double, msg:String):Unit =
  {
    if (score.isNaN) println("The score is not a number.") else println(msg + score)
  }
}
// ================================================================
// ================================================================
