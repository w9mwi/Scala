A Scala "view" is a special kind of collection that represents some base collection,
(i.e., Array, List, etc.) but implements all TRANSFORMERS lazily.  To understand
what this means, keep reading.

Scala Collections (Arrays, Lists, etc.) contain methods that construct new collections.
Some examples are...

The map() method.
The filter() method.
The "++" operator method.

Methods such as these are called TRANSFORMERS because they take at least one collection
as their receiver object, and generate another collection as their result.

There are TWO (2) ways to implement transformers.

1) STRICT - A new collection with all its elements is constructed as a result
            of the transformer.  This is what's used 99% of the time.  When
            the List.filter() method, or the List.map() method is called,
            they're almost always called on a STRICT List.

2) NON-STRICT OR LAZY - Only a proxy is constructed for the result collection.
                        Its resulting elements get constructed ONLY when you
                        access them.

To transform a strict collection into a non-strict (lazy) collection,
invoke the view() method on the collection.

To transform a non-strict (lazy) collection back into into a strict collection,
invoke the to() method on the collection.

The main reason for using views is performance.  By switching a collection to
a view, the construction of intermediate results can be avoided.  Below is an
example program.

To learn more, read this web page:
https://docs.scala-lang.org/overviews/collections-2.13/views.html#


import scala.collection.SeqView
object Demo
{
  /********************************************
   * main()
   ********************************************/
  def main(args: Array[String]): Unit =
  {
    println("PART 1) =============================")
    // Here we initialize vect.
    val vect:Vector[Int] = Vector(1 to 10: _*)
    vect.foreach(println)

    println("\nPART 2) =============================")
    // In this example each call to map() generates a new result.
    var result:Vector[Int] = vect.map(_ + 1).map(_ * 2)
    result.foreach(println)

    println("\nPART 3) =============================")
    // Here we see that calling vect.view() transforms vect (a strict
    // collection) into a lazy/non-strict collection.
    val seqView1:SeqView[Int, Vector[Int]] = vect.view

    println("\nPART 4) =============================")
    // When map() is called on seqView1 (a lazy/non-strict collection)
    // no result is generated, but the data type returned does change.
    val seqView2:SeqView[Int, Seq[_]] = seqView1.map(_ + 1)
    // seqView2.foreach(println)

    println("\nPART 5) =============================")
    // We now invoke the map() method on seqView2, and are ready to generate
    // a result, which means we must obtain a non-strict collection.
    // NOTE: The to() method below transforms the non-strict collection
    //       SeqView[Int, Seq[_]] into a strict collection (IndexedSeq[Int]).
    //       The toVector() method below transforms the data type from
    //       IndexedSeq[Int] into Vector[Int].
    result = seqView2.map(_ * 2).to.toVector
    result.foreach(println)

    println("\nPART 6) =============================")
    // Here we combine PART 3), PART 4) and PART 5) above into a single line of equivalent code.
    result = vect.view.map(_ + 1).map(_ * 2).to.toVector
    result.foreach(println)
  }
}

============================================================================
Here is another example of how calling the view() prevents an intermediary
Sequence being generated that may be too large.  Read in-line comments for
details.


object Demo
{
  def isPalindrome(str:String):Boolean                    = { str == str.reverse }
  def findFirstPalindrome(seq:Seq[String]):Option[String] = seq.find(isPalindrome)

  /********************************************
   * main() function
   ********************************************/
  def main(args: Array[String])
  {
    println("PART 1) ==============================")
    // If you attempt to execute the following commented-out line of code, this error will
    // be thrown:  Exception in thread "main" java.lang.OutOfMemoryError: Java heap space
    // This occurs because an intermediary Sequence containing Int.MaxValue (2,147,483,647)
    // elements is constructed BEFORE "filter(_ % 2 == 0).take(10)" is invoked.
    // var myList:List[Int] = (1 to Int.MaxValue).filter(_ % 2 == 0).take(10).toList

    // To prevent an intermediary Sequence of Int.MaxValue (2,147,483,647) elements
    // from being constructed, the view method is added to the above line of
    // commented-out code.  The view method transforms a strict Sequence into
    // a non-strict/lazy Sequence.  Therefore, when "filter(_ % 2 == 0).take(10)"
    // is invoked, an intermediary Sequence of only 10 elements is constructed.
    var myList:List[Int] = (1 to Int.MaxValue).view.filter(_ % 2 == 0).take(10).toList
    println(s"No. of elements in myList = ${myList.size}") // PRINTS: No. of elements in myList = 10
    println(s"myList = $myList") // PRINTS: myList = List(2, 4, 6, 8, 10, 12, 14, 16, 18, 20)


    println("PART 2) ==============================")
    // Make myString is a very long string.  In a real application,
    // this string could have a size of many megabytes.
    val myString:String = "Marion Robert Morrison radar (May 26, 1907 to June 11, 1979), known professionally as John Wayne oxo"
    println(s"myString length = ${myString.length}")

    // Transform myString into an Array of strings (words).
    val myStrArray:Array[String] = myString.split(" ")
    println(s"Number of elements in myStrArray = ${myStrArray.length}")

    // Obtain the first word in myStrArray that's a palindrome.
    // Here, we do it in the standard way.  NOTE: Calling it
    // this way (where myStrArray.view represents a non-strict/lazy
    // Array) also works:       findFirstPalindrome(myStrArray.view)
    var result:Option[String] = findFirstPalindrome(myStrArray)
    println(s"result 1 = ${result.get}") // PRINTS: result 1 = radar

    // Here we "take" 999 elements of myStrArray and pass them to
    // findFirstPalindrome().
    // IMPORTANT: If myStrArray was super-large, and we were to "take" a
    //            number equal to the size of myStrArray, an OutOfMemory
    //            exception could be thrown because an intermediary
    //            Sequence of that size would be constructed first.
    result = findFirstPalindrome(myStrArray take 15)
    println(s"result 2 = ${result.get}")  // PRINTS: result 2 = radar

    // Here we first transform myStrArray into a view (a non-strict/lazy
    // Array) before "take(999)" is called.  Calling view prevents the
    // construction of an intermediary Sequence of size 15.
    result = findFirstPalindrome(myStrArray.view.take(15))
    println(s"result 3 = ${result.get}")  // PRINTS: result 3 = radar
  }
}

============================================================================
